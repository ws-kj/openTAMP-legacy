.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "MPI4PY" "1" "Nov 25, 2021" "3.1" "MPI for Python"
.SH NAME
mpi4py \- MPI for Python
.INDENT 0.0
.TP
.B Author
Lisandro Dalcin
.TP
.B Contact
\fI\%dalcinl@gmail.com\fP
.TP
.B Date
Nov 25, 2021
.UNINDENT
.SS Abstract
.sp
This document describes the \fIMPI for Python\fP package. \fIMPI for
Python\fP provides Python bindings for the \fIMessage Passing
Interface\fP (MPI) standard, allowing Python applications to exploit
multiple processors on workstations, clusters and supercomputers.
.sp
This package builds on the MPI specification and provides an object
oriented interface resembling the MPI\-2 C++ bindings. It supports
point\-to\-point (sends, receives) and collective (broadcasts,
scatters, gathers) communication of any \fIpicklable\fP Python object,
as well as efficient communication of Python objects exposing the
Python buffer interface (e.g. NumPy arrays and builtin
bytes/array/memoryview objects).
.SH INTRODUCTION
.sp
Over the last years, high performance computing has become an
affordable resource to many more researchers in the scientific
community than ever before. The conjunction of quality open source
software and commodity hardware strongly influenced the now widespread
popularity of \fI\%Beowulf\fP class clusters and cluster of workstations.
.sp
Among many parallel computational models, message\-passing has proven
to be an effective one.  This paradigm is specially suited for (but
not limited to) distributed memory architectures and is used in
today’s most demanding scientific and engineering application related
to modeling, simulation, design, and signal processing.  However,
portable message\-passing parallel programming used to be a nightmare
in the past because of the many incompatible options developers were
faced to.  Fortunately, this situation definitely changed after the
MPI Forum released its standard specification.
.sp
High performance computing is traditionally associated with software
development using compiled languages. However, in typical applications
programs, only a small part of the code is time\-critical enough to
require the efficiency of compiled languages. The rest of the code is
generally related to memory management, error handling, input/output,
and user interaction, and those are usually the most error prone and
time\-consuming lines of code to write and debug in the whole
development process.  Interpreted high\-level languages can be really
advantageous for this kind of tasks.
.sp
For implementing general\-purpose numerical computations, MATLAB [1]
is the dominant interpreted programming language. In the open source
side, Octave and Scilab are well known, freely distributed software
packages providing compatibility with the MATLAB language. In this
work, we present MPI for Python, a new package enabling applications
to exploit multiple processors using standard MPI “look and feel” in
Python scripts.
.IP [1] 5
MATLAB is a registered trademark of The MathWorks, Inc.
.SS What is MPI?
.sp
\fI\%MPI\fP, [mpi\-using] [mpi\-ref] the \fIMessage Passing Interface\fP, is a
standardized and portable message\-passing system designed to function
on a wide variety of parallel computers. The standard defines the
syntax and semantics of library routines and allows users to write
portable programs in the main scientific programming languages
(Fortran, C, or C++).
.sp
Since its release, the MPI specification [mpi\-std1] [mpi\-std2] has
become the leading standard for message\-passing libraries for parallel
computers.  Implementations are available from vendors of
high\-performance computers and from well known open source projects
like \fI\%MPICH\fP [mpi\-mpich] and \fI\%Open MPI\fP [mpi\-openmpi]\&.
.SS What is Python?
.sp
\fI\%Python\fP is a modern, easy to learn, powerful programming language. It
has efficient high\-level data structures and a simple but effective
approach to object\-oriented programming with dynamic typing and
dynamic binding. It supports modules and packages, which encourages
program modularity and code reuse. Python’s elegant syntax, together
with its interpreted nature, make it an ideal language for scripting
and rapid application development in many areas on most platforms.
.sp
The Python interpreter and the extensive standard library are
available in source or binary form without charge for all major
platforms, and can be freely distributed. It is easily extended with
new functions and data types implemented in C or C++. Python is also
suitable as an extension language for customizable applications.
.sp
Python is an ideal candidate for writing the higher\-level parts of
large\-scale scientific applications [Hinsen97] and driving
simulations in parallel architectures [Beazley97] like clusters of
PC’s or SMP’s. Python codes are quickly developed, easily maintained,
and can achieve a high degree of integration with other libraries
written in compiled languages.
.SS Related Projects
.sp
As this work started and evolved, some ideas were borrowed from well
known MPI and Python related open source projects from the Internet.
.INDENT 0.0
.IP \(bu 2
\fI\%OOMPI\fP
.INDENT 2.0
.IP \(bu 2
It has no relation with Python, but is an excellent object
oriented approach to MPI.
.IP \(bu 2
It is a C++ class library specification layered on top of the C
bindings that encapsulates MPI into a functional class hierarchy.
.IP \(bu 2
It provides a flexible and intuitive interface by adding some
abstractions, like \fIPorts\fP and \fIMessages\fP, which enrich and
simplify the syntax.
.UNINDENT
.IP \(bu 2
\fI\%Pypar\fP
.INDENT 2.0
.IP \(bu 2
Its interface is rather minimal. There is no support for
communicators or process topologies.
.IP \(bu 2
It does not require the Python interpreter to be modified or
recompiled, but does not permit interactive parallel runs.
.IP \(bu 2
General (\fIpicklable\fP) Python objects of any type can be
communicated. There is good support for numeric arrays,
practically full MPI bandwidth can be achieved.
.UNINDENT
.IP \(bu 2
\fI\%pyMPI\fP
.INDENT 2.0
.IP \(bu 2
It rebuilds the Python interpreter providing a built\-in module
for message passing. It does permit interactive parallel runs,
which are useful for learning and debugging.
.IP \(bu 2
It provides an interface suitable for basic parallel programing.
There is not full support for defining new communicators or process
topologies.
.IP \(bu 2
General (picklable) Python objects can be messaged between
processors. There is not support for numeric arrays.
.UNINDENT
.IP \(bu 2
\fI\%Scientific Python\fP
.INDENT 2.0
.IP \(bu 2
It provides a collection of Python modules that are
useful for scientific computing.
.IP \(bu 2
There is an interface to MPI and BSP (\fIBulk Synchronous Parallel
programming\fP).
.IP \(bu 2
The interface is simple but incomplete and does not resemble
the MPI specification. There is support for numeric arrays.
.UNINDENT
.UNINDENT
.sp
Additionally, we would like to mention some available tools for
scientific computing and software development with Python.
.INDENT 0.0
.IP \(bu 2
\fI\%NumPy\fP is a package that provides array manipulation and
computational capabilities similar to those found in IDL, MATLAB, or
Octave. Using NumPy, it is possible to write many efficient
numerical data processing applications directly in Python without
using any C, C++ or Fortran code.
.IP \(bu 2
\fI\%SciPy\fP is an open source library of scientific tools for Python,
gathering a variety of high level science and engineering modules
together as a single package. It includes modules for graphics and
plotting, optimization, integration, special functions, signal and
image processing, genetic algorithms, ODE solvers, and others.
.IP \(bu 2
\fI\%Cython\fP is a language that makes writing C extensions for the
Python language as easy as Python itself. The Cython language is
very close to the Python language, but Cython additionally supports
calling C functions and declaring C types on variables and class
attributes. This allows the compiler to generate very efficient C
code from Cython code. This makes Cython the ideal language for
wrapping for external C libraries, and for fast C modules that speed
up the execution of Python code.
.IP \(bu 2
\fI\%SWIG\fP is a software development tool that connects programs
written in C and C++ with a variety of high\-level programming
languages like Perl, Tcl/Tk, Ruby and Python. Issuing header files
to SWIG is the simplest approach to interfacing C/C++ libraries from
a Python module.
.UNINDENT
.IP [mpi-std1] 5
MPI Forum. MPI: A Message Passing Interface Standard.
International Journal of Supercomputer Applications, volume 8,
number 3\-4, pages 159\-416, 1994.
.IP [mpi-std2] 5
MPI Forum. MPI: A Message Passing Interface Standard.
High Performance Computing Applications, volume 12, number 1\-2,
pages 1\-299, 1998.
.IP [mpi-using] 5
William Gropp, Ewing Lusk, and Anthony Skjellum.  Using
MPI: portable parallel programming with the message\-passing
interface.  MIT Press, 1994.
.IP [mpi-ref] 5
Mark Snir, Steve Otto, Steven Huss\-Lederman, David
Walker, and Jack Dongarra.  MPI \- The Complete Reference, volume 1,
The MPI Core.  MIT Press, 2nd. edition, 1998.
.IP [mpi-mpich] 5
W. Gropp, E. Lusk, N. Doss, and A. Skjellum.  A
high\-performance, portable implementation of the MPI message
passing interface standard.  Parallel Computing, 22(6):789\-828,
September 1996.
.IP [mpi-openmpi] 5
Edgar Gabriel, Graham E. Fagg, George Bosilca, Thara
Angskun, Jack J. Dongarra, Jeffrey M. Squyres, Vishal Sahay,
Prabhanjan Kambadur, Brian Barrett, Andrew Lumsdaine, Ralph
H. Castain, David J. Daniel, Richard L. Graham, and Timothy
S. Woodall. Open MPI: Goals, Concept, and Design of a Next
Generation MPI Implementation. In Proceedings, 11th European
PVM/MPI Users’ Group Meeting, Budapest, Hungary, September 2004.
.IP [Hinsen97] 5
Konrad Hinsen.  The Molecular Modelling Toolkit: a case
study of a large scientific application in Python.  In Proceedings
of the 6th International Python Conference, pages 29\-35, San Jose,
Ca., October 1997.
.IP [Beazley97] 5
David M. Beazley and Peter S. Lomdahl.  Feeding a
large\-scale physics application to Python.  In Proceedings of the
6th International Python Conference, pages 21\-29, San Jose, Ca.,
October 1997.
.SH OVERVIEW
.sp
MPI for Python provides an object oriented approach to message passing
which grounds on the standard MPI\-2 C++ bindings. The interface was
designed with focus in translating MPI syntax and semantics of
standard MPI\-2 bindings for C++ to Python. Any user of the standard
C/C++ MPI bindings should be able to use this module without need of
learning a new interface.
.SS Communicating Python Objects and Array Data
.sp
The Python standard library supports different mechanisms for data
persistence. Many of them rely on disk storage, but \fIpickling\fP and
\fImarshaling\fP can also work with memory buffers.
.sp
The \fI\%pickle\fP modules provide user\-extensible facilities to
serialize general Python objects using ASCII or binary formats. The
\fI\%marshal\fP module provides facilities to serialize built\-in Python
objects using a binary format specific to Python, but independent of
machine architecture issues.
.sp
\fIMPI for Python\fP can communicate any built\-in or user\-defined Python
object taking advantage of the features provided by the \fI\%pickle\fP
module. These facilities will be routinely used to build binary
representations of objects to communicate (at sending processes), and
restoring them back (at receiving processes).
.sp
Although simple and general, the serialization approach (i.e.,
\fIpickling\fP and \fIunpickling\fP) previously discussed imposes important
overheads in memory as well as processor usage, especially in the
scenario of objects with large memory footprints being
communicated. Pickling general Python objects, ranging from primitive
or container built\-in types to user\-defined classes, necessarily
requires computer resources.  Processing is also needed for
dispatching the appropriate serialization method (that depends on the
type of the object) and doing the actual packing. Additional memory is
always needed, and if its total amount is not known \fIa priori\fP, many
reallocations can occur.  Indeed, in the case of large numeric arrays,
this is certainly unacceptable and precludes communication of objects
occupying half or more of the available memory resources.
.sp
\fIMPI for Python\fP supports direct communication of any object exporting
the single\-segment buffer interface. This interface is a standard
Python mechanism provided by some types (e.g., strings and numeric
arrays), allowing access in the C side to a contiguous memory buffer
(i.e., address and length) containing the relevant data. This feature,
in conjunction with the capability of constructing user\-defined MPI
datatypes describing complicated memory layouts, enables the
implementation of many algorithms involving multidimensional numeric
arrays (e.g., image processing, fast Fourier transforms, finite
difference schemes on structured Cartesian grids) directly in Python,
with negligible overhead, and almost as fast as compiled Fortran, C,
or C++ codes.
.SS Communicators
.sp
In \fIMPI for Python\fP, \fBComm\fP is the base class of communicators. The
\fBIntracomm\fP and \fBIntercomm\fP classes are sublcasses of the \fBComm\fP
class.  The \fBComm.Is_inter\fP method (and \fBComm.Is_intra\fP, provided for
convenience but not part of the MPI specification) is defined for
communicator objects and can be used to determine the particular
communicator class.
.sp
The two predefined intracommunicator instances are available:
\fBCOMM_SELF\fP and \fBCOMM_WORLD\fP\&. From them, new communicators can be
created as needed.
.sp
The number of processes in a communicator and the calling process rank
can be respectively obtained with methods \fBComm.Get_size\fP and
\fBComm.Get_rank\fP\&. The associated process group can be retrieved from a
communicator by calling the \fBComm.Get_group\fP method, which returns an
instance of the \fBGroup\fP class. Set operations with \fBGroup\fP objects
like like \fBGroup.Union\fP, \fBGroup.Intersection\fP and \fBGroup.Difference\fP
are fully supported, as well as the creation of new communicators from
these groups using \fBComm.Create\fP and \fBComm.Create_group\fP\&.
.sp
New communicator instances can be obtained with the \fBComm.Clone\fP,
\fBComm.Dup\fP and \fBComm.Split\fP methods, as well methods
\fBIntracomm.Create_intercomm\fP and \fBIntercomm.Merge\fP\&.
.sp
Virtual topologies (\fBCartcomm\fP, \fBGraphcomm\fP and \fBDistgraphcomm\fP
classes, which are specializations of the \fBIntracomm\fP class) are fully
supported. New instances can be obtained from intracommunicator
instances with factory methods \fBIntracomm.Create_cart\fP and
\fBIntracomm.Create_graph\fP\&.
.SS Point\-to\-Point Communications
.sp
Point to point communication is a fundamental capability of message
passing systems. This mechanism enables the transmission of data
between a pair of processes, one side sending, the other receiving.
.sp
MPI provides a set of \fIsend\fP and \fIreceive\fP functions allowing the
communication of \fItyped\fP data with an associated \fItag\fP\&.  The type
information enables the conversion of data representation from one
architecture to another in the case of heterogeneous computing
environments; additionally, it allows the representation of
non\-contiguous data layouts and user\-defined datatypes, thus avoiding
the overhead of (otherwise unavoidable) packing/unpacking
operations. The tag information allows selectivity of messages at the
receiving end.
.SS Blocking Communications
.sp
MPI provides basic send and receive functions that are \fIblocking\fP\&.
These functions block the caller until the data buffers involved in
the communication can be safely reused by the application program.
.sp
In \fIMPI for Python\fP, the \fBComm.Send\fP, \fBComm.Recv\fP and \fBComm.Sendrecv\fP
methods of communicator objects provide support for blocking
point\-to\-point communications within \fBIntracomm\fP and \fBIntercomm\fP
instances. These methods can communicate memory buffers. The variants
\fBComm.send\fP, \fBComm.recv\fP and \fBComm.sendrecv\fP can communicate general
Python objects.
.SS Nonblocking Communications
.sp
On many systems, performance can be significantly increased by
overlapping communication and computation. This is particularly true
on systems where communication can be executed autonomously by an
intelligent, dedicated communication controller.
.sp
MPI provides \fInonblocking\fP send and receive functions. They allow the
possible overlap of communication and computation.  Non\-blocking
communication always come in two parts: posting functions, which begin
the requested operation; and test\-for\-completion functions, which
allow to discover whether the requested operation has completed.
.sp
In \fIMPI for Python\fP, the \fBComm.Isend\fP and \fBComm.Irecv\fP methods
initiate send and receive operations, respectively. These methods
return a \fBRequest\fP instance, uniquely identifying the started
operation.  Its completion can be managed using the \fBRequest.Test\fP,
\fBRequest.Wait\fP and \fBRequest.Cancel\fP methods. The management of
\fBRequest\fP objects and associated memory buffers involved in
communication requires a careful, rather low\-level coordination. Users
must ensure that objects exposing their memory buffers are not
accessed at the Python level while they are involved in nonblocking
message\-passing operations.
.SS Persistent Communications
.sp
Often a communication with the same argument list is repeatedly
executed within an inner loop. In such cases, communication can be
further optimized by using persistent communication, a particular case
of nonblocking communication allowing the reduction of the overhead
between processes and communication controllers. Furthermore , this
kind of optimization can also alleviate the extra call overheads
associated to interpreted, dynamic languages like Python.
.sp
In \fIMPI for Python\fP, the \fBComm.Send_init\fP and \fBComm.Recv_init\fP methods
create persistent requests for a send and receive operation,
respectively.  These methods return an instance of the \fBPrequest\fP
class, a subclass of the \fBRequest\fP class. The actual communication can
be effectively started using the \fBPrequest.Start\fP method, and its
completion can be managed as previously described.
.SS Collective Communications
.sp
Collective communications allow the transmittal of data between
multiple processes of a group simultaneously. The syntax and semantics
of collective functions is consistent with point\-to\-point
communication. Collective functions communicate \fItyped\fP data, but
messages are not paired with an associated \fItag\fP; selectivity of
messages is implied in the calling order. Additionally, collective
functions come in blocking versions only.
.sp
The more commonly used collective communication operations are the
following.
.INDENT 0.0
.IP \(bu 2
Barrier synchronization across all group members.
.IP \(bu 2
Global communication functions
.INDENT 2.0
.IP \(bu 2
Broadcast data from one member to all members of a group.
.IP \(bu 2
Gather data from all members to one member of a group.
.IP \(bu 2
Scatter data from one member to all members of a group.
.UNINDENT
.IP \(bu 2
Global reduction operations such as sum, maximum, minimum, etc.
.UNINDENT
.sp
In \fIMPI for Python\fP, the \fBComm.Bcast\fP, \fBComm.Scatter\fP, \fBComm.Gather\fP,
\fBComm.Allgather\fP, \fBComm.Alltoall\fP methods provide support for
collective communications of memory buffers. The lower\-case variants
\fBComm.bcast\fP, \fBComm.scatter\fP, \fBComm.gather\fP, \fBComm.allgather\fP and
\fBComm.alltoall\fP can communicate general Python objects.  The vector
variants (which can communicate different amounts of data to each
process) \fBComm.Scatterv\fP, \fBComm.Gatherv\fP, \fBComm.Allgatherv\fP,
\fBComm.Alltoallv\fP and \fBComm.Alltoallw\fP are also supported, they can
only communicate objects exposing memory buffers.
.sp
Global reducion operations on memory buffers are accessible through
the \fBComm.Reduce\fP, \fBComm.Reduce_scatter\fP, \fBComm.Allreduce\fP,
\fBIntracomm.Scan\fP and \fBIntracomm.Exscan\fP methods. The lower\-case
variants \fBComm.reduce\fP, \fBComm.allreduce\fP, \fBIntracomm.scan\fP and
\fBIntracomm.exscan\fP can communicate general Python objects; however,
the actual required reduction computations are performed sequentially
at some process. All the predefined (i.e., \fBSUM\fP, \fBPROD\fP, \fBMAX\fP, etc.)
reduction operations can be applied.
.SS Support for GPU\-aware MPI
.sp
Several MPI implementations, including Open MPI and MVAPICH, support
passing GPU pointers to MPI calls to avoid explict data movement
between the host and the device. On the Python side, GPU arrays have
been implemented by many libraries that need GPU computation, such as
CuPy, Numba, PyTorch, and PyArrow. In order to increase library
interoperability, two kinds of zero\-copy data exchange protocols are
defined and agreed upon: \fI\%DLPack\fP and \fI\%CUDA Array Interface\fP\&. For
example, a CuPy array can be passed to a Numba CUDA\-jit kernel.
.sp
\fIMPI for Python\fP provides an experimental support for GPU\-aware MPI.
This feature requires:
.INDENT 0.0
.IP 1. 3
mpi4py is built against a GPU\-aware MPI library.
.IP 2. 3
The Python GPU arrays are compliant with either of the protocols.
.UNINDENT
.sp
See the tutorial section for further information. We note that
.INDENT 0.0
.IP \(bu 2
Whether or not a MPI call can work for GPU arrays depends on the
underlying MPI implementation, not on mpi4py.
.IP \(bu 2
This support is currently experimental and subject to change in the
future.
.UNINDENT
.SS Dynamic Process Management
.sp
In the context of the MPI\-1 specification, a parallel application is
static; that is, no processes can be added to or deleted from a
running application after it has been started. Fortunately, this
limitation was addressed in MPI\-2. The new specification added a
process management model providing a basic interface between an
application and external resources and process managers.
.sp
This MPI\-2 extension can be really useful, especially for sequential
applications built on top of parallel modules, or parallel
applications with a client/server model. The MPI\-2 process model
provides a mechanism to create new processes and establish
communication between them and the existing MPI application. It also
provides mechanisms to establish communication between two existing
MPI applications, even when one did not \fIstart\fP the other.
.sp
In \fIMPI for Python\fP, new independent process groups can be created by
calling the \fBIntracomm.Spawn\fP method within an intracommunicator.
This call returns a new intercommunicator (i.e., an \fBIntercomm\fP
instance) at the parent process group. The child process group can
retrieve the matching intercommunicator by calling the
\fBComm.Get_parent\fP class method. At each side, the new
intercommunicator can be used to perform point to point and collective
communications between the parent and child groups of processes.
.sp
Alternatively, disjoint groups of processes can establish
communication using a client/server approach. Any server application
must first call the \fBOpen_port\fP function to open a \fIport\fP and the
\fBPublish_name\fP function to publish a provided \fIservice\fP, and next call
the \fBIntracomm.Accept\fP method.  Any client applications can first find
a published \fIservice\fP by calling the \fBLookup_name\fP function, which
returns the \fIport\fP where a server can be contacted; and next call the
\fBIntracomm.Connect\fP method. Both \fBIntracomm.Accept\fP and
\fBIntracomm.Connect\fP methods return an \fBIntercomm\fP instance. When
connection between client/server processes is no longer needed, all of
them must cooperatively call the \fBComm.Disconnect\fP
method. Additionally, server applications should release resources by
calling the \fBUnpublish_name\fP and \fBClose_port\fP functions.
.SS One\-Sided Communications
.sp
One\-sided communications (also called \fIRemote Memory Access\fP, \fIRMA\fP)
supplements the traditional two\-sided, send/receive based MPI
communication model with a one\-sided, put/get based
interface. One\-sided communication that can take advantage of the
capabilities of highly specialized network hardware. Additionally,
this extension lowers latency and software overhead in applications
written using a shared\-memory\-like paradigm.
.sp
The MPI specification revolves around the use of objects called
\fIwindows\fP; they intuitively specify regions of a process’s memory that
have been made available for remote read and write operations.  The
published memory blocks can be accessed through three functions for
put (remote send), get (remote write), and accumulate (remote update
or reduction) data items. A much larger number of functions support
different synchronization styles; the semantics of these
synchronization operations are fairly complex.
.sp
In \fIMPI for Python\fP, one\-sided operations are available by using
instances of the \fBWin\fP class. New window objects are created by
calling the \fBWin.Create\fP method at all processes within a communicator
and specifying a memory buffer . When a window instance is no longer
needed, the \fBWin.Free\fP method should be called.
.sp
The three one\-sided MPI operations for remote write, read and
reduction are available through calling the methods \fBWin.Put\fP,
\fBWin.Get\fP, and \fBWin.Accumulate\fP respectively within a \fBWin\fP instance.
These methods need an integer rank identifying the target process and
an integer offset relative the base address of the remote memory block
being accessed.
.sp
The one\-sided operations read, write, and reduction are implicitly
nonblocking, and must be synchronized by using two primary modes.
Active target synchronization requires the origin process to call the
\fBWin.Start\fP and \fBWin.Complete\fP methods at the origin process, and
target process cooperates by calling the \fBWin.Post\fP and \fBWin.Wait\fP
methods. There is also a collective variant provided by the
\fBWin.Fence\fP method. Passive target synchronization is more lenient,
only the origin process calls the \fBWin.Lock\fP and \fBWin.Unlock\fP
methods. Locks are used to protect remote accesses to the locked
remote window and to protect local load/store accesses to a locked
local window.
.SS Parallel Input/Output
.sp
The POSIX standard provides a model of a widely portable file
system. However, the optimization needed for parallel input/output
cannot be achieved with this generic interface. In order to ensure
efficiency and scalability, the underlying parallel input/output
system must provide a high\-level interface supporting partitioning of
file data among processes and a collective interface supporting
complete transfers of global data structures between process memories
and files. Additionally, further efficiencies can be gained via
support for asynchronous input/output, strided accesses to data, and
control over physical file layout on storage devices. This scenario
motivated the inclusion in the MPI\-2 standard of a custom interface in
order to support more elaborated parallel input/output operations.
.sp
The MPI specification for parallel input/output revolves around the
use objects called \fIfiles\fP\&. As defined by MPI, files are not just
contiguous byte streams. Instead, they are regarded as ordered
collections of \fItyped\fP data items. MPI supports sequential or random
access to any integral set of these items. Furthermore, files are
opened collectively by a group of processes.
.sp
The common patterns for accessing a shared file (broadcast, scatter,
gather, reduction) is expressed by using user\-defined datatypes.
Compared to the communication patterns of point\-to\-point and
collective communications, this approach has the advantage of added
flexibility and expressiveness. Data access operations (read and
write) are defined for different kinds of positioning (using explicit
offsets, individual file pointers, and shared file pointers),
coordination (non\-collective and collective), and synchronism
(blocking, nonblocking, and split collective with begin/end phases).
.sp
In \fIMPI for Python\fP, all MPI input/output operations are performed
through instances of the \fBFile\fP class. File handles are obtained by
calling the \fBFile.Open\fP method at all processes within a communicator
and providing a file name and the intended access mode.  After use,
they must be closed by calling the \fBFile.Close\fP method.  Files even
can be deleted by calling method \fBFile.Delete\fP\&.
.sp
After creation, files are typically associated with a per\-process
\fIview\fP\&. The view defines the current set of data visible and
accessible from an open file as an ordered set of elementary
datatypes. This data layout can be set and queried with the
\fBFile.Set_view\fP and \fBFile.Get_view\fP methods respectively.
.sp
Actual input/output operations are achieved by many methods combining
read and write calls with different behavior regarding positioning,
coordination, and synchronism. Summing up, \fIMPI for Python\fP provides
the thirty (30) methods defined in MPI\-2 for reading from or writing
to files using explicit offsets or file pointers (individual or
shared), in blocking or nonblocking and collective or noncollective
versions.
.SS Environmental Management
.SS Initialization and Exit
.sp
Module functions \fBInit\fP or \fBInit_thread\fP and \fBFinalize\fP provide MPI
initialization and finalization respectively. Module functions
\fBIs_initialized\fP and \fBIs_finalized\fP provide the respective tests for
initialization and finalization.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBMPI_Init()\fP or \fBMPI_Init_thread()\fP is actually called
when you import the \fBMPI\fP module from the
\fBmpi4py\fP package, but only if MPI is not already
initialized. In such case, calling \fBInit\fP or \fBInit_thread\fP from
Python is expected to generate an MPI error, and in turn an
exception will be raised.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBMPI_Finalize()\fP is registered (by using Python C/API
function \fI\%Py_AtExit()\fP) for being automatically called when
Python processes exit, but only if \fBmpi4py\fP actually
initialized MPI. Therefore, there is no need to call \fBFinalize\fP
from Python to ensure MPI finalization.
.UNINDENT
.UNINDENT
.SS Implementation Information
.INDENT 0.0
.IP \(bu 2
The MPI version number can be retrieved from module function
\fBGet_version\fP\&. It returns a two\-integer tuple \fB(version,
subversion)\fP\&.
.IP \(bu 2
The \fBGet_processor_name\fP function can be used to access the
processor name.
.IP \(bu 2
The values of predefined attributes attached to the world
communicator can be obtained by calling the \fBComm.Get_attr\fP method
within the \fBCOMM_WORLD\fP instance.
.UNINDENT
.SS Timers
.sp
MPI timer functionalities are available through the \fBWtime\fP and
\fBWtick\fP functions.
.SS Error Handling
.sp
In order facilitate handle sharing with other Python modules
interfacing MPI\-based parallel libraries, the predefined MPI error
handlers \fBERRORS_RETURN\fP and \fBERRORS_ARE_FATAL\fP can be assigned to and
retrieved from communicators using methods \fBComm.Set_errhandler\fP and
\fBComm.Get_errhandler\fP, and similarly for windows and files.
.sp
When the predefined error handler \fBERRORS_RETURN\fP is set, errors
returned from MPI calls within Python code will raise an instance of
the exception class \fBException\fP, which is a subclass of the standard
Python exception \fI\%RuntimeError\fP\&.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
After import, mpi4py overrides the default MPI rules governing
inheritance of error handlers. The \fBERRORS_RETURN\fP error handler is
set in the predefined \fBCOMM_SELF\fP and \fBCOMM_WORLD\fP communicators,
as well as any new \fBComm\fP, \fBWin\fP, or \fBFile\fP instance created
through mpi4py. If you ever pass such handles to C/C++/Fortran
library code, it is recommended to set the \fBERRORS_ARE_FATAL\fP error
handler on them to ensure MPI errors do not pass silently.
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
Importing with \fBfrom mpi4py.MPI import *\fP will cause a name
clashing with the standard Python \fI\%Exception\fP base class.
.UNINDENT
.UNINDENT
.SH TUTORIAL
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
Under construction. Contributions very welcome!
.UNINDENT
.UNINDENT
.sp
\fBTIP:\fP
.INDENT 0.0
.INDENT 3.5
\fI\%Rolf Rabenseifner\fP at \fI\%HLRS\fP developed a comprehensive
MPI\-3.1/4.0 course with slides and a large set of exercises
including solutions. This material is \fI\%available online\fP for self\-study. The slides and exercises show the C,
Fortran, and Python (mpi4py) interfaces. For performance reasons,
most Python exercises use NumPy arrays and communication routines
involving buffer\-like objects.
.UNINDENT
.UNINDENT
.sp
\fBTIP:\fP
.INDENT 0.0
.INDENT 3.5
\fI\%Victor Eijkhout\fP at \fI\%TACC\fP authored the book \fIParallel
Programming for Science and Engineering\fP\&.  This book is available
online in \fI\%PDF\fP and \fI\%HTML\fP formats.  The
book covers parallel programming with MPI and OpenMP in C/C++ and
Fortran, and MPI in Python using mpi4py.
.UNINDENT
.UNINDENT
.sp
\fIMPI for Python\fP supports convenient, \fIpickle\fP\-based communication of
generic Python object as well as fast, near C\-speed, direct array data
communication of buffer\-provider objects (e.g., NumPy arrays).
.INDENT 0.0
.IP \(bu 2
Communication of generic Python objects
.sp
You have to use methods with \fBall\-lowercase\fP names, like
\fBComm.send\fP, \fBComm.recv\fP, \fBComm.bcast\fP, \fBComm.scatter\fP,
\fBComm.gather\fP . An object to be sent is passed as a parameter to the
communication call, and the received object is simply the return
value.
.sp
The \fBComm.isend\fP and \fBComm.irecv\fP methods return \fBRequest\fP
instances; completion of these methods can be managed using the
\fBRequest.test\fP and \fBRequest.wait\fP methods.
.sp
The \fBComm.recv\fP and \fBComm.irecv\fP methods may be passed a buffer
object that can be repeatedly used to receive messages avoiding
internal memory allocation. This buffer must be sufficiently large
to accommodate the transmitted messages; hence, any buffer passed to
\fBComm.recv\fP or \fBComm.irecv\fP must be at least as long as the
\fIpickled\fP data transmitted to the receiver.
.sp
Collective calls like \fBComm.scatter\fP, \fBComm.gather\fP,
\fBComm.allgather\fP, \fBComm.alltoall\fP expect a single value or a
sequence of \fBComm.size\fP elements at the root or all process. They
return a single value, a list of \fBComm.size\fP elements, or \fI\%None\fP\&.
.sp
\fBNOTE:\fP
.INDENT 2.0
.INDENT 3.5
\fIMPI for Python\fP uses the \fBhighest\fP \fI\%protocol version\fP available in the Python runtime (see the
\fI\%HIGHEST_PROTOCOL\fP constant in the \fI\%pickle\fP
module).  The default protocol can be changed at import time by
setting the \fBMPI4PY_PICKLE_PROTOCOL\fP environment
variable, or at runtime by assigning a different value to the
\fBPROTOCOL\fP attribute of the
\fBpickle\fP object within the \fBMPI\fP
module.
.UNINDENT
.UNINDENT
.IP \(bu 2
Communication of buffer\-like objects
.sp
You have to use method names starting with an \fBupper\-case\fP letter,
like \fBComm.Send\fP, \fBComm.Recv\fP, \fBComm.Bcast\fP, \fBComm.Scatter\fP,
\fBComm.Gather\fP\&.
.sp
In general, buffer arguments to these calls must be explicitly
specified by using a 2/3\-list/tuple like \fB[data, MPI.DOUBLE]\fP, or
\fB[data, count, MPI.DOUBLE]\fP (the former one uses the byte\-size of
\fBdata\fP and the extent of the MPI datatype to define \fBcount\fP).
.sp
For vector collectives communication operations like
\fBComm.Scatterv\fP and \fBComm.Gatherv\fP, buffer arguments are
specified as \fB[data, count, displ, datatype]\fP, where \fBcount\fP and
\fBdispl\fP are sequences of integral values.
.sp
Automatic MPI datatype discovery for NumPy/GPU arrays and PEP\-3118
buffers is supported, but limited to basic C types (all C/C99\-native
signed/unsigned integral types and single/double precision
real/complex floating types) and availability of matching datatypes
in the underlying MPI implementation. In this case, the
buffer\-provider object can be passed directly as a buffer argument,
the count and MPI datatype will be inferred.
.sp
If mpi4py is built against a GPU\-aware MPI implementation, GPU
arrays can be passed to upper\-case methods as long as they have
either the \fB__dlpack__\fP and \fB__dlpack_device__\fP methods or the
\fB__cuda_array_interface__\fP attribute that are compliant with the
respective standard specifications. Moreover, only C\-contiguous or
Fortran\-contiguous GPU arrays are supported. It is important to note
that GPU buffers must be fully ready before any MPI routines operate
on them to avoid race conditions. This can be ensured by using the
synchronization API of your array library. mpi4py does not have
access to any GPU\-specific functionality and thus cannot perform
this operation automatically for users.
.UNINDENT
.SS Running Python scripts with MPI
.sp
Most MPI programs can be run with the command \fBmpiexec\fP\&. In
practice, running Python programs looks like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpiexec \-n 4 python script.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
to run the program with 4 processors.
.SS Point\-to\-Point Communication
.INDENT 0.0
.IP \(bu 2
Python objects (\fI\%pickle\fP under the hood):
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

if rank == 0:
    data = {\(aqa\(aq: 7, \(aqb\(aq: 3.14}
    comm.send(data, dest=1, tag=11)
elif rank == 1:
    data = comm.recv(source=0, tag=11)
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Python objects with non\-blocking communication:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

if rank == 0:
    data = {\(aqa\(aq: 7, \(aqb\(aq: 3.14}
    req = comm.isend(data, dest=1, tag=11)
    req.wait()
elif rank == 1:
    req = comm.irecv(source=0, tag=11)
    data = req.wait()
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
NumPy arrays (the fast way!):
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
import numpy

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

# passing MPI datatypes explicitly
if rank == 0:
    data = numpy.arange(1000, dtype=\(aqi\(aq)
    comm.Send([data, MPI.INT], dest=1, tag=77)
elif rank == 1:
    data = numpy.empty(1000, dtype=\(aqi\(aq)
    comm.Recv([data, MPI.INT], source=0, tag=77)

# automatic MPI datatype discovery
if rank == 0:
    data = numpy.arange(100, dtype=numpy.float64)
    comm.Send(data, dest=1, tag=13)
elif rank == 1:
    data = numpy.empty(100, dtype=numpy.float64)
    comm.Recv(data, source=0, tag=13)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Collective Communication
.INDENT 0.0
.IP \(bu 2
Broadcasting a Python dictionary:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

if rank == 0:
    data = {\(aqkey1\(aq : [7, 2.72, 2+3j],
            \(aqkey2\(aq : ( \(aqabc\(aq, \(aqxyz\(aq)}
else:
    data = None
data = comm.bcast(data, root=0)
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Scattering Python objects:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI

comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

if rank == 0:
    data = [(i+1)**2 for i in range(size)]
else:
    data = None
data = comm.scatter(data, root=0)
assert data == (rank+1)**2
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Gathering Python objects:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI

comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

data = (rank+1)**2
data = comm.gather(data, root=0)
if rank == 0:
    for i in range(size):
        assert data[i] == (i+1)**2
else:
    assert data is None
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Broadcasting a NumPy array:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
import numpy as np

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

if rank == 0:
    data = np.arange(100, dtype=\(aqi\(aq)
else:
    data = np.empty(100, dtype=\(aqi\(aq)
comm.Bcast(data, root=0)
for i in range(100):
    assert data[i] == i
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Scattering NumPy arrays:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
import numpy as np

comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

sendbuf = None
if rank == 0:
    sendbuf = np.empty([size, 100], dtype=\(aqi\(aq)
    sendbuf.T[:,:] = range(size)
recvbuf = np.empty(100, dtype=\(aqi\(aq)
comm.Scatter(sendbuf, recvbuf, root=0)
assert np.allclose(recvbuf, rank)
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Gathering NumPy arrays:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
import numpy as np

comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

sendbuf = np.zeros(100, dtype=\(aqi\(aq) + rank
recvbuf = None
if rank == 0:
    recvbuf = np.empty([size, 100], dtype=\(aqi\(aq)
comm.Gather(sendbuf, recvbuf, root=0)
if rank == 0:
    for i in range(size):
        assert np.allclose(recvbuf[i,:], i)
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Parallel matrix\-vector product:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
import numpy

def matvec(comm, A, x):
    m = A.shape[0] # local rows
    p = comm.Get_size()
    xg = numpy.zeros(m*p, dtype=\(aqd\(aq)
    comm.Allgather([x,  MPI.DOUBLE],
                   [xg, MPI.DOUBLE])
    y = numpy.dot(A, xg)
    return y
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS MPI\-IO
.INDENT 0.0
.IP \(bu 2
Collective I/O with NumPy arrays:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
import numpy as np

amode = MPI.MODE_WRONLY|MPI.MODE_CREATE
comm = MPI.COMM_WORLD
fh = MPI.File.Open(comm, "./datafile.contig", amode)

buffer = np.empty(10, dtype=np.int)
buffer[:] = comm.Get_rank()

offset = comm.Get_rank()*buffer.nbytes
fh.Write_at_all(offset, buffer)

fh.Close()
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Non\-contiguous Collective I/O with NumPy arrays and datatypes:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
import numpy as np

comm = MPI.COMM_WORLD
rank = comm.Get_rank()
size = comm.Get_size()

amode = MPI.MODE_WRONLY|MPI.MODE_CREATE
fh = MPI.File.Open(comm, "./datafile.noncontig", amode)

item_count = 10

buffer = np.empty(item_count, dtype=\(aqi\(aq)
buffer[:] = rank

filetype = MPI.INT.Create_vector(item_count, 1, size)
filetype.Commit()

displacement = MPI.INT.Get_size()*rank
fh.Set_view(displacement, filetype=filetype)

fh.Write_all(buffer)
filetype.Free()
fh.Close()
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Dynamic Process Management
.INDENT 0.0
.IP \(bu 2
Compute Pi \- Master (or parent, or client) side:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
#!/usr/bin/env python
from mpi4py import MPI
import numpy
import sys

comm = MPI.COMM_SELF.Spawn(sys.executable,
                           args=[\(aqcpi.py\(aq],
                           maxprocs=5)

N = numpy.array(100, \(aqi\(aq)
comm.Bcast([N, MPI.INT], root=MPI.ROOT)
PI = numpy.array(0.0, \(aqd\(aq)
comm.Reduce(None, [PI, MPI.DOUBLE],
            op=MPI.SUM, root=MPI.ROOT)
print(PI)

comm.Disconnect()
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Compute Pi \- Worker (or child, or server) side:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
#!/usr/bin/env python
from mpi4py import MPI
import numpy

comm = MPI.Comm.Get_parent()
size = comm.Get_size()
rank = comm.Get_rank()

N = numpy.array(0, dtype=\(aqi\(aq)
comm.Bcast([N, MPI.INT], root=0)
h = 1.0 / N; s = 0.0
for i in range(rank, N, size):
    x = h * (i + 0.5)
    s += 4.0 / (1.0 + x**2)
PI = numpy.array(s * h, dtype=\(aqd\(aq)
comm.Reduce([PI, MPI.DOUBLE], None,
            op=MPI.SUM, root=0)

comm.Disconnect()
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS CUDA\-aware MPI + Python GPU arrays
.INDENT 0.0
.IP \(bu 2
Reduce\-to\-all CuPy arrays:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
import cupy as cp

comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

sendbuf = cp.arange(10, dtype=\(aqi\(aq)
recvbuf = cp.empty_like(sendbuf)
assert hasattr(sendbuf, \(aq__cuda_array_interface__\(aq)
assert hasattr(recvbuf, \(aq__cuda_array_interface__\(aq)
cp.cuda.get_current_stream().synchronize()
comm.Allreduce(sendbuf, recvbuf)

assert cp.allclose(recvbuf, sendbuf*size)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS One\-Sided Communications
.INDENT 0.0
.IP \(bu 2
Read from (write to) the entire RMA window:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
import numpy as np
from mpi4py import MPI
from mpi4py.util import dtlib

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

datatype = MPI.FLOAT
np_dtype = dtlib.to_numpy_dtype(datatype)
itemsize = datatype.Get_size()

N = 10
win_size = N * itemsize if rank == 0 else 0
win = MPI.Win.Allocate(win_size, comm=comm)

buf = np.empty(N, dtype=np_dtype)
if rank == 0:
    buf.fill(42)
    win.Lock(rank=0)
    win.Put(buf, target_rank=0)
    win.Unlock(rank=0)
    comm.Barrier()
else:
    comm.Barrier()
    win.Lock(rank=0)
    win.Get(buf, target_rank=0)
    win.Unlock(rank=0)
    assert np.all(buf == 42)
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Accessing a part of the RMA window using the \fBtarget\fP argument,
which is defined as \fB(offset, count, datatype)\fP:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
import numpy as np
from mpi4py import MPI
from mpi4py.util import dtlib

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

datatype = MPI.FLOAT
np_dtype = dtlib.to_numpy_dtype(datatype)
itemsize = datatype.Get_size()

N = comm.Get_size() + 1
win_size = N * itemsize if rank == 0 else 0
win = MPI.Win.Allocate(
    size=win_size,
    disp_unit=itemsize,
    comm=comm,
)
if rank == 0:
    mem = np.frombuffer(win, dtype=np_dtype)
    mem[:] = np.arange(len(mem), dtype=np_dtype)
comm.Barrier()

buf = np.zeros(3, dtype=np_dtype)
target = (rank, 2, datatype)
win.Lock(rank=0)
win.Get(buf, target_rank=0, target=target)
win.Unlock(rank=0)
assert np.all(buf == [rank, rank+1, 0])
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Wrapping with SWIG
.INDENT 0.0
.IP \(bu 2
C source:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
/* file: helloworld.c */
void sayhello(MPI_Comm comm)
{
  int size, rank;
  MPI_Comm_size(comm, &size);
  MPI_Comm_rank(comm, &rank);
  printf("Hello, World! "
         "I am process %d of %d.\en",
         rank, size);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
SWIG interface file:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
// file: helloworld.i
%module helloworld
%{
#include <mpi.h>
#include "helloworld.c"
}%

%include mpi4py/mpi4py.i
%mpi4py_typemap(Comm, MPI_Comm);
void sayhello(MPI_Comm comm);
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Try it in the Python prompt:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
>>> from mpi4py import MPI
>>> import helloworld
>>> helloworld.sayhello(MPI.COMM_WORLD)
Hello, World! I am process 0 of 1.
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Wrapping with F2Py
.INDENT 0.0
.IP \(bu 2
Fortran 90 source:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
! file: helloworld.f90
subroutine sayhello(comm)
  use mpi
  implicit none
  integer :: comm, rank, size, ierr
  call MPI_Comm_size(comm, size, ierr)
  call MPI_Comm_rank(comm, rank, ierr)
  print *, \(aqHello, World! I am process \(aq,rank,\(aq of \(aq,size,\(aq.\(aq
end subroutine sayhello
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Compiling example using f2py
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
$ f2py \-c \-\-f90exec=mpif90 helloworld.f90 \-m helloworld
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Try it in the Python prompt:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
>>> from mpi4py import MPI
>>> import helloworld
>>> fcomm = MPI.COMM_WORLD.py2f()
>>> helloworld.sayhello(fcomm)
Hello, World! I am process 0 of 1.
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SH MPI4PY
.sp
This is the \fBMPI for Python\fP package.
.sp
The \fIMessage Passing Interface\fP (MPI) is a standardized and portable
message\-passing system designed to function on a wide variety of
parallel computers. The MPI standard defines the syntax and semantics
of library routines and allows users to write portable programs in the
main scientific programming languages (Fortran, C, or C++). Since its
release, the MPI specification has become the leading standard for
message\-passing libraries for parallel computers.
.sp
\fIMPI for Python\fP provides MPI bindings for the Python programming
language, allowing any Python program to exploit multiple processors.
This package build on the MPI specification and provides an object
oriented interface which closely follows MPI\-2 C++ bindings.
.SS Runtime configuration options
.INDENT 0.0
.TP
.B mpi4py.rc
This object has attributes exposing runtime configuration options that
become effective at import time of the \fBMPI\fP module.
.UNINDENT
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%initialize\fP
T}	T{
Automatic MPI initialization at import
T}
_
T{
\fI\%threads\fP
T}	T{
Request initialization with thread support
T}
_
T{
\fI\%thread_level\fP
T}	T{
Level of thread support to request
T}
_
T{
\fI\%finalize\fP
T}	T{
Automatic MPI finalization at exit
T}
_
T{
\fI\%fast_reduce\fP
T}	T{
Use tree\-based reductions for objects
T}
_
T{
\fI\%recv_mprobe\fP
T}	T{
Use matched probes to receive objects
T}
_
T{
\fI\%errors\fP
T}	T{
Error handling policy
T}
_
.TE
.sp
Attributes Documentation
.INDENT 0.0
.TP
.B mpi4py.rc.initialize
Automatic MPI initialization at import.
.INDENT 7.0
.TP
.B Type
\fI\%bool\fP
.TP
.B Default
\fI\%True\fP
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%MPI4PY_RC_INITIALIZE\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B mpi4py.rc.threads
Request initialization with thread support.
.INDENT 7.0
.TP
.B Type
\fI\%bool\fP
.TP
.B Default
\fI\%True\fP
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%MPI4PY_RC_THREADS\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B mpi4py.rc.thread_level
Level of thread support to request.
.INDENT 7.0
.TP
.B Type
\fI\%str\fP
.TP
.B Default
\fB"multiple"\fP
.TP
.B Choices
\fB"multiple"\fP, \fB"serialized"\fP, \fB"funneled"\fP, \fB"single"\fP
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%MPI4PY_RC_THREAD_LEVEL\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B mpi4py.rc.finalize
Automatic MPI finalization at exit.
.INDENT 7.0
.TP
.B Type
\fI\%None\fP or \fI\%bool\fP
.TP
.B Default
\fI\%None\fP
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%MPI4PY_RC_FINALIZE\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B mpi4py.rc.fast_reduce
Use tree\-based reductions for objects.
.INDENT 7.0
.TP
.B Type
\fI\%bool\fP
.TP
.B Default
\fI\%True\fP
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%MPI4PY_RC_FAST_REDUCE\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B mpi4py.rc.recv_mprobe
Use matched probes to receive objects.
.INDENT 7.0
.TP
.B Type
\fI\%bool\fP
.TP
.B Default
\fI\%True\fP
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%MPI4PY_RC_RECV_MPROBE\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B mpi4py.rc.errors
Error handling policy.
.INDENT 7.0
.TP
.B Type
\fI\%str\fP
.TP
.B Default
\fB"exception"\fP
.TP
.B Choices
\fB"exception"\fP, \fB"default"\fP, \fB"fatal"\fP
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%MPI4PY_RC_ERRORS\fP
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Example
.sp
MPI for Python features automatic initialization and finalization of the MPI
execution environment. By using the \fI\%mpi4py.rc\fP object, MPI initialization and
finalization can be handled programatically:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import mpi4py
mpi4py.rc.initialize = False  # do not initialize MPI automatically
mpi4py.rc.finalize = False    # do not finalize MPI automatically

from mpi4py import MPI # import the \(aqMPI\(aq module

MPI.Init()      # manual initialization of the MPI environment
\&...             # your finest code here ...
MPI.Finalize()  # manual finalization of the MPI environment
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Environment variables
.sp
The following environment variables override the corresponding attributes of
the \fI\%mpi4py.rc\fP and \fBMPI.pickle\fP objects at import time of the
\fBMPI\fP module.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
For variables of boolean type, accepted values are \fB0\fP and \fB1\fP
(interpreted as \fI\%False\fP and \fI\%True\fP, respectively), and strings
specifying a \fI\%YAML boolean\fP value (case\-insensitive).
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_RC_INITIALIZE
.INDENT 7.0
.TP
.B Type
\fI\%bool\fP
.TP
.B Default
\fI\%True\fP
.UNINDENT
.sp
Whether to automatically initialize MPI at import time of the
\fBmpi4py.MPI\fP module.
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%mpi4py.rc.initialize\fP
.UNINDENT
.UNINDENT
.sp
New in version 3.1.0.

.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_RC_FINALIZE
.INDENT 7.0
.TP
.B Type
\fI\%None\fP | \fI\%bool\fP
.TP
.B Default
\fI\%None\fP
.TP
.B Choices
\fI\%None\fP, \fI\%True\fP, \fI\%False\fP
.UNINDENT
.sp
Whether to automatically finalize MPI at exit time of the Python process.
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%mpi4py.rc.finalize\fP
.UNINDENT
.UNINDENT
.sp
New in version 3.1.0.

.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_RC_THREADS
.INDENT 7.0
.TP
.B Type
\fI\%bool\fP
.TP
.B Default
\fI\%True\fP
.UNINDENT
.sp
Whether to initialize MPI with thread support.
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%mpi4py.rc.threads\fP
.UNINDENT
.UNINDENT
.sp
New in version 3.1.0.

.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_RC_THREAD_LEVEL
.INDENT 7.0
.TP
.B Default
\fB"multiple"\fP
.TP
.B Choices
\fB"single"\fP, \fB"funneled"\fP,
\fB"serialized"\fP, \fB"multiple"\fP
.UNINDENT
.sp
The level of required thread support.
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%mpi4py.rc.thread_level\fP
.UNINDENT
.UNINDENT
.sp
New in version 3.1.0.

.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_RC_FAST_REDUCE
.INDENT 7.0
.TP
.B Type
\fI\%bool\fP
.TP
.B Default
\fI\%True\fP
.UNINDENT
.sp
Whether to use tree\-based reductions for objects.
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%mpi4py.rc.fast_reduce\fP
.UNINDENT
.UNINDENT
.sp
New in version 3.1.0.

.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_RC_RECV_MPROBE
.INDENT 7.0
.TP
.B Type
\fI\%bool\fP
.TP
.B Default
\fI\%True\fP
.UNINDENT
.sp
Whether to use matched probes to receive objects.
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%mpi4py.rc.recv_mprobe\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_RC_ERRORS
.INDENT 7.0
.TP
.B Default
\fB"exception"\fP
.TP
.B Choices
\fB"exception"\fP, \fB"default"\fP, \fB"fatal"\fP
.UNINDENT
.sp
Controls default MPI error handling policy.
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%mpi4py.rc.errors\fP
.UNINDENT
.UNINDENT
.sp
New in version 3.1.0.

.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_PICKLE_PROTOCOL
.INDENT 7.0
.TP
.B Type
\fI\%int\fP
.TP
.B Default
\fI\%pickle.HIGHEST_PROTOCOL\fP
.UNINDENT
.sp
Controls the default pickle protocol to use when communicating Python
objects.
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
\fBPROTOCOL\fP attribute of the
\fBMPI.pickle\fP object within the \fBMPI\fP module.
.UNINDENT
.UNINDENT
.sp
New in version 3.1.0.

.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_PICKLE_THRESHOLD
.INDENT 7.0
.TP
.B Type
\fI\%int\fP
.TP
.B Default
\fB262144\fP
.UNINDENT
.sp
Controls the default buffer size threshold for switching from in\-band to
out\-of\-band buffer handling when using pickle protocol version 5 or higher.
.sp
\fBSEE ALSO:\fP
.INDENT 7.0
.INDENT 3.5
Module \fBmpi4py.util.pkl5\fP\&.
.UNINDENT
.UNINDENT
.sp
New in version 3.1.2.

.UNINDENT
.SS Miscellaneous functions
.INDENT 0.0
.TP
.B mpi4py.profile(name, *, path=None, logfile=None)
Support for the MPI profiling interface.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP (\fI\%str\fP) – Name of the profiler library to load.
.IP \(bu 2
\fBpath\fP (\fI\%sequence\fP of \fI\%str\fP, \fIoptional\fP) – Additional paths to search for the profiler.
.IP \(bu 2
\fBlogfile\fP (\fI\%str\fP, \fIoptional\fP) – Filename prefix for dumping profiler output.
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B mpi4py.get_config()
Return a dictionary with information about MPI.
.INDENT 7.0
.TP
.B Return type
Dict[\fI\%str\fP, \fI\%str\fP]
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B mpi4py.get_include()
Return the directory in the package that contains header files.
.sp
Extension modules that need to compile against mpi4py should use
this function to locate the appropriate include directory. Using
Python distutils (or perhaps NumPy distutils):
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
import mpi4py
Extension(\(aqextension_name\(aq, ...
          include_dirs=[..., mpi4py.get_include()])
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.SH MPI4PY.MPI
.SS Classes
.sp
Ancillary
.TS
center;
|l|l|.
_
T{
\fBDatatype\fP([datatype])
T}	T{
Datatype object
T}
_
T{
\fBStatus\fP([status])
T}	T{
Status object
T}
_
T{
\fBRequest\fP([request])
T}	T{
Request handle
T}
_
T{
\fBPrequest\fP([request])
T}	T{
Persistent request handle
T}
_
T{
\fBGrequest\fP([request])
T}	T{
Generalized request handle
T}
_
T{
\fBOp\fP([op])
T}	T{
Operation object
T}
_
T{
\fBGroup\fP([group])
T}	T{
Group of processes
T}
_
T{
\fBInfo\fP([info])
T}	T{
Info object
T}
_
.TE
.sp
Communication
.TS
center;
|l|l|.
_
T{
\fBComm\fP([comm])
T}	T{
Communicator
T}
_
T{
\fBIntracomm\fP([comm])
T}	T{
Intracommunicator
T}
_
T{
\fBTopocomm\fP([comm])
T}	T{
Topology intracommunicator
T}
_
T{
\fBCartcomm\fP([comm])
T}	T{
Cartesian topology intracommunicator
T}
_
T{
\fBGraphcomm\fP([comm])
T}	T{
General graph topology intracommunicator
T}
_
T{
\fBDistgraphcomm\fP([comm])
T}	T{
Distributed graph topology intracommunicator
T}
_
T{
\fBIntercomm\fP([comm])
T}	T{
Intercommunicator
T}
_
T{
\fBMessage\fP([message])
T}	T{
Matched message handle
T}
_
.TE
.sp
One\-sided operations
.TS
center;
|l|l|.
_
T{
\fBWin\fP([win])
T}	T{
Window handle
T}
_
.TE
.sp
Input/Output
.TS
center;
|l|l|.
_
T{
\fBFile\fP([file])
T}	T{
File handle
T}
_
.TE
.sp
Error handling
.TS
center;
|l|l|.
_
T{
\fBErrhandler\fP([errhandler])
T}	T{
Error handler
T}
_
T{
\fBException\fP([ierr])
T}	T{
Exception class
T}
_
.TE
.sp
Auxiliary
.TS
center;
|l|l|.
_
T{
\fBPickle\fP([dumps, loads, protocol])
T}	T{
Pickle/unpickle Python objects
T}
_
T{
\fBmemory\fP(buf)
T}	T{
Memory buffer
T}
_
.TE
.SS Functions
.sp
Version inquiry
.TS
center;
|l|l|.
_
T{
\fBGet_version\fP()
T}	T{
Obtain the version number of the MPI standard supported by the implementation as a tuple \fB(version, subversion)\fP
T}
_
T{
\fBGet_library_version\fP()
T}	T{
Obtain the version string of the MPI library
T}
_
.TE
.sp
Initialization and finalization
.TS
center;
|l|l|.
_
T{
\fBInit\fP()
T}	T{
Initialize the MPI execution environment
T}
_
T{
\fBInit_thread\fP([required])
T}	T{
Initialize the MPI execution environment
T}
_
T{
\fBFinalize\fP()
T}	T{
Terminate the MPI execution environment
T}
_
T{
\fBIs_initialized\fP()
T}	T{
Indicates whether \fBInit\fP has been called
T}
_
T{
\fBIs_finalized\fP()
T}	T{
Indicates whether \fBFinalize\fP has completed
T}
_
T{
\fBQuery_thread\fP()
T}	T{
Return the level of thread support provided by the MPI library
T}
_
T{
\fBIs_thread_main\fP()
T}	T{
Indicate whether this thread called \fBInit\fP or \fBInit_thread\fP
T}
_
.TE
.sp
Memory allocation
.TS
center;
|l|l|.
_
T{
\fBAlloc_mem\fP(size[, info])
T}	T{
Allocate memory for message passing and RMA
T}
_
T{
\fBFree_mem\fP(mem)
T}	T{
Free memory allocated with \fBAlloc_mem()\fP
T}
_
.TE
.sp
Address manipulation
.TS
center;
|l|l|.
_
T{
\fBGet_address\fP(location)
T}	T{
Get the address of a location in memory
T}
_
T{
\fBAint_add\fP(base, disp)
T}	T{
Return the sum of base address and displacement
T}
_
T{
\fBAint_diff\fP(addr1, addr2)
T}	T{
Return the difference between absolute addresses
T}
_
.TE
.sp
Timer
.TS
center;
|l|l|.
_
T{
\fBWtick\fP()
T}	T{
Return the resolution of \fBWtime\fP
T}
_
T{
\fBWtime\fP()
T}	T{
Return an elapsed time on the calling processor
T}
_
.TE
.sp
Error handling
.TS
center;
|l|l|.
_
T{
\fBGet_error_class\fP(errorcode)
T}	T{
Convert an \fIerror code\fP into an \fIerror class\fP
T}
_
T{
\fBGet_error_string\fP(errorcode)
T}	T{
Return the \fIerror string\fP for a given \fIerror class\fP or \fIerror code\fP
T}
_
T{
\fBAdd_error_class\fP()
T}	T{
Add an \fIerror class\fP to the known error classes
T}
_
T{
\fBAdd_error_code\fP(errorclass)
T}	T{
Add an \fIerror code\fP to an \fIerror class\fP
T}
_
T{
\fBAdd_error_string\fP(errorcode, string)
T}	T{
Associate an \fIerror string\fP with an \fIerror class\fP or \fIerrorcode\fP
T}
_
.TE
.sp
Dynamic process management
.TS
center;
|l|l|.
_
T{
\fBOpen_port\fP([info])
T}	T{
Return an address that can be used to establish connections between groups of MPI processes
T}
_
T{
\fBClose_port\fP(port_name)
T}	T{
Close a port
T}
_
T{
\fBPublish_name\fP(service_name, port_name[, info])
T}	T{
Publish a service name
T}
_
T{
\fBUnpublish_name\fP(service_name, port_name[, info])
T}	T{
Unpublish a service name
T}
_
T{
\fBLookup_name\fP(service_name[, info])
T}	T{
Lookup a port name given a service name
T}
_
.TE
.sp
Miscellanea
.TS
center;
|l|l|.
_
T{
\fBAttach_buffer\fP(buf)
T}	T{
Attach a user\-provided buffer for sending in buffered mode
T}
_
T{
\fBDetach_buffer\fP()
T}	T{
Remove an existing attached buffer
T}
_
T{
\fBCompute_dims\fP(nnodes, dims)
T}	T{
Return a balanced distribution of processes per coordinate direction
T}
_
T{
\fBGet_processor_name\fP()
T}	T{
Obtain the name of the calling processor
T}
_
T{
\fBRegister_datarep\fP(datarep, read_fn, write_fn, ...)
T}	T{
Register user\-defined data representations
T}
_
T{
\fBPcontrol\fP(level)
T}	T{
Control profiling
T}
_
.TE
.sp
Utilities
.TS
center;
|l|l|.
_
T{
\fBget_vendor\fP()
T}	T{
Infomation about the underlying MPI implementation
T}
_
.TE
.SS Attributes
.TS
center;
|l|l|.
_
T{
\fBUNDEFINED\fP
T}	T{
\fI\%int\fP \fBUNDEFINED\fP
T}
_
T{
\fBANY_SOURCE\fP
T}	T{
\fI\%int\fP \fBANY_SOURCE\fP
T}
_
T{
\fBANY_TAG\fP
T}	T{
\fI\%int\fP \fBANY_TAG\fP
T}
_
T{
\fBPROC_NULL\fP
T}	T{
\fI\%int\fP \fBPROC_NULL\fP
T}
_
T{
\fBROOT\fP
T}	T{
\fI\%int\fP \fBROOT\fP
T}
_
T{
\fBBOTTOM\fP
T}	T{
\fBBottom\fP \fBBOTTOM\fP
T}
_
T{
\fBIN_PLACE\fP
T}	T{
\fBInPlace\fP \fBIN_PLACE\fP
T}
_
T{
\fBKEYVAL_INVALID\fP
T}	T{
\fI\%int\fP \fBKEYVAL_INVALID\fP
T}
_
T{
\fBTAG_UB\fP
T}	T{
\fI\%int\fP \fBTAG_UB\fP
T}
_
T{
\fBHOST\fP
T}	T{
\fI\%int\fP \fBHOST\fP
T}
_
T{
\fBIO\fP
T}	T{
\fI\%int\fP \fBIO\fP
T}
_
T{
\fBWTIME_IS_GLOBAL\fP
T}	T{
\fI\%int\fP \fBWTIME_IS_GLOBAL\fP
T}
_
T{
\fBUNIVERSE_SIZE\fP
T}	T{
\fI\%int\fP \fBUNIVERSE_SIZE\fP
T}
_
T{
\fBAPPNUM\fP
T}	T{
\fI\%int\fP \fBAPPNUM\fP
T}
_
T{
\fBLASTUSEDCODE\fP
T}	T{
\fI\%int\fP \fBLASTUSEDCODE\fP
T}
_
T{
\fBWIN_BASE\fP
T}	T{
\fI\%int\fP \fBWIN_BASE\fP
T}
_
T{
\fBWIN_SIZE\fP
T}	T{
\fI\%int\fP \fBWIN_SIZE\fP
T}
_
T{
\fBWIN_DISP_UNIT\fP
T}	T{
\fI\%int\fP \fBWIN_DISP_UNIT\fP
T}
_
T{
\fBWIN_CREATE_FLAVOR\fP
T}	T{
\fI\%int\fP \fBWIN_CREATE_FLAVOR\fP
T}
_
T{
\fBWIN_FLAVOR\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR\fP
T}
_
T{
\fBWIN_MODEL\fP
T}	T{
\fI\%int\fP \fBWIN_MODEL\fP
T}
_
T{
\fBSUCCESS\fP
T}	T{
\fI\%int\fP \fBSUCCESS\fP
T}
_
T{
\fBERR_LASTCODE\fP
T}	T{
\fI\%int\fP \fBERR_LASTCODE\fP
T}
_
T{
\fBERR_COMM\fP
T}	T{
\fI\%int\fP \fBERR_COMM\fP
T}
_
T{
\fBERR_GROUP\fP
T}	T{
\fI\%int\fP \fBERR_GROUP\fP
T}
_
T{
\fBERR_TYPE\fP
T}	T{
\fI\%int\fP \fBERR_TYPE\fP
T}
_
T{
\fBERR_REQUEST\fP
T}	T{
\fI\%int\fP \fBERR_REQUEST\fP
T}
_
T{
\fBERR_OP\fP
T}	T{
\fI\%int\fP \fBERR_OP\fP
T}
_
T{
\fBERR_BUFFER\fP
T}	T{
\fI\%int\fP \fBERR_BUFFER\fP
T}
_
T{
\fBERR_COUNT\fP
T}	T{
\fI\%int\fP \fBERR_COUNT\fP
T}
_
T{
\fBERR_TAG\fP
T}	T{
\fI\%int\fP \fBERR_TAG\fP
T}
_
T{
\fBERR_RANK\fP
T}	T{
\fI\%int\fP \fBERR_RANK\fP
T}
_
T{
\fBERR_ROOT\fP
T}	T{
\fI\%int\fP \fBERR_ROOT\fP
T}
_
T{
\fBERR_TRUNCATE\fP
T}	T{
\fI\%int\fP \fBERR_TRUNCATE\fP
T}
_
T{
\fBERR_IN_STATUS\fP
T}	T{
\fI\%int\fP \fBERR_IN_STATUS\fP
T}
_
T{
\fBERR_PENDING\fP
T}	T{
\fI\%int\fP \fBERR_PENDING\fP
T}
_
T{
\fBERR_TOPOLOGY\fP
T}	T{
\fI\%int\fP \fBERR_TOPOLOGY\fP
T}
_
T{
\fBERR_DIMS\fP
T}	T{
\fI\%int\fP \fBERR_DIMS\fP
T}
_
T{
\fBERR_ARG\fP
T}	T{
\fI\%int\fP \fBERR_ARG\fP
T}
_
T{
\fBERR_OTHER\fP
T}	T{
\fI\%int\fP \fBERR_OTHER\fP
T}
_
T{
\fBERR_UNKNOWN\fP
T}	T{
\fI\%int\fP \fBERR_UNKNOWN\fP
T}
_
T{
\fBERR_INTERN\fP
T}	T{
\fI\%int\fP \fBERR_INTERN\fP
T}
_
T{
\fBERR_INFO\fP
T}	T{
\fI\%int\fP \fBERR_INFO\fP
T}
_
T{
\fBERR_FILE\fP
T}	T{
\fI\%int\fP \fBERR_FILE\fP
T}
_
T{
\fBERR_WIN\fP
T}	T{
\fI\%int\fP \fBERR_WIN\fP
T}
_
T{
\fBERR_KEYVAL\fP
T}	T{
\fI\%int\fP \fBERR_KEYVAL\fP
T}
_
T{
\fBERR_INFO_KEY\fP
T}	T{
\fI\%int\fP \fBERR_INFO_KEY\fP
T}
_
T{
\fBERR_INFO_VALUE\fP
T}	T{
\fI\%int\fP \fBERR_INFO_VALUE\fP
T}
_
T{
\fBERR_INFO_NOKEY\fP
T}	T{
\fI\%int\fP \fBERR_INFO_NOKEY\fP
T}
_
T{
\fBERR_ACCESS\fP
T}	T{
\fI\%int\fP \fBERR_ACCESS\fP
T}
_
T{
\fBERR_AMODE\fP
T}	T{
\fI\%int\fP \fBERR_AMODE\fP
T}
_
T{
\fBERR_BAD_FILE\fP
T}	T{
\fI\%int\fP \fBERR_BAD_FILE\fP
T}
_
T{
\fBERR_FILE_EXISTS\fP
T}	T{
\fI\%int\fP \fBERR_FILE_EXISTS\fP
T}
_
T{
\fBERR_FILE_IN_USE\fP
T}	T{
\fI\%int\fP \fBERR_FILE_IN_USE\fP
T}
_
T{
\fBERR_NO_SPACE\fP
T}	T{
\fI\%int\fP \fBERR_NO_SPACE\fP
T}
_
T{
\fBERR_NO_SUCH_FILE\fP
T}	T{
\fI\%int\fP \fBERR_NO_SUCH_FILE\fP
T}
_
T{
\fBERR_IO\fP
T}	T{
\fI\%int\fP \fBERR_IO\fP
T}
_
T{
\fBERR_READ_ONLY\fP
T}	T{
\fI\%int\fP \fBERR_READ_ONLY\fP
T}
_
T{
\fBERR_CONVERSION\fP
T}	T{
\fI\%int\fP \fBERR_CONVERSION\fP
T}
_
T{
\fBERR_DUP_DATAREP\fP
T}	T{
\fI\%int\fP \fBERR_DUP_DATAREP\fP
T}
_
T{
\fBERR_UNSUPPORTED_DATAREP\fP
T}	T{
\fI\%int\fP \fBERR_UNSUPPORTED_DATAREP\fP
T}
_
T{
\fBERR_UNSUPPORTED_OPERATION\fP
T}	T{
\fI\%int\fP \fBERR_UNSUPPORTED_OPERATION\fP
T}
_
T{
\fBERR_NAME\fP
T}	T{
\fI\%int\fP \fBERR_NAME\fP
T}
_
T{
\fBERR_NO_MEM\fP
T}	T{
\fI\%int\fP \fBERR_NO_MEM\fP
T}
_
T{
\fBERR_NOT_SAME\fP
T}	T{
\fI\%int\fP \fBERR_NOT_SAME\fP
T}
_
T{
\fBERR_PORT\fP
T}	T{
\fI\%int\fP \fBERR_PORT\fP
T}
_
T{
\fBERR_QUOTA\fP
T}	T{
\fI\%int\fP \fBERR_QUOTA\fP
T}
_
T{
\fBERR_SERVICE\fP
T}	T{
\fI\%int\fP \fBERR_SERVICE\fP
T}
_
T{
\fBERR_SPAWN\fP
T}	T{
\fI\%int\fP \fBERR_SPAWN\fP
T}
_
T{
\fBERR_BASE\fP
T}	T{
\fI\%int\fP \fBERR_BASE\fP
T}
_
T{
\fBERR_SIZE\fP
T}	T{
\fI\%int\fP \fBERR_SIZE\fP
T}
_
T{
\fBERR_DISP\fP
T}	T{
\fI\%int\fP \fBERR_DISP\fP
T}
_
T{
\fBERR_ASSERT\fP
T}	T{
\fI\%int\fP \fBERR_ASSERT\fP
T}
_
T{
\fBERR_LOCKTYPE\fP
T}	T{
\fI\%int\fP \fBERR_LOCKTYPE\fP
T}
_
T{
\fBERR_RMA_CONFLICT\fP
T}	T{
\fI\%int\fP \fBERR_RMA_CONFLICT\fP
T}
_
T{
\fBERR_RMA_SYNC\fP
T}	T{
\fI\%int\fP \fBERR_RMA_SYNC\fP
T}
_
T{
\fBERR_RMA_RANGE\fP
T}	T{
\fI\%int\fP \fBERR_RMA_RANGE\fP
T}
_
T{
\fBERR_RMA_ATTACH\fP
T}	T{
\fI\%int\fP \fBERR_RMA_ATTACH\fP
T}
_
T{
\fBERR_RMA_SHARED\fP
T}	T{
\fI\%int\fP \fBERR_RMA_SHARED\fP
T}
_
T{
\fBERR_RMA_FLAVOR\fP
T}	T{
\fI\%int\fP \fBERR_RMA_FLAVOR\fP
T}
_
T{
\fBORDER_C\fP
T}	T{
\fI\%int\fP \fBORDER_C\fP
T}
_
T{
\fBORDER_F\fP
T}	T{
\fI\%int\fP \fBORDER_F\fP
T}
_
T{
\fBORDER_FORTRAN\fP
T}	T{
\fI\%int\fP \fBORDER_FORTRAN\fP
T}
_
T{
\fBTYPECLASS_INTEGER\fP
T}	T{
\fI\%int\fP \fBTYPECLASS_INTEGER\fP
T}
_
T{
\fBTYPECLASS_REAL\fP
T}	T{
\fI\%int\fP \fBTYPECLASS_REAL\fP
T}
_
T{
\fBTYPECLASS_COMPLEX\fP
T}	T{
\fI\%int\fP \fBTYPECLASS_COMPLEX\fP
T}
_
T{
\fBDISTRIBUTE_NONE\fP
T}	T{
\fI\%int\fP \fBDISTRIBUTE_NONE\fP
T}
_
T{
\fBDISTRIBUTE_BLOCK\fP
T}	T{
\fI\%int\fP \fBDISTRIBUTE_BLOCK\fP
T}
_
T{
\fBDISTRIBUTE_CYCLIC\fP
T}	T{
\fI\%int\fP \fBDISTRIBUTE_CYCLIC\fP
T}
_
T{
\fBDISTRIBUTE_DFLT_DARG\fP
T}	T{
\fI\%int\fP \fBDISTRIBUTE_DFLT_DARG\fP
T}
_
T{
\fBCOMBINER_NAMED\fP
T}	T{
\fI\%int\fP \fBCOMBINER_NAMED\fP
T}
_
T{
\fBCOMBINER_DUP\fP
T}	T{
\fI\%int\fP \fBCOMBINER_DUP\fP
T}
_
T{
\fBCOMBINER_CONTIGUOUS\fP
T}	T{
\fI\%int\fP \fBCOMBINER_CONTIGUOUS\fP
T}
_
T{
\fBCOMBINER_VECTOR\fP
T}	T{
\fI\%int\fP \fBCOMBINER_VECTOR\fP
T}
_
T{
\fBCOMBINER_HVECTOR\fP
T}	T{
\fI\%int\fP \fBCOMBINER_HVECTOR\fP
T}
_
T{
\fBCOMBINER_INDEXED\fP
T}	T{
\fI\%int\fP \fBCOMBINER_INDEXED\fP
T}
_
T{
\fBCOMBINER_HINDEXED\fP
T}	T{
\fI\%int\fP \fBCOMBINER_HINDEXED\fP
T}
_
T{
\fBCOMBINER_INDEXED_BLOCK\fP
T}	T{
\fI\%int\fP \fBCOMBINER_INDEXED_BLOCK\fP
T}
_
T{
\fBCOMBINER_HINDEXED_BLOCK\fP
T}	T{
\fI\%int\fP \fBCOMBINER_HINDEXED_BLOCK\fP
T}
_
T{
\fBCOMBINER_STRUCT\fP
T}	T{
\fI\%int\fP \fBCOMBINER_STRUCT\fP
T}
_
T{
\fBCOMBINER_SUBARRAY\fP
T}	T{
\fI\%int\fP \fBCOMBINER_SUBARRAY\fP
T}
_
T{
\fBCOMBINER_DARRAY\fP
T}	T{
\fI\%int\fP \fBCOMBINER_DARRAY\fP
T}
_
T{
\fBCOMBINER_RESIZED\fP
T}	T{
\fI\%int\fP \fBCOMBINER_RESIZED\fP
T}
_
T{
\fBCOMBINER_F90_REAL\fP
T}	T{
\fI\%int\fP \fBCOMBINER_F90_REAL\fP
T}
_
T{
\fBCOMBINER_F90_COMPLEX\fP
T}	T{
\fI\%int\fP \fBCOMBINER_F90_COMPLEX\fP
T}
_
T{
\fBCOMBINER_F90_INTEGER\fP
T}	T{
\fI\%int\fP \fBCOMBINER_F90_INTEGER\fP
T}
_
T{
\fBIDENT\fP
T}	T{
\fI\%int\fP \fBIDENT\fP
T}
_
T{
\fBCONGRUENT\fP
T}	T{
\fI\%int\fP \fBCONGRUENT\fP
T}
_
T{
\fBSIMILAR\fP
T}	T{
\fI\%int\fP \fBSIMILAR\fP
T}
_
T{
\fBUNEQUAL\fP
T}	T{
\fI\%int\fP \fBUNEQUAL\fP
T}
_
T{
\fBCART\fP
T}	T{
\fI\%int\fP \fBCART\fP
T}
_
T{
\fBGRAPH\fP
T}	T{
\fI\%int\fP \fBGRAPH\fP
T}
_
T{
\fBDIST_GRAPH\fP
T}	T{
\fI\%int\fP \fBDIST_GRAPH\fP
T}
_
T{
\fBUNWEIGHTED\fP
T}	T{
\fI\%int\fP \fBUNWEIGHTED\fP
T}
_
T{
\fBWEIGHTS_EMPTY\fP
T}	T{
\fI\%int\fP \fBWEIGHTS_EMPTY\fP
T}
_
T{
\fBCOMM_TYPE_SHARED\fP
T}	T{
\fI\%int\fP \fBCOMM_TYPE_SHARED\fP
T}
_
T{
\fBBSEND_OVERHEAD\fP
T}	T{
\fI\%int\fP \fBBSEND_OVERHEAD\fP
T}
_
T{
\fBWIN_FLAVOR_CREATE\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR_CREATE\fP
T}
_
T{
\fBWIN_FLAVOR_ALLOCATE\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR_ALLOCATE\fP
T}
_
T{
\fBWIN_FLAVOR_DYNAMIC\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR_DYNAMIC\fP
T}
_
T{
\fBWIN_FLAVOR_SHARED\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR_SHARED\fP
T}
_
T{
\fBWIN_SEPARATE\fP
T}	T{
\fI\%int\fP \fBWIN_SEPARATE\fP
T}
_
T{
\fBWIN_UNIFIED\fP
T}	T{
\fI\%int\fP \fBWIN_UNIFIED\fP
T}
_
T{
\fBMODE_NOCHECK\fP
T}	T{
\fI\%int\fP \fBMODE_NOCHECK\fP
T}
_
T{
\fBMODE_NOSTORE\fP
T}	T{
\fI\%int\fP \fBMODE_NOSTORE\fP
T}
_
T{
\fBMODE_NOPUT\fP
T}	T{
\fI\%int\fP \fBMODE_NOPUT\fP
T}
_
T{
\fBMODE_NOPRECEDE\fP
T}	T{
\fI\%int\fP \fBMODE_NOPRECEDE\fP
T}
_
T{
\fBMODE_NOSUCCEED\fP
T}	T{
\fI\%int\fP \fBMODE_NOSUCCEED\fP
T}
_
T{
\fBLOCK_EXCLUSIVE\fP
T}	T{
\fI\%int\fP \fBLOCK_EXCLUSIVE\fP
T}
_
T{
\fBLOCK_SHARED\fP
T}	T{
\fI\%int\fP \fBLOCK_SHARED\fP
T}
_
T{
\fBMODE_RDONLY\fP
T}	T{
\fI\%int\fP \fBMODE_RDONLY\fP
T}
_
T{
\fBMODE_WRONLY\fP
T}	T{
\fI\%int\fP \fBMODE_WRONLY\fP
T}
_
T{
\fBMODE_RDWR\fP
T}	T{
\fI\%int\fP \fBMODE_RDWR\fP
T}
_
T{
\fBMODE_CREATE\fP
T}	T{
\fI\%int\fP \fBMODE_CREATE\fP
T}
_
T{
\fBMODE_EXCL\fP
T}	T{
\fI\%int\fP \fBMODE_EXCL\fP
T}
_
T{
\fBMODE_DELETE_ON_CLOSE\fP
T}	T{
\fI\%int\fP \fBMODE_DELETE_ON_CLOSE\fP
T}
_
T{
\fBMODE_UNIQUE_OPEN\fP
T}	T{
\fI\%int\fP \fBMODE_UNIQUE_OPEN\fP
T}
_
T{
\fBMODE_SEQUENTIAL\fP
T}	T{
\fI\%int\fP \fBMODE_SEQUENTIAL\fP
T}
_
T{
\fBMODE_APPEND\fP
T}	T{
\fI\%int\fP \fBMODE_APPEND\fP
T}
_
T{
\fBSEEK_SET\fP
T}	T{
\fI\%int\fP \fBSEEK_SET\fP
T}
_
T{
\fBSEEK_CUR\fP
T}	T{
\fI\%int\fP \fBSEEK_CUR\fP
T}
_
T{
\fBSEEK_END\fP
T}	T{
\fI\%int\fP \fBSEEK_END\fP
T}
_
T{
\fBDISPLACEMENT_CURRENT\fP
T}	T{
\fI\%int\fP \fBDISPLACEMENT_CURRENT\fP
T}
_
T{
\fBDISP_CUR\fP
T}	T{
\fI\%int\fP \fBDISP_CUR\fP
T}
_
T{
\fBTHREAD_SINGLE\fP
T}	T{
\fI\%int\fP \fBTHREAD_SINGLE\fP
T}
_
T{
\fBTHREAD_FUNNELED\fP
T}	T{
\fI\%int\fP \fBTHREAD_FUNNELED\fP
T}
_
T{
\fBTHREAD_SERIALIZED\fP
T}	T{
\fI\%int\fP \fBTHREAD_SERIALIZED\fP
T}
_
T{
\fBTHREAD_MULTIPLE\fP
T}	T{
\fI\%int\fP \fBTHREAD_MULTIPLE\fP
T}
_
T{
\fBVERSION\fP
T}	T{
\fI\%int\fP \fBVERSION\fP
T}
_
T{
\fBSUBVERSION\fP
T}	T{
\fI\%int\fP \fBSUBVERSION\fP
T}
_
T{
\fBMAX_PROCESSOR_NAME\fP
T}	T{
\fI\%int\fP \fBMAX_PROCESSOR_NAME\fP
T}
_
T{
\fBMAX_ERROR_STRING\fP
T}	T{
\fI\%int\fP \fBMAX_ERROR_STRING\fP
T}
_
T{
\fBMAX_PORT_NAME\fP
T}	T{
\fI\%int\fP \fBMAX_PORT_NAME\fP
T}
_
T{
\fBMAX_INFO_KEY\fP
T}	T{
\fI\%int\fP \fBMAX_INFO_KEY\fP
T}
_
T{
\fBMAX_INFO_VAL\fP
T}	T{
\fI\%int\fP \fBMAX_INFO_VAL\fP
T}
_
T{
\fBMAX_OBJECT_NAME\fP
T}	T{
\fI\%int\fP \fBMAX_OBJECT_NAME\fP
T}
_
T{
\fBMAX_DATAREP_STRING\fP
T}	T{
\fI\%int\fP \fBMAX_DATAREP_STRING\fP
T}
_
T{
\fBMAX_LIBRARY_VERSION_STRING\fP
T}	T{
\fI\%int\fP \fBMAX_LIBRARY_VERSION_STRING\fP
T}
_
T{
\fBDATATYPE_NULL\fP
T}	T{
\fBDatatype\fP \fBDATATYPE_NULL\fP
T}
_
T{
\fBUB\fP
T}	T{
\fBDatatype\fP \fBUB\fP
T}
_
T{
\fBLB\fP
T}	T{
\fBDatatype\fP \fBLB\fP
T}
_
T{
\fBPACKED\fP
T}	T{
\fBDatatype\fP \fBPACKED\fP
T}
_
T{
\fBBYTE\fP
T}	T{
\fBDatatype\fP \fBBYTE\fP
T}
_
T{
\fBAINT\fP
T}	T{
\fBDatatype\fP \fBAINT\fP
T}
_
T{
\fBOFFSET\fP
T}	T{
\fBDatatype\fP \fBOFFSET\fP
T}
_
T{
\fBCOUNT\fP
T}	T{
\fBDatatype\fP \fBCOUNT\fP
T}
_
T{
\fBCHAR\fP
T}	T{
\fBDatatype\fP \fBCHAR\fP
T}
_
T{
\fBWCHAR\fP
T}	T{
\fBDatatype\fP \fBWCHAR\fP
T}
_
T{
\fBSIGNED_CHAR\fP
T}	T{
\fBDatatype\fP \fBSIGNED_CHAR\fP
T}
_
T{
\fBSHORT\fP
T}	T{
\fBDatatype\fP \fBSHORT\fP
T}
_
T{
\fBINT\fP
T}	T{
\fBDatatype\fP \fBINT\fP
T}
_
T{
\fBLONG\fP
T}	T{
\fBDatatype\fP \fBLONG\fP
T}
_
T{
\fBLONG_LONG\fP
T}	T{
\fBDatatype\fP \fBLONG_LONG\fP
T}
_
T{
\fBUNSIGNED_CHAR\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_CHAR\fP
T}
_
T{
\fBUNSIGNED_SHORT\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_SHORT\fP
T}
_
T{
\fBUNSIGNED\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED\fP
T}
_
T{
\fBUNSIGNED_LONG\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_LONG\fP
T}
_
T{
\fBUNSIGNED_LONG_LONG\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_LONG_LONG\fP
T}
_
T{
\fBFLOAT\fP
T}	T{
\fBDatatype\fP \fBFLOAT\fP
T}
_
T{
\fBDOUBLE\fP
T}	T{
\fBDatatype\fP \fBDOUBLE\fP
T}
_
T{
\fBLONG_DOUBLE\fP
T}	T{
\fBDatatype\fP \fBLONG_DOUBLE\fP
T}
_
T{
\fBC_BOOL\fP
T}	T{
\fBDatatype\fP \fBC_BOOL\fP
T}
_
T{
\fBINT8_T\fP
T}	T{
\fBDatatype\fP \fBINT8_T\fP
T}
_
T{
\fBINT16_T\fP
T}	T{
\fBDatatype\fP \fBINT16_T\fP
T}
_
T{
\fBINT32_T\fP
T}	T{
\fBDatatype\fP \fBINT32_T\fP
T}
_
T{
\fBINT64_T\fP
T}	T{
\fBDatatype\fP \fBINT64_T\fP
T}
_
T{
\fBUINT8_T\fP
T}	T{
\fBDatatype\fP \fBUINT8_T\fP
T}
_
T{
\fBUINT16_T\fP
T}	T{
\fBDatatype\fP \fBUINT16_T\fP
T}
_
T{
\fBUINT32_T\fP
T}	T{
\fBDatatype\fP \fBUINT32_T\fP
T}
_
T{
\fBUINT64_T\fP
T}	T{
\fBDatatype\fP \fBUINT64_T\fP
T}
_
T{
\fBC_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBC_COMPLEX\fP
T}
_
T{
\fBC_FLOAT_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBC_FLOAT_COMPLEX\fP
T}
_
T{
\fBC_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBC_DOUBLE_COMPLEX\fP
T}
_
T{
\fBC_LONG_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBC_LONG_DOUBLE_COMPLEX\fP
T}
_
T{
\fBCXX_BOOL\fP
T}	T{
\fBDatatype\fP \fBCXX_BOOL\fP
T}
_
T{
\fBCXX_FLOAT_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBCXX_FLOAT_COMPLEX\fP
T}
_
T{
\fBCXX_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBCXX_DOUBLE_COMPLEX\fP
T}
_
T{
\fBCXX_LONG_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBCXX_LONG_DOUBLE_COMPLEX\fP
T}
_
T{
\fBSHORT_INT\fP
T}	T{
\fBDatatype\fP \fBSHORT_INT\fP
T}
_
T{
\fBINT_INT\fP
T}	T{
\fBDatatype\fP \fBINT_INT\fP
T}
_
T{
\fBTWOINT\fP
T}	T{
\fBDatatype\fP \fBTWOINT\fP
T}
_
T{
\fBLONG_INT\fP
T}	T{
\fBDatatype\fP \fBLONG_INT\fP
T}
_
T{
\fBFLOAT_INT\fP
T}	T{
\fBDatatype\fP \fBFLOAT_INT\fP
T}
_
T{
\fBDOUBLE_INT\fP
T}	T{
\fBDatatype\fP \fBDOUBLE_INT\fP
T}
_
T{
\fBLONG_DOUBLE_INT\fP
T}	T{
\fBDatatype\fP \fBLONG_DOUBLE_INT\fP
T}
_
T{
\fBCHARACTER\fP
T}	T{
\fBDatatype\fP \fBCHARACTER\fP
T}
_
T{
\fBLOGICAL\fP
T}	T{
\fBDatatype\fP \fBLOGICAL\fP
T}
_
T{
\fBINTEGER\fP
T}	T{
\fBDatatype\fP \fBINTEGER\fP
T}
_
T{
\fBREAL\fP
T}	T{
\fBDatatype\fP \fBREAL\fP
T}
_
T{
\fBDOUBLE_PRECISION\fP
T}	T{
\fBDatatype\fP \fBDOUBLE_PRECISION\fP
T}
_
T{
\fBCOMPLEX\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX\fP
T}
_
T{
\fBDOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBDOUBLE_COMPLEX\fP
T}
_
T{
\fBLOGICAL1\fP
T}	T{
\fBDatatype\fP \fBLOGICAL1\fP
T}
_
T{
\fBLOGICAL2\fP
T}	T{
\fBDatatype\fP \fBLOGICAL2\fP
T}
_
T{
\fBLOGICAL4\fP
T}	T{
\fBDatatype\fP \fBLOGICAL4\fP
T}
_
T{
\fBLOGICAL8\fP
T}	T{
\fBDatatype\fP \fBLOGICAL8\fP
T}
_
T{
\fBINTEGER1\fP
T}	T{
\fBDatatype\fP \fBINTEGER1\fP
T}
_
T{
\fBINTEGER2\fP
T}	T{
\fBDatatype\fP \fBINTEGER2\fP
T}
_
T{
\fBINTEGER4\fP
T}	T{
\fBDatatype\fP \fBINTEGER4\fP
T}
_
T{
\fBINTEGER8\fP
T}	T{
\fBDatatype\fP \fBINTEGER8\fP
T}
_
T{
\fBINTEGER16\fP
T}	T{
\fBDatatype\fP \fBINTEGER16\fP
T}
_
T{
\fBREAL2\fP
T}	T{
\fBDatatype\fP \fBREAL2\fP
T}
_
T{
\fBREAL4\fP
T}	T{
\fBDatatype\fP \fBREAL4\fP
T}
_
T{
\fBREAL8\fP
T}	T{
\fBDatatype\fP \fBREAL8\fP
T}
_
T{
\fBREAL16\fP
T}	T{
\fBDatatype\fP \fBREAL16\fP
T}
_
T{
\fBCOMPLEX4\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX4\fP
T}
_
T{
\fBCOMPLEX8\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX8\fP
T}
_
T{
\fBCOMPLEX16\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX16\fP
T}
_
T{
\fBCOMPLEX32\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX32\fP
T}
_
T{
\fBUNSIGNED_INT\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_INT\fP
T}
_
T{
\fBSIGNED_SHORT\fP
T}	T{
\fBDatatype\fP \fBSIGNED_SHORT\fP
T}
_
T{
\fBSIGNED_INT\fP
T}	T{
\fBDatatype\fP \fBSIGNED_INT\fP
T}
_
T{
\fBSIGNED_LONG\fP
T}	T{
\fBDatatype\fP \fBSIGNED_LONG\fP
T}
_
T{
\fBSIGNED_LONG_LONG\fP
T}	T{
\fBDatatype\fP \fBSIGNED_LONG_LONG\fP
T}
_
T{
\fBBOOL\fP
T}	T{
\fBDatatype\fP \fBBOOL\fP
T}
_
T{
\fBSINT8_T\fP
T}	T{
\fBDatatype\fP \fBSINT8_T\fP
T}
_
T{
\fBSINT16_T\fP
T}	T{
\fBDatatype\fP \fBSINT16_T\fP
T}
_
T{
\fBSINT32_T\fP
T}	T{
\fBDatatype\fP \fBSINT32_T\fP
T}
_
T{
\fBSINT64_T\fP
T}	T{
\fBDatatype\fP \fBSINT64_T\fP
T}
_
T{
\fBF_BOOL\fP
T}	T{
\fBDatatype\fP \fBF_BOOL\fP
T}
_
T{
\fBF_INT\fP
T}	T{
\fBDatatype\fP \fBF_INT\fP
T}
_
T{
\fBF_FLOAT\fP
T}	T{
\fBDatatype\fP \fBF_FLOAT\fP
T}
_
T{
\fBF_DOUBLE\fP
T}	T{
\fBDatatype\fP \fBF_DOUBLE\fP
T}
_
T{
\fBF_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBF_COMPLEX\fP
T}
_
T{
\fBF_FLOAT_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBF_FLOAT_COMPLEX\fP
T}
_
T{
\fBF_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBF_DOUBLE_COMPLEX\fP
T}
_
T{
\fBREQUEST_NULL\fP
T}	T{
\fBRequest\fP \fBREQUEST_NULL\fP
T}
_
T{
\fBMESSAGE_NULL\fP
T}	T{
\fBMessage\fP \fBMESSAGE_NULL\fP
T}
_
T{
\fBMESSAGE_NO_PROC\fP
T}	T{
\fBMessage\fP \fBMESSAGE_NO_PROC\fP
T}
_
T{
\fBOP_NULL\fP
T}	T{
\fBOp\fP \fBOP_NULL\fP
T}
_
T{
\fBMAX\fP
T}	T{
\fBOp\fP \fBMAX\fP
T}
_
T{
\fBMIN\fP
T}	T{
\fBOp\fP \fBMIN\fP
T}
_
T{
\fBSUM\fP
T}	T{
\fBOp\fP \fBSUM\fP
T}
_
T{
\fBPROD\fP
T}	T{
\fBOp\fP \fBPROD\fP
T}
_
T{
\fBLAND\fP
T}	T{
\fBOp\fP \fBLAND\fP
T}
_
T{
\fBBAND\fP
T}	T{
\fBOp\fP \fBBAND\fP
T}
_
T{
\fBLOR\fP
T}	T{
\fBOp\fP \fBLOR\fP
T}
_
T{
\fBBOR\fP
T}	T{
\fBOp\fP \fBBOR\fP
T}
_
T{
\fBLXOR\fP
T}	T{
\fBOp\fP \fBLXOR\fP
T}
_
T{
\fBBXOR\fP
T}	T{
\fBOp\fP \fBBXOR\fP
T}
_
T{
\fBMAXLOC\fP
T}	T{
\fBOp\fP \fBMAXLOC\fP
T}
_
T{
\fBMINLOC\fP
T}	T{
\fBOp\fP \fBMINLOC\fP
T}
_
T{
\fBREPLACE\fP
T}	T{
\fBOp\fP \fBREPLACE\fP
T}
_
T{
\fBNO_OP\fP
T}	T{
\fBOp\fP \fBNO_OP\fP
T}
_
T{
\fBGROUP_NULL\fP
T}	T{
\fBGroup\fP \fBGROUP_NULL\fP
T}
_
T{
\fBGROUP_EMPTY\fP
T}	T{
\fBGroup\fP \fBGROUP_EMPTY\fP
T}
_
T{
\fBINFO_NULL\fP
T}	T{
\fBInfo\fP \fBINFO_NULL\fP
T}
_
T{
\fBINFO_ENV\fP
T}	T{
\fBInfo\fP \fBINFO_ENV\fP
T}
_
T{
\fBERRHANDLER_NULL\fP
T}	T{
\fBErrhandler\fP \fBERRHANDLER_NULL\fP
T}
_
T{
\fBERRORS_RETURN\fP
T}	T{
\fBErrhandler\fP \fBERRORS_RETURN\fP
T}
_
T{
\fBERRORS_ARE_FATAL\fP
T}	T{
\fBErrhandler\fP \fBERRORS_ARE_FATAL\fP
T}
_
T{
\fBCOMM_NULL\fP
T}	T{
\fBComm\fP \fBCOMM_NULL\fP
T}
_
T{
\fBCOMM_SELF\fP
T}	T{
\fBIntracomm\fP \fBCOMM_SELF\fP
T}
_
T{
\fBCOMM_WORLD\fP
T}	T{
\fBIntracomm\fP \fBCOMM_WORLD\fP
T}
_
T{
\fBWIN_NULL\fP
T}	T{
\fBWin\fP \fBWIN_NULL\fP
T}
_
T{
\fBFILE_NULL\fP
T}	T{
\fBFile\fP \fBFILE_NULL\fP
T}
_
T{
\fBpickle\fP
T}	T{
\fBPickle\fP \fBpickle\fP
T}
_
.TE
.SH MPI4PY.FUTURES
.sp
New in version 3.0.0.

.sp
This package provides a high\-level interface for asynchronously executing
callables on a pool of worker processes using MPI for inter\-process
communication.
.SS concurrent.futures
.sp
The \fI\%mpi4py.futures\fP package is based on \fI\%concurrent.futures\fP from
the Python standard library. More precisely, \fI\%mpi4py.futures\fP provides the
\fI\%MPIPoolExecutor\fP class as a concrete implementation of the abstract
class \fI\%Executor\fP\&.  The
\fI\%submit()\fP interface schedules a callable to
be executed asynchronously and returns a \fI\%Future\fP
object representing the execution of the callable.
\fI\%Future\fP instances can be queried for the call
result or exception. Sets of \fI\%Future\fP instances can
be passed to the \fI\%wait()\fP and
\fI\%as_completed()\fP functions.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The \fI\%concurrent.futures\fP package was introduced in Python 3.2. A
\fI\%backport\fP targeting Python 2.7 is available on \fI\%PyPI\fP\&. The \fI\%mpi4py.futures\fP package uses
\fI\%concurrent.futures\fP if available, either from the Python 3 standard
library or the Python 2.7 backport if installed. Otherwise,
\fI\%mpi4py.futures\fP uses a bundled copy of core functionality backported
from Python 3.5 to work with Python 2.7.
.UNINDENT
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B Module \fI\%concurrent.futures\fP
Documentation of the \fI\%concurrent.futures\fP standard module.
.UNINDENT
.UNINDENT
.UNINDENT
.SS MPIPoolExecutor
.sp
The \fI\%MPIPoolExecutor\fP class uses a pool of MPI processes to execute
calls asynchronously. By performing computations in separate processes, it
allows to side\-step the \fI\%global interpreter lock\fP but also means that
only picklable objects can be executed and returned. The \fI\%__main__\fP module
must be importable by worker processes, thus \fI\%MPIPoolExecutor\fP instances
may not work in the interactive interpreter.
.sp
\fI\%MPIPoolExecutor\fP takes advantage of the dynamic process management
features introduced in the MPI\-2 standard. In particular, the
\fBMPI.Intracomm.Spawn\fP method of \fBMPI.COMM_SELF\fP is used in the master (or
parent) process to spawn new worker (or child) processes running a Python
interpreter. The master process uses a separate thread (one for each
\fI\%MPIPoolExecutor\fP instance) to communicate back and forth with the
workers.  The worker processes serve the execution of tasks in the main (and
only) thread until they are signaled for completion.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The worker processes must import the main script in order to \fIunpickle\fP any
callable defined in the \fI\%__main__\fP module and submitted from the master
process. Furthermore, the callables may need access to other global
variables. At the worker processes, \fI\%mpi4py.futures\fP executes the main
script code (using the \fI\%runpy\fP module) under the \fB__worker__\fP
namespace to define the \fI\%__main__\fP module. The \fI\%__main__\fP and
\fB__worker__\fP modules are added to \fI\%sys.modules\fP (both at the
master and worker processes) to ensure proper \fIpickling\fP and \fIunpickling\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
During the initial import phase at the workers, the main script cannot
create and use new \fI\%MPIPoolExecutor\fP instances. Otherwise, each
worker would attempt to spawn a new pool of workers, leading to infinite
recursion. \fI\%mpi4py.futures\fP detects such recursive attempts to spawn
new workers and aborts the MPI execution environment. As the main script
code is run under the \fB__worker__\fP namespace, the easiest way to avoid
spawn recursion is using the idiom \fBif __name__ == \(aq__main__\(aq: ...\fP in
the main script.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  mpi4py.futures.MPIPoolExecutor(max_workers=None, initializer=None, initargs=(), **kwargs)
An \fI\%Executor\fP subclass that executes calls
asynchronously using a pool of at most \fImax_workers\fP processes.  If
\fImax_workers\fP is \fI\%None\fP or not given, its value is determined from the
\fI\%MPI4PY_FUTURES_MAX_WORKERS\fP environment variable if set, or the MPI
universe size if set, otherwise a single worker process is spawned.  If
\fImax_workers\fP is lower than or equal to \fB0\fP, then a \fI\%ValueError\fP will
be raised.
.sp
\fIinitializer\fP is an optional callable that is called at the start of each
worker process before executing any tasks; \fIinitargs\fP is a tuple of
arguments passed to the initializer. If \fIinitializer\fP raises an exception,
all pending tasks and any attempt to submit new tasks to the pool will raise
a \fI\%BrokenExecutor\fP exception.
.sp
Other parameters:
.INDENT 7.0
.IP \(bu 2
\fIpython_exe\fP: Path to the Python interpreter executable used to spawn
worker processes, otherwise \fI\%sys.executable\fP is used.
.IP \(bu 2
\fIpython_args\fP: \fI\%list\fP or iterable with additional command line
flags to pass to the Python executable. Command line flags determined from
inspection of \fI\%sys.flags\fP, \fI\%sys.warnoptions\fP and
\fI\%sys._xoptions\fP in are passed unconditionally.
.IP \(bu 2
\fImpi_info\fP: \fI\%dict\fP or iterable yielding \fB(key, value)\fP pairs.
These \fB(key, value)\fP pairs are passed (through an \fBMPI.Info\fP object) to
the \fBMPI.Intracomm.Spawn\fP call used to spawn worker processes. This
mechanism allows telling the MPI runtime system where and how to start the
processes. Check the documentation of the backend MPI implementation about
the set of keys it interprets and the corresponding format for values.
.IP \(bu 2
\fIglobals\fP: \fI\%dict\fP or iterable yielding \fB(name, value)\fP pairs to
initialize the main module namespace in worker processes.
.IP \(bu 2
\fImain\fP: If set to \fI\%False\fP, do not import the \fI\%__main__\fP module in
worker processes. Setting \fImain\fP to \fI\%False\fP prevents worker processes
from accessing definitions in the parent \fI\%__main__\fP namespace.
.IP \(bu 2
\fIpath\fP: \fI\%list\fP or iterable with paths to append to \fI\%sys.path\fP
in worker processes to extend the \fI\%module search path\fP\&.
.IP \(bu 2
\fIwdir\fP: Path to set the current working directory in worker processes
using \fI\%os.chdir()\fP\&. The initial working directory is set by the MPI
implementation. Quality MPI implementations should honor a \fBwdir\fP info
key passed through \fImpi_info\fP, although such feature is not mandatory.
.IP \(bu 2
\fIenv\fP: \fI\%dict\fP or iterable yielding \fB(name, value)\fP pairs with
environment variables to update \fI\%os.environ\fP in worker processes.
The initial environment is set by the MPI implementation. MPI
implementations may allow setting the initial environment through
\fImpi_info\fP, however such feature is not required nor recommended by the
MPI standard.
.UNINDENT
.INDENT 7.0
.TP
.B submit(func, *args, **kwargs)
Schedule the callable, \fIfunc\fP, to be executed as \fBfunc(*args,
**kwargs)\fP and returns a \fI\%Future\fP object
representing the execution of the callable.
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
executor = MPIPoolExecutor(max_workers=1)
future = executor.submit(pow, 321, 1234)
print(future.result())
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B map(func, *iterables, timeout=None, chunksize=1, **kwargs)
Equivalent to \fI\%map(func, *iterables)\fP except \fIfunc\fP is
executed asynchronously and several calls to \fIfunc\fP may be made
concurrently, out\-of\-order, in separate processes.  The returned iterator
raises a \fI\%TimeoutError\fP if
\fI\%__next__()\fP is called and the result isn’t available after
\fItimeout\fP seconds from the original call to \fI\%map()\fP\&.
\fItimeout\fP can be an int or a float.  If \fItimeout\fP is not specified or
\fI\%None\fP, there is no limit to the wait time.  If a call raises an
exception, then that exception will be raised when its value is retrieved
from the iterator. This method chops \fIiterables\fP into a number of chunks
which it submits to the pool as separate tasks. The (approximate) size of
these chunks can be specified by setting \fIchunksize\fP to a positive
integer. For very long iterables, using a large value for \fIchunksize\fP can
significantly improve performance compared to the default size of one. By
default, the returned iterator yields results in\-order, waiting for
successive tasks to complete . This behavior can be changed by passing
the keyword argument \fIunordered\fP as \fI\%True\fP, then the result iterator
will yield a result as soon as any of the tasks complete.
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
executor = MPIPoolExecutor(max_workers=3)
for result in executor.map(pow, [2]*32, range(32)):
    print(result)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B starmap(func, iterable, timeout=None, chunksize=1, **kwargs)
Equivalent to \fI\%itertools.starmap(func, iterable)\fP\&. Used instead of \fI\%map()\fP when
argument parameters are already grouped in tuples from a single iterable
(the data has been “pre\-zipped”). \fI\%map(func, *iterable)\fP is
equivalent to \fI\%starmap(func, zip(*iterable))\fP\&.
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
executor = MPIPoolExecutor(max_workers=3)
iterable = ((2, n) for n in range(32))
for result in executor.starmap(pow, iterable):
    print(result)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B shutdown(wait=True, cancel_futures=False)
Signal the executor that it should free any resources that it is using
when the currently pending futures are done executing.  Calls to
\fI\%submit()\fP and \fI\%map()\fP made
after \fI\%shutdown()\fP will raise \fI\%RuntimeError\fP\&.
.sp
If \fIwait\fP is \fI\%True\fP then this method will not return until all the
pending futures are done executing and the resources associated with the
executor have been freed.  If \fIwait\fP is \fI\%False\fP then this method will
return immediately and the resources associated with the executor will be
freed when all pending futures are done executing.  Regardless of the
value of \fIwait\fP, the entire Python program will not exit until all
pending futures are done executing.
.sp
If \fIcancel_futures\fP is \fI\%True\fP, this method will cancel all pending
futures that the executor has not started running. Any futures that
are completed or running won’t be cancelled, regardless of the value
of \fIcancel_futures\fP\&.
.sp
You can avoid having to call this method explicitly if you use the
\fI\%with\fP statement, which will shutdown the executor instance
(waiting as if \fI\%shutdown()\fP were called with \fIwait\fP
set to \fI\%True\fP).
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
import time
with MPIPoolExecutor(max_workers=1) as executor:
    future = executor.submit(time.sleep, 2)
assert future.done()
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B bootup(wait=True)
Signal the executor that it should allocate eagerly any required
resources (in particular, MPI worker processes). If \fIwait\fP is \fI\%True\fP,
then \fI\%bootup()\fP will not return until the executor
resources are ready to process submissions.  Resources are automatically
allocated in the first call to \fI\%submit()\fP, thus
calling \fI\%bootup()\fP explicitly is seldom needed.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B MPI4PY_FUTURES_MAX_WORKERS
If the \fImax_workers\fP parameter to \fI\%MPIPoolExecutor\fP is \fI\%None\fP or not
given, the \fI\%MPI4PY_FUTURES_MAX_WORKERS\fP environment variable
provides fallback value for the maximum number of MPI worker processes to
spawn.
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
As the master process uses a separate thread to perform MPI communication
with the workers, the backend MPI implementation should provide support for
\fBMPI.THREAD_MULTIPLE\fP\&. However, some popular MPI implementations do not
support yet concurrent MPI calls from multiple threads. Additionally, users
may decide to initialize MPI with a lower level of thread support. If the
level of thread support in the backend MPI is less than
\fBMPI.THREAD_MULTIPLE\fP, \fI\%mpi4py.futures\fP will use a global lock to
serialize MPI calls. If the level of thread support is less than
\fBMPI.THREAD_SERIALIZED\fP, \fI\%mpi4py.futures\fP will emit a
\fI\%RuntimeWarning\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
If the level of thread support in the backend MPI is less than
\fBMPI.THREAD_SERIALIZED\fP (i.e, it is either \fBMPI.THREAD_SINGLE\fP or
\fBMPI.THREAD_FUNNELED\fP), in theory \fI\%mpi4py.futures\fP cannot be
used. Rather than raising an exception, \fI\%mpi4py.futures\fP emits a
warning and takes a “cross\-fingers” attitude to continue execution in the
hope that serializing MPI calls with a global lock will actually work.
.UNINDENT
.UNINDENT
.SS MPICommExecutor
.sp
Legacy MPI\-1 implementations (as well as some vendor MPI\-2 implementations) do
not support the dynamic process management features introduced in the MPI\-2
standard. Additionally, job schedulers and batch systems in supercomputing
facilities may pose additional complications to applications using the
\fBMPI_Comm_spawn()\fP routine.
.sp
With these issues in mind, \fI\%mpi4py.futures\fP supports an additonal, more
traditional, SPMD\-like usage pattern requiring MPI\-1 calls only. Python
applications are started the usual way, e.g., using the \fBmpiexec\fP
command. Python code should make a collective call to the
\fI\%MPICommExecutor\fP context manager to partition the set of MPI processes
within a MPI communicator in one master processes and many workers
processes. The master process gets access to an \fI\%MPIPoolExecutor\fP
instance to submit tasks. Meanwhile, the worker process follow a different
execution path and team\-up to execute the tasks submitted from the master.
.sp
Besides alleviating the lack of dynamic process managment features in legacy
MPI\-1 or partial MPI\-2 implementations, the \fI\%MPICommExecutor\fP context
manager may be useful in classic MPI\-based Python applications willing to take
advantage of the simple, task\-based, master/worker approach available in the
\fI\%mpi4py.futures\fP package.
.INDENT 0.0
.TP
.B class  mpi4py.futures.MPICommExecutor(comm=None, root=0)
Context manager for \fI\%MPIPoolExecutor\fP\&. This context manager splits a
MPI (intra)communicator \fIcomm\fP (defaults to \fBMPI.COMM_WORLD\fP if not provided
or \fI\%None\fP) in two disjoint sets: a single master process (with rank \fIroot\fP
in \fIcomm\fP) and the remaining worker processes. These sets are then connected
through an intercommunicator.  The target of the \fI\%with\fP statement
is assigned either an \fI\%MPIPoolExecutor\fP instance (at the master) or
\fI\%None\fP (at the workers).
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
from mpi4py.futures import MPICommExecutor

with MPICommExecutor(MPI.COMM_WORLD, root=0) as executor:
    if executor is not None:
       future = executor.submit(abs, \-42)
       assert future.result() == 42
       answer = set(executor.map(abs, [\-42, 42]))
       assert answer == {42}
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
If \fI\%MPICommExecutor\fP is passed a communicator of size one (e.g.,
\fBMPI.COMM_SELF\fP), then the executor instace assigned to the target of the
\fI\%with\fP statement will execute all submitted tasks in a single
worker thread, thus ensuring that task execution still progress
asynchronously. However, the \fI\%GIL\fP will prevent the main and worker
threads from running concurrently in multicore processors. Moreover, the
thread context switching may harm noticeably the performance of CPU\-bound
tasks. In case of I/O\-bound tasks, the \fI\%GIL\fP is not usually an issue,
however, as a single worker thread is used, it progress one task at a
time. We advice against using \fI\%MPICommExecutor\fP with communicators of
size one and suggest refactoring your code to use instead a
\fI\%ThreadPoolExecutor\fP\&.
.UNINDENT
.UNINDENT
.SS Command line
.sp
Recalling the issues related to the lack of support for dynamic process
managment features in MPI implementations, \fI\%mpi4py.futures\fP supports an
alternative usage pattern where Python code (either from scripts, modules, or
zip files) is run under command line control of the \fI\%mpi4py.futures\fP
package by passing \fB\-m mpi4py.futures\fP to the \fBpython\fP
executable.  The \fBmpi4py.futures\fP invocation should be passed a \fIpyfile\fP path
to a script (or a zipfile/directory containing a \fB__main__.py\fP file).
Additionally, \fBmpi4py.futures\fP accepts \fB\-m \fP\fImod\fP to execute a module
named \fImod\fP, \fB\-c \fP\fIcmd\fP to execute a command string \fIcmd\fP, or even
\fB\-\fP to read commands from standard input (\fI\%sys.stdin\fP).
Summarizing, \fBmpi4py.futures\fP can be invoked in the following ways:
.INDENT 0.0
.IP \(bu 2
\fB$ mpiexec \-n \fP\fInumprocs\fP\fB python \-m mpi4py.futures \fP\fIpyfile\fP\fB [arg] ...\fP
.IP \(bu 2
\fB$ mpiexec \-n \fP\fInumprocs\fP\fB python \-m mpi4py.futures \-m \fP\fImod\fP\fB [arg] ...\fP
.IP \(bu 2
\fB$ mpiexec \-n \fP\fInumprocs\fP\fB python \-m mpi4py.futures \-c \fP\fIcmd\fP\fB [arg] ...\fP
.IP \(bu 2
\fB$ mpiexec \-n \fP\fInumprocs\fP\fB python \-m mpi4py.futures \- [arg] ...\fP
.UNINDENT
.sp
Before starting the main script execution, \fI\%mpi4py.futures\fP splits
\fBMPI.COMM_WORLD\fP in one master (the process with rank 0 in \fBMPI.COMM_WORLD\fP) and
\fInumprocs \- 1\fP workers and connects them through an MPI intercommunicator.
Afterwards, the master process proceeds with the execution of the user script
code, which eventually creates \fI\%MPIPoolExecutor\fP instances to submit
tasks. Meanwhile, the worker processes follow a different execution path to
serve the master.  Upon successful termination of the main script at the master,
the entire MPI execution environment exists gracefully. In case of any unhandled
exception in the main script, the master process calls
\fBMPI.COMM_WORLD.Abort(1)\fP to prevent deadlocks and force termination of entire
MPI execution environment.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
Running scripts under command line control of \fI\%mpi4py.futures\fP is quite
similar to executing a single\-process application that spawn additional
workers as required. However, there is a very important difference users
should be aware of. All \fI\%MPIPoolExecutor\fP instances created at the
master will share the pool of workers. Tasks submitted at the master from
many different executors will be scheduled for execution in random order as
soon as a worker is idle. Any executor can easily starve all the workers
(e.g., by calling \fI\%MPIPoolExecutor.map()\fP with long iterables). If that
ever happens, submissions from other executors will not be serviced until
free workers are available.
.UNINDENT
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fI\%Command line\fP
Documentation on Python command line interface.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Examples
.sp
The following \fBjulia.py\fP script computes the \fI\%Julia set\fP and dumps an
image to disk in binary \fI\%PGM\fP format. The code starts by importing
\fI\%MPIPoolExecutor\fP from the \fI\%mpi4py.futures\fP package. Next, some
global constants and functions implement the computation of the Julia set. The
computations are protected with the standard \fBif __name__ == \(aq__main__\(aq:
\&...\fP idiom.  The image is computed by whole scanlines submitting all these
tasks at once using the \fI\%map\fP method. The result
iterator yields scanlines in\-order as the tasks complete. Finally, each
scanline is dumped to disk.
.sp
\fBjulia.py\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py.futures import MPIPoolExecutor

x0, x1, w = \-2.0, +2.0, 640*2
y0, y1, h = \-1.5, +1.5, 480*2
dx = (x1 \- x0) / w
dy = (y1 \- y0) / h

c = complex(0, 0.65)

def julia(x, y):
    z = complex(x, y)
    n = 255
    while abs(z) < 3 and n > 1:
        z = z**2 + c
        n \-= 1
    return n

def julia_line(k):
    line = bytearray(w)
    y = y1 \- k * dy
    for j in range(w):
        x = x0 + j * dx
        line[j] = julia(x, y)
    return line

if __name__ == \(aq__main__\(aq:

    with MPIPoolExecutor() as executor:
        image = executor.map(julia_line, range(h))
        with open(\(aqjulia.pgm\(aq, \(aqwb\(aq) as f:
            f.write(b\(aqP5 %d %d %d\en\(aq % (w, h, 255))
            for line in image:
                f.write(line)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The recommended way to execute the script is by using the \fBmpiexec\fP
command specifying one MPI process (master) and (optional but recommended) the
desired MPI universe size, which determines the number of additional
dynamically spawned processes (workers). The MPI universe size is provided
either by a batch system or set by the user via command\-line arguments to
\fBmpiexec\fP or environment variables. Below we provide examples for
MPICH and Open MPI implementations [1]\&. In all of these examples, the
\fBmpiexec\fP command launches a single master process running the Python
interpreter and executing the main script. When required, \fI\%mpi4py.futures\fP
spawns the pool of 16 worker processes. The master submits tasks to the workers
and waits for the results. The workers receive incoming tasks, execute them,
and send back the results to the master.
.sp
When using MPICH implementation or its derivatives based on the Hydra process
manager, users can set the MPI universe size via the \fB\-usize\fP argument to
\fBmpiexec\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpiexec \-n 1 \-usize 17 python julia.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
or, alternatively, by setting the \fBMPIEXEC_UNIVERSE_SIZE\fP environment
variable:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ MPIEXEC_UNIVERSE_SIZE=17 mpiexec \-n 1 python julia.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In the Open MPI implementation, the MPI universe size can be set via the
\fB\-host\fP argument to \fBmpiexec\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpiexec \-n 1 \-host <hostname>:17 python julia.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Another way to specify the number of workers is to use the
\fI\%mpi4py.futures\fP\-specific environment variable
\fI\%MPI4PY_FUTURES_MAX_WORKERS\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ MPI4PY_FUTURES_MAX_WORKERS=16 mpiexec \-n 1 python julia.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that in this case, the MPI universe size is ignored.
.sp
Alternatively, users may decide to execute the script in a more traditional
way, that is, all the MPI processes are started at once. The user script is run
under command\-line control of \fI\%mpi4py.futures\fP passing the \fI\%\-m\fP flag to the \fBpython\fP executable:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpiexec \-n 17 python \-m mpi4py.futures julia.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
As explained previously, the 17 processes are partitioned in one master and 16
workers. The master process executes the main script while the workers execute
the tasks submitted by the master.
.IP [1] 5
When using an MPI implementation other than MPICH or Open MPI, please
check the documentation of the implementation and/or batch
system for the ways to specify the desired MPI universe size.
.INDENT 0.0
.TP
.B GIL
See \fI\%global interpreter lock\fP\&.
.UNINDENT
.SH MPI4PY.UTIL
.sp
New in version 3.1.0.

.sp
The \fI\%mpi4py.util\fP package collects miscellaneous utilities
within the intersection of Python and MPI.
.SS mpi4py.util.pkl5
.sp
New in version 3.1.0.

.sp
\fI\%pickle\fP protocol 5 (see \fI\%PEP 574\fP) introduced support for out\-of\-band
buffers, allowing for more efficient handling of certain object types with
large memory footprints.
.sp
MPI for Python uses the traditional in\-band handling of buffers. This approach
is appropriate for communicating non\-buffer Python objects, or buffer\-like
objects with small memory footprints. For point\-to\-point communication, in\-band
buffer handling allows for the communication of a pickled stream with a single
MPI message, at the expense of additional CPU and memory overhead in the
pickling and unpickling steps.
.sp
The \fI\%mpi4py.util.pkl5\fP module provides communicator wrapper classes
reimplementing pickle\-based point\-to\-point communication methods using pickle
protocol 5. Handling out\-of\-band buffers necessarily involve multiple MPI
messages, thus increasing latency and hurting performance in case of small size
data. However, in case of large size data, the zero\-copy savings of out\-of\-band
buffer handling more than offset the extra latency costs.  Additionally, these
wrapper methods overcome the infamous 2 GiB message count limit (MPI\-1 to
MPI\-3).
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Support for pickle protocol 5 is available in the \fI\%pickle\fP module
within the Python standard library since Python 3.8. Previous Python 3
releases can use the \fBpickle5\fP backport, which is available on \fI\%PyPI\fP and can be installed with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
python \-m pip install pickle5
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  mpi4py.util.pkl5.Request(request=None)
Request.
.sp
Custom request class for nonblocking communications.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%Request\fP is not a subclass of \fBmpi4py.MPI.Request\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBrequest\fP (\fIIterable\fP\fI[\fP\fIMPI.Request\fP\fI]\fP) – 
.TP
.B Return type
Request
.UNINDENT
.INDENT 7.0
.TP
.B Free()
Free a communication request.
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B cancel()
Cancel a communication request.
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_status(status=None)
Non\-destructive test for the completion of a request.
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B test(status=None)
Test for the completion of a request.
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
Tuple[\fI\%bool\fP, Optional[Any]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B wait(status=None)
Wait for a request to complete.
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  testall(requests, statuses=None)
Test for the completion of all requests.
.INDENT 7.0
.TP
.B Classmethod
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  waitall(requests, statuses=None)
Wait for all requests to complete.
.INDENT 7.0
.TP
.B Classmethod
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  mpi4py.util.pkl5.Message(message=None)
Message.
.sp
Custom message class for matching probes.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
\fI\%Message\fP is not a subclass of \fBmpi4py.MPI.Message\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBmessage\fP (\fIIterable\fP\fI[\fP\fIMPI.Message\fP\fI]\fP) – 
.TP
.B Return type
Message
.UNINDENT
.INDENT 7.0
.TP
.B recv(status=None)
Blocking receive of matched message.
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B irecv()
Nonblocking receive of matched message.
.INDENT 7.0
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  probe(comm, source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking test for a matched message.
.INDENT 7.0
.TP
.B Classmethod
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  iprobe(comm, source=ANY_SOURCE, tag=ANY_TAG, status=None)
Nonblocking test for a matched message.
.INDENT 7.0
.TP
.B Classmethod
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  mpi4py.util.pkl5.Comm
Communicator.
.sp
Base communicator wrapper class.
.INDENT 7.0
.TP
.B send(obj, dest, tag=0)
Blocking send in standard mode.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B bsend(obj, dest, tag=0)
Blocking send in buffered mode.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B ssend(obj, dest, tag=0)
Blocking send in synchronous mode.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B isend(obj, dest, tag=0)
Nonblocking send in standard mode.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B ibsend(obj, dest, tag=0)
Nonblocking send in buffered mode.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B issend(obj, dest, tag=0)
Nonblocking send in synchronous mode.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B recv(buf=None, source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking receive.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIOptional\fP\fI[\fP\fIBuffer\fP\fI]\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B irecv(buf=None, source=ANY_SOURCE, tag=ANY_TAG)
Nonblocking receive.
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
This method cannot be supported reliably
and raises \fI\%RuntimeError\fP\&.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIOptional\fP\fI[\fP\fIBuffer\fP\fI]\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B sendrecv(sendobj, dest, sendtag=0, recvbuf=None, source=ANY_SOURCE, recvtag=ANY_TAG, status=None)
Send and receive.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBsendtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIOptional\fP\fI[\fP\fIBuffer\fP\fI]\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBrecvtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B mprobe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking test for a matched message.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Message
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B improbe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Nonblocking test for a matched message.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Optional[Message]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B bcast(obj, root=0)
Broadcast.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class  mpi4py.util.pkl5.Intracomm
Intracommunicator.
.sp
Intracommunicator wrapper class.
.UNINDENT
.INDENT 0.0
.TP
.B class  mpi4py.util.pkl5.Intercomm
Intercommunicator.
.sp
Intercommunicator wrapper class.
.UNINDENT
.SS Examples
.sp
\fBtest\-pkl5\-1.py\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import numpy as np
from mpi4py import MPI
from mpi4py.util import pkl5

comm = pkl5.Intracomm(MPI.COMM_WORLD)  # comm wrapper
size = comm.Get_size()
rank = comm.Get_rank()
dst = (rank + 1) % size
src = (rank \- 1) % size

sobj = np.full(1024**3, rank, dtype=\(aqi4\(aq)  # > 4 GiB
sreq = comm.isend(sobj, dst, tag=42)
robj = comm.recv (None, src, tag=42)
sreq.Free()

assert np.min(robj) == src
assert np.max(robj) == src
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBtest\-pkl5\-2.py\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import numpy as np
from mpi4py import MPI
from mpi4py.util import pkl5

comm = pkl5.Intracomm(MPI.COMM_WORLD)  # comm wrapper
size = comm.Get_size()
rank = comm.Get_rank()
dst = (rank + 1) % size
src = (rank \- 1) % size

sobj = np.full(1024**3, rank, dtype=\(aqi4\(aq)  # > 4 GiB
sreq = comm.isend(sobj, dst, tag=42)

status = MPI.Status()
rmsg = comm.mprobe(status=status)
assert status.Get_source() == src
assert status.Get_tag() == 42
rreq = rmsg.irecv()
robj = rreq.wait()

sreq.Free()
assert np.max(robj) == src
assert np.min(robj) == src
.ft P
.fi
.UNINDENT
.UNINDENT
.SS mpi4py.util.dtlib
.sp
New in version 3.1.0.

.sp
The \fI\%mpi4py.util.dtlib\fP module provides converter routines between NumPy
and MPI datatypes.
.INDENT 0.0
.TP
.B mpi4py.util.dtlib.from_numpy_dtype(dtype)
Convert NumPy datatype to MPI datatype.
.INDENT 7.0
.TP
.B Parameters
\fBdtype\fP (\fI\%numpy.typing.DTypeLike\fP) – NumPy dtype\-like object.
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B mpi4py.util.dtlib.to_numpy_dtype(datatype)
Convert MPI datatype to NumPy datatype.
.INDENT 7.0
.TP
.B Parameters
\fBdatatype\fP (\fIDatatype\fP) – MPI datatype.
.TP
.B Return type
\fI\%numpy.dtype\fP
.UNINDENT
.UNINDENT
.SH MPI4PY.RUN
.sp
New in version 3.0.0.

.sp
At import time, \fBmpi4py\fP initializes the MPI execution environment calling
\fBMPI_Init_thread()\fP and installs an exit hook to automatically call
\fBMPI_Finalize()\fP just before the Python process terminates. Additionally,
\fBmpi4py\fP overrides the default \fBERRORS_ARE_FATAL\fP error handler in favor
of \fBERRORS_RETURN\fP, which allows translating MPI errors in Python
exceptions. These departures from standard MPI behavior may be controversial,
but are quite convenient within the highly dynamic Python programming
environment. Third\-party code using \fBmpi4py\fP can just \fBfrom mpi4py import
MPI\fP and perform MPI calls without the tedious initialization/finalization
handling.  MPI errors, once translated automatically to Python exceptions, can
be dealt with the common \fI\%try\fP…\fI\%except\fP…\fI\%finally\fP clauses; unhandled MPI exceptions will print a traceback
which helps in locating problems in source code.
.sp
Unfortunately, the interplay of automatic MPI finalization and unhandled
exceptions may lead to deadlocks. In unattended runs, these deadlocks will
drain the battery of your laptop, or burn precious allocation hours in your
supercomputing facility.
.sp
Consider the following snippet of Python code. Assume this code is stored in a
standard Python script file and run with \fBmpiexec\fP in two or more
processes.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from mpi4py import MPI
assert MPI.COMM_WORLD.Get_size() > 1
rank = MPI.COMM_WORLD.Get_rank()
if rank == 0:
    1/0
    MPI.COMM_WORLD.send(None, dest=1, tag=42)
elif rank == 1:
    MPI.COMM_WORLD.recv(source=0, tag=42)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Process 0 raises \fI\%ZeroDivisionError\fP exception before performing a send call to
process 1. As the exception is not handled, the Python interpreter running in
process 0 will proceed to exit with non\-zero status. However, as \fBmpi4py\fP
installed a finalizer hook to call \fBMPI_Finalize()\fP before exit, process
0 will block waiting for other processes to also enter the
\fBMPI_Finalize()\fP call. Meanwhile, process 1 will block waiting for a
message to arrive from process 0, thus never reaching to
\fBMPI_Finalize()\fP\&. The whole MPI execution environment is irremediably in
a deadlock state.
.sp
To alleviate this issue, \fBmpi4py\fP offers a simple, alternative command
line execution mechanism based on using the \fI\%\-m\fP
flag and implemented with the \fI\%runpy\fP module. To use this features, Python
code should be run passing \fB\-m mpi4py\fP in the command line invoking the
Python interpreter. In case of unhandled exceptions, the finalizer hook will
call \fBMPI_Abort()\fP on the \fBMPI_COMM_WORLD\fP communicator, thus
effectively aborting the MPI execution environment.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
When a process is forced to abort, resources (e.g. open files) are not
cleaned\-up and any registered finalizers (either with the \fI\%atexit\fP
module, the Python C/API function \fI\%Py_AtExit()\fP, or even the C
standard library function \fBatexit()\fP) will not be executed. Thus,
aborting execution is an extremely impolite way of ensuring process
termination. However, MPI provides no other mechanism to recover from a
deadlock state.
.UNINDENT
.UNINDENT
.SS Interface options
.sp
The use of \fB\-m mpi4py\fP to execute Python code on the command line resembles
that of the Python interpreter.
.INDENT 0.0
.IP \(bu 2
\fBmpiexec \-n \fP\fInumprocs\fP\fB python \-m mpi4py \fP\fIpyfile\fP\fB [arg] ...\fP
.IP \(bu 2
\fBmpiexec \-n \fP\fInumprocs\fP\fB python \-m mpi4py \-m \fP\fImod\fP\fB [arg] ...\fP
.IP \(bu 2
\fBmpiexec \-n \fP\fInumprocs\fP\fB python \-m mpi4py \-c \fP\fIcmd\fP\fB [arg] ...\fP
.IP \(bu 2
\fBmpiexec \-n \fP\fInumprocs\fP\fB python \-m mpi4py \- [arg] ...\fP
.UNINDENT
.INDENT 0.0
.TP
.B <pyfile>
Execute the Python code contained in \fIpyfile\fP, which must be a filesystem
path referring to either a Python file, a directory containing a
\fB__main__.py\fP file, or a zipfile containing a \fB__main__.py\fP
file.
.UNINDENT
.INDENT 0.0
.TP
.B \-m <mod>
Search \fI\%sys.path\fP for the named module \fImod\fP and execute its contents.
.UNINDENT
.INDENT 0.0
.TP
.B \-c <cmd>
Execute the Python code in the \fIcmd\fP string command.
.UNINDENT
.INDENT 0.0
.TP
.B \-
Read commands from standard input (\fI\%sys.stdin\fP).
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fI\%Command line\fP
Documentation on Python command line interface.
.UNINDENT
.UNINDENT
.UNINDENT
.SH REFERENCE
.TS
center;
|l|l|.
_
T{
\fBmpi4py.MPI\fP
T}	T{
Message Passing Interface.
T}
_
.TE
.SS mpi4py.MPI
.sp
Message Passing Interface.
.sp
Classes
.TS
center;
|l|l|.
_
T{
\fBCartcomm\fP([comm])
T}	T{
Cartesian topology intracommunicator
T}
_
T{
\fBComm\fP([comm])
T}	T{
Communicator
T}
_
T{
\fBDatatype\fP([datatype])
T}	T{
Datatype object
T}
_
T{
\fBDistgraphcomm\fP([comm])
T}	T{
Distributed graph topology intracommunicator
T}
_
T{
\fBErrhandler\fP([errhandler])
T}	T{
Error handler
T}
_
T{
\fBFile\fP([file])
T}	T{
File handle
T}
_
T{
\fBGraphcomm\fP([comm])
T}	T{
General graph topology intracommunicator
T}
_
T{
\fBGrequest\fP([request])
T}	T{
Generalized request handle
T}
_
T{
\fBGroup\fP([group])
T}	T{
Group of processes
T}
_
T{
\fBInfo\fP([info])
T}	T{
Info object
T}
_
T{
\fBIntercomm\fP([comm])
T}	T{
Intercommunicator
T}
_
T{
\fBIntracomm\fP([comm])
T}	T{
Intracommunicator
T}
_
T{
\fBMessage\fP([message])
T}	T{
Matched message handle
T}
_
T{
\fBOp\fP([op])
T}	T{
Operation object
T}
_
T{
\fBPickle\fP([dumps, loads, protocol])
T}	T{
Pickle/unpickle Python objects
T}
_
T{
\fBPrequest\fP([request])
T}	T{
Persistent request handle
T}
_
T{
\fBRequest\fP([request])
T}	T{
Request handle
T}
_
T{
\fBStatus\fP([status])
T}	T{
Status object
T}
_
T{
\fBTopocomm\fP([comm])
T}	T{
Topology intracommunicator
T}
_
T{
\fBWin\fP([win])
T}	T{
Window handle
T}
_
T{
\fBmemory\fP(buf)
T}	T{
Memory buffer
T}
_
.TE
.SS mpi4py.MPI.Cartcomm
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Cartcomm(comm=None)
Bases: \fBmpi4py.MPI.Topocomm\fP
.sp
Cartesian topology intracommunicator
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fICartcomm\fP\fI]\fP) – 
.TP
.B Return type
Cartcomm
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, comm=None)
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fICartcomm\fP\fI]\fP) – 
.TP
.B Return type
Cartcomm
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Get_cart_rank\fP(coords)
T}	T{
Translate logical coordinates to ranks
T}
_
T{
\fI\%Get_coords\fP(rank)
T}	T{
Translate ranks to logical coordinates
T}
_
T{
\fI\%Get_dim\fP()
T}	T{
Return number of dimensions
T}
_
T{
\fI\%Get_topo\fP()
T}	T{
Return information on the cartesian topology
T}
_
T{
\fI\%Shift\fP(direction, disp)
T}	T{
Return a tuple (source, dest) of process ranks for data shifting with Comm.Sendrecv()
T}
_
T{
\fI\%Sub\fP(remain_dims)
T}	T{
Return cartesian communicators that form lower\-dimensional subgrids
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%coords\fP
T}	T{
coordinates
T}
_
T{
\fI\%dim\fP
T}	T{
number of dimensions
T}
_
T{
\fI\%dims\fP
T}	T{
dimensions
T}
_
T{
\fI\%ndim\fP
T}	T{
number of dimensions
T}
_
T{
\fI\%periods\fP
T}	T{
periodicity
T}
_
T{
\fI\%topo\fP
T}	T{
topology information
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Get_cart_rank(coords)
Translate logical coordinates to ranks
.INDENT 7.0
.TP
.B Parameters
\fBcoords\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_coords(rank)
Translate ranks to logical coordinates
.INDENT 7.0
.TP
.B Parameters
\fBrank\fP (\fI\%int\fP) – 
.TP
.B Return type
List[\fI\%int\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_dim()
Return number of dimensions
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_topo()
Return information on the cartesian topology
.INDENT 7.0
.TP
.B Return type
Tuple[List[\fI\%int\fP], List[\fI\%int\fP], List[\fI\%int\fP]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Shift(direction, disp)
Return a tuple (source, dest) of process ranks
for data shifting with Comm.Sendrecv()
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdirection\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBdisp\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Tuple[\fI\%int\fP, \fI\%int\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Sub(remain_dims)
Return cartesian communicators
that form lower\-dimensional subgrids
.INDENT 7.0
.TP
.B Parameters
\fBremain_dims\fP (\fISequence\fP\fI[\fP\fI\%bool\fP\fI]\fP) – 
.TP
.B Return type
Cartcomm
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B coords
coordinates
.UNINDENT
.INDENT 7.0
.TP
.B dim
number of dimensions
.UNINDENT
.INDENT 7.0
.TP
.B dims
dimensions
.UNINDENT
.INDENT 7.0
.TP
.B ndim
number of dimensions
.UNINDENT
.INDENT 7.0
.TP
.B periods
periodicity
.UNINDENT
.INDENT 7.0
.TP
.B topo
topology information
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Comm
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Comm(comm=None)
Bases: \fI\%object\fP
.sp
Communicator
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIComm\fP\fI]\fP) – 
.TP
.B Return type
Comm
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, comm=None)
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIComm\fP\fI]\fP) – 
.TP
.B Return type
Comm
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Abort\fP([errorcode])
T}	T{
Terminate MPI execution environment
T}
_
T{
\fI\%Allgather\fP(sendbuf, recvbuf)
T}	T{
Gather to All, gather data from all processes and distribute it to all other processes in a group
T}
_
T{
\fI\%Allgatherv\fP(sendbuf, recvbuf)
T}	T{
Gather to All Vector, gather data from all processes and distribute it to all other processes in a group providing different amount of data and displacements
T}
_
T{
\fI\%Allreduce\fP(sendbuf, recvbuf[, op])
T}	T{
Reduce to All
T}
_
T{
\fI\%Alltoall\fP(sendbuf, recvbuf)
T}	T{
All to All Scatter/Gather, send data from all to all processes in a group
T}
_
T{
\fI\%Alltoallv\fP(sendbuf, recvbuf)
T}	T{
All to All Scatter/Gather Vector, send data from all to all processes in a group providing different amount of data and displacements
T}
_
T{
\fI\%Alltoallw\fP(sendbuf, recvbuf)
T}	T{
Generalized All\-to\-All communication allowing different counts, displacements and datatypes for each partner
T}
_
T{
\fI\%Barrier\fP()
T}	T{
Barrier synchronization
T}
_
T{
\fI\%Bcast\fP(buf[, root])
T}	T{
Broadcast a message from one process to all other processes in a group
T}
_
T{
\fI\%Bsend\fP(buf, dest[, tag])
T}	T{
Blocking send in buffered mode
T}
_
T{
\fI\%Bsend_init\fP(buf, dest[, tag])
T}	T{
Persistent request for a send in buffered mode
T}
_
T{
\fI\%Call_errhandler\fP(errorcode)
T}	T{
Call the error handler installed on a communicator
T}
_
T{
\fI\%Clone\fP()
T}	T{
Clone an existing communicator
T}
_
T{
\fI\%Compare\fP(comm1, comm2)
T}	T{
Compare two communicators
T}
_
T{
\fI\%Create\fP(group)
T}	T{
Create communicator from group
T}
_
T{
\fI\%Create_group\fP(group[, tag])
T}	T{
Create communicator from group
T}
_
T{
\fI\%Create_keyval\fP([copy_fn, delete_fn, nopython])
T}	T{
Create a new attribute key for communicators
T}
_
T{
\fI\%Delete_attr\fP(keyval)
T}	T{
Delete attribute value associated with a key
T}
_
T{
\fI\%Disconnect\fP()
T}	T{
Disconnect from a communicator
T}
_
T{
\fI\%Dup\fP([info])
T}	T{
Duplicate an existing communicator
T}
_
T{
\fI\%Dup_with_info\fP(info)
T}	T{
Duplicate an existing communicator
T}
_
T{
\fI\%Free\fP()
T}	T{
Free a communicator
T}
_
T{
\fI\%Free_keyval\fP(keyval)
T}	T{
Free an attribute key for communicators
T}
_
T{
\fI\%Gather\fP(sendbuf, recvbuf[, root])
T}	T{
Gather together values from a group of processes
T}
_
T{
\fI\%Gatherv\fP(sendbuf, recvbuf[, root])
T}	T{
Gather Vector, gather data to one process from all other processes in a group providing different amount of data and displacements at the receiving sides
T}
_
T{
\fI\%Get_attr\fP(keyval)
T}	T{
Retrieve attribute value by key
T}
_
T{
\fI\%Get_errhandler\fP()
T}	T{
Get the error handler for a communicator
T}
_
T{
\fI\%Get_group\fP()
T}	T{
Access the group associated with a communicator
T}
_
T{
\fI\%Get_info\fP()
T}	T{
Return the hints for a communicator that are currently in use
T}
_
T{
\fI\%Get_name\fP()
T}	T{
Get the print name for this communicator
T}
_
T{
\fI\%Get_parent\fP()
T}	T{
Return the parent intercommunicator for this process
T}
_
T{
\fI\%Get_rank\fP()
T}	T{
Return the rank of this process in a communicator
T}
_
T{
\fI\%Get_size\fP()
T}	T{
Return the number of processes in a communicator
T}
_
T{
\fI\%Get_topology\fP()
T}	T{
Determine the type of topology (if any) associated with a communicator
T}
_
T{
\fI\%Iallgather\fP(sendbuf, recvbuf)
T}	T{
Nonblocking Gather to All
T}
_
T{
\fI\%Iallgatherv\fP(sendbuf, recvbuf)
T}	T{
Nonblocking Gather to All Vector
T}
_
T{
\fI\%Iallreduce\fP(sendbuf, recvbuf[, op])
T}	T{
Nonblocking Reduce to All
T}
_
T{
\fI\%Ialltoall\fP(sendbuf, recvbuf)
T}	T{
Nonblocking All to All Scatter/Gather
T}
_
T{
\fI\%Ialltoallv\fP(sendbuf, recvbuf)
T}	T{
Nonblocking All to All Scatter/Gather Vector
T}
_
T{
\fI\%Ialltoallw\fP(sendbuf, recvbuf)
T}	T{
Nonblocking Generalized All\-to\-All
T}
_
T{
\fI\%Ibarrier\fP()
T}	T{
Nonblocking Barrier
T}
_
T{
\fI\%Ibcast\fP(buf[, root])
T}	T{
Nonblocking Broadcast
T}
_
T{
\fI\%Ibsend\fP(buf, dest[, tag])
T}	T{
Nonblocking send in buffered mode
T}
_
T{
\fI\%Idup\fP()
T}	T{
Nonblocking duplicate an existing communicator
T}
_
T{
\fI\%Igather\fP(sendbuf, recvbuf[, root])
T}	T{
Nonblocking Gather
T}
_
T{
\fI\%Igatherv\fP(sendbuf, recvbuf[, root])
T}	T{
Nonblocking Gather Vector
T}
_
T{
\fI\%Improbe\fP([source, tag, status])
T}	T{
Nonblocking test for a matched message
T}
_
T{
\fI\%Iprobe\fP([source, tag, status])
T}	T{
Nonblocking test for a message
T}
_
T{
\fI\%Irecv\fP(buf[, source, tag])
T}	T{
Nonblocking receive
T}
_
T{
\fI\%Ireduce\fP(sendbuf, recvbuf[, op, root])
T}	T{
Nonblocking Reduce to Root
T}
_
T{
\fI\%Ireduce_scatter\fP(sendbuf, recvbuf[, ...])
T}	T{
Nonblocking Reduce\-Scatter (vector version)
T}
_
T{
\fI\%Ireduce_scatter_block\fP(sendbuf, recvbuf[, op])
T}	T{
Nonblocking Reduce\-Scatter Block (regular, non\-vector version)
T}
_
T{
\fI\%Irsend\fP(buf, dest[, tag])
T}	T{
Nonblocking send in ready mode
T}
_
T{
\fI\%Is_inter\fP()
T}	T{
Test to see if a comm is an intercommunicator
T}
_
T{
\fI\%Is_intra\fP()
T}	T{
Test to see if a comm is an intracommunicator
T}
_
T{
\fI\%Iscatter\fP(sendbuf, recvbuf[, root])
T}	T{
Nonblocking Scatter
T}
_
T{
\fI\%Iscatterv\fP(sendbuf, recvbuf[, root])
T}	T{
Nonblocking Scatter Vector
T}
_
T{
\fI\%Isend\fP(buf, dest[, tag])
T}	T{
Nonblocking send
T}
_
T{
\fI\%Issend\fP(buf, dest[, tag])
T}	T{
Nonblocking send in synchronous mode
T}
_
T{
\fI\%Join\fP(fd)
T}	T{
Create a intercommunicator by joining two processes connected by a socket
T}
_
T{
\fI\%Mprobe\fP([source, tag, status])
T}	T{
Blocking test for a matched message
T}
_
T{
\fI\%Probe\fP([source, tag, status])
T}	T{
Blocking test for a message
T}
_
T{
\fI\%Recv\fP(buf[, source, tag, status])
T}	T{
Blocking receive
T}
_
T{
\fI\%Recv_init\fP(buf[, source, tag])
T}	T{
Create a persistent request for a receive
T}
_
T{
\fI\%Reduce\fP(sendbuf, recvbuf[, op, root])
T}	T{
Reduce to Root
T}
_
T{
\fI\%Reduce_scatter\fP(sendbuf, recvbuf[, ...])
T}	T{
Reduce\-Scatter (vector version)
T}
_
T{
\fI\%Reduce_scatter_block\fP(sendbuf, recvbuf[, op])
T}	T{
Reduce\-Scatter Block (regular, non\-vector version)
T}
_
T{
\fI\%Rsend\fP(buf, dest[, tag])
T}	T{
Blocking send in ready mode
T}
_
T{
\fI\%Rsend_init\fP(buf, dest[, tag])
T}	T{
Persistent request for a send in ready mode
T}
_
T{
\fI\%Scatter\fP(sendbuf, recvbuf[, root])
T}	T{
Scatter data from one process to all other processes in a group
T}
_
T{
\fI\%Scatterv\fP(sendbuf, recvbuf[, root])
T}	T{
Scatter Vector, scatter data from one process to all other processes in a group providing different amount of data and displacements at the sending side
T}
_
T{
\fI\%Send\fP(buf, dest[, tag])
T}	T{
Blocking send
T}
_
T{
\fI\%Send_init\fP(buf, dest[, tag])
T}	T{
Create a persistent request for a standard send
T}
_
T{
\fI\%Sendrecv\fP(sendbuf, dest[, sendtag, recvbuf, ...])
T}	T{
Send and receive a message
T}
_
T{
\fI\%Sendrecv_replace\fP(buf, dest[, sendtag, ...])
T}	T{
Send and receive a message
T}
_
T{
\fI\%Set_attr\fP(keyval, attrval)
T}	T{
Store attribute value associated with a key
T}
_
T{
\fI\%Set_errhandler\fP(errhandler)
T}	T{
Set the error handler for a communicator
T}
_
T{
\fI\%Set_info\fP(info)
T}	T{
Set new values for the hints associated with a communicator
T}
_
T{
\fI\%Set_name\fP(name)
T}	T{
Set the print name for this communicator
T}
_
T{
\fI\%Split\fP([color, key])
T}	T{
Split communicator by color and key
T}
_
T{
\fI\%Split_type\fP(split_type[, key, info])
T}	T{
Split communicator by split type
T}
_
T{
\fI\%Ssend\fP(buf, dest[, tag])
T}	T{
Blocking send in synchronous mode
T}
_
T{
\fI\%Ssend_init\fP(buf, dest[, tag])
T}	T{
Persistent request for a send in synchronous mode
T}
_
T{
\fI\%allgather\fP(sendobj)
T}	T{
Gather to All
T}
_
T{
\fI\%allreduce\fP(sendobj[, op])
T}	T{
Reduce to All
T}
_
T{
\fI\%alltoall\fP(sendobj)
T}	T{
All to All Scatter/Gather
T}
_
T{
\fI\%barrier\fP()
T}	T{
Barrier
T}
_
T{
\fI\%bcast\fP(obj[, root])
T}	T{
Broadcast
T}
_
T{
\fI\%bsend\fP(obj, dest[, tag])
T}	T{
Send in buffered mode
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%gather\fP(sendobj[, root])
T}	T{
Gather
T}
_
T{
\fI\%ibsend\fP(obj, dest[, tag])
T}	T{
Nonblocking send in buffered mode
T}
_
T{
\fI\%improbe\fP([source, tag, status])
T}	T{
Nonblocking test for a matched message
T}
_
T{
\fI\%iprobe\fP([source, tag, status])
T}	T{
Nonblocking test for a message
T}
_
T{
\fI\%irecv\fP([buf, source, tag])
T}	T{
Nonblocking receive
T}
_
T{
\fI\%isend\fP(obj, dest[, tag])
T}	T{
Nonblocking send
T}
_
T{
\fI\%issend\fP(obj, dest[, tag])
T}	T{
Nonblocking send in synchronous mode
T}
_
T{
\fI\%mprobe\fP([source, tag, status])
T}	T{
Blocking test for a matched message
T}
_
T{
\fI\%probe\fP([source, tag, status])
T}	T{
Blocking test for a message
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
T{
\fI\%recv\fP([buf, source, tag, status])
T}	T{
Receive
T}
_
T{
\fI\%reduce\fP(sendobj[, op, root])
T}	T{
Reduce to Root
T}
_
T{
\fI\%scatter\fP(sendobj[, root])
T}	T{
Scatter
T}
_
T{
\fI\%send\fP(obj, dest[, tag])
T}	T{
Send
T}
_
T{
\fI\%sendrecv\fP(sendobj, dest[, sendtag, recvbuf, ...])
T}	T{
Send and Receive
T}
_
T{
\fI\%ssend\fP(obj, dest[, tag])
T}	T{
Send in synchronous mode
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%group\fP
T}	T{
communicator group
T}
_
T{
\fI\%info\fP
T}	T{
communicator info
T}
_
T{
\fI\%is_inter\fP
T}	T{
is intercommunicator
T}
_
T{
\fI\%is_intra\fP
T}	T{
is intracommunicator
T}
_
T{
\fI\%is_topo\fP
T}	T{
is a topology communicator
T}
_
T{
\fI\%name\fP
T}	T{
communicator name
T}
_
T{
\fI\%rank\fP
T}	T{
rank of this process in communicator
T}
_
T{
\fI\%size\fP
T}	T{
number of processes in communicator
T}
_
T{
\fI\%topology\fP
T}	T{
communicator topology type
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Abort(errorcode=0)
Terminate MPI execution environment
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
This is a direct call, use it with care!!!.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBerrorcode\fP (\fI\%int\fP) – 
.TP
.B Return type
NoReturn
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Allgather(sendbuf, recvbuf)
Gather to All, gather data from all processes and
distribute it to all other processes in a group
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecB\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Allgatherv(sendbuf, recvbuf)
Gather to All Vector, gather data from all processes and
distribute it to all other processes in a group providing
different amount of data and displacements
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecV\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Allreduce(sendbuf, recvbuf, op=SUM)
Reduce to All
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Alltoall(sendbuf, recvbuf)
All to All Scatter/Gather, send data from all to all
processes in a group
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpecB\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecB\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Alltoallv(sendbuf, recvbuf)
All to All Scatter/Gather Vector, send data from all to all
processes in a group providing different amount of data and
displacements
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpecV\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecV\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Alltoallw(sendbuf, recvbuf)
Generalized All\-to\-All communication allowing different
counts, displacements and datatypes for each partner
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpecW\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecW\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Barrier()
Barrier synchronization
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Bcast(buf, root=0)
Broadcast a message from one process
to all other processes in a group
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Bsend(buf, dest, tag=0)
Blocking send in buffered mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Bsend_init(buf, dest, tag=0)
Persistent request for a send in buffered mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Call_errhandler(errorcode)
Call the error handler installed on a communicator
.INDENT 7.0
.TP
.B Parameters
\fBerrorcode\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Clone()
Clone an existing communicator
.INDENT 7.0
.TP
.B Return type
Comm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Compare(comm1, comm2)
Compare two communicators
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcomm1\fP (\fIComm\fP) – 
.IP \(bu 2
\fBcomm2\fP (\fIComm\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create(group)
Create communicator from group
.INDENT 7.0
.TP
.B Parameters
\fBgroup\fP (\fIGroup\fP) – 
.TP
.B Return type
Comm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_group(group, tag=0)
Create communicator from group
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgroup\fP (\fIGroup\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Comm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Create_keyval(copy_fn=None, delete_fn=None, nopython=False)
Create a new attribute key for communicators
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcopy_fn\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIComm\fP\fI, \fP\fI\%int\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBdelete_fn\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIComm\fP\fI, \fP\fI\%int\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fI\%None\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBnopython\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Delete_attr(keyval)
Delete attribute value associated with a key
.INDENT 7.0
.TP
.B Parameters
\fBkeyval\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Disconnect()
Disconnect from a communicator
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Dup(info=None)
Duplicate an existing communicator
.INDENT 7.0
.TP
.B Parameters
\fBinfo\fP (\fIOptional\fP\fI[\fP\fIInfo\fP\fI]\fP) – 
.TP
.B Return type
Comm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Dup_with_info(info)
Duplicate an existing communicator
.INDENT 7.0
.TP
.B Parameters
\fBinfo\fP (\fIInfo\fP) – 
.TP
.B Return type
Comm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Free()
Free a communicator
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Free_keyval(keyval)
Free an attribute key for communicators
.INDENT 7.0
.TP
.B Parameters
\fBkeyval\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Gather(sendbuf, recvbuf, root=0)
Gather together values from a group of processes
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpecB\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Gatherv(sendbuf, recvbuf, root=0)
Gather Vector, gather data to one process from all other
processes in a group providing different amount of data and
displacements at the receiving sides
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpecV\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_attr(keyval)
Retrieve attribute value by key
.INDENT 7.0
.TP
.B Parameters
\fBkeyval\fP (\fI\%int\fP) – 
.TP
.B Return type
Optional[Union[\fI\%int\fP, Any]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_errhandler()
Get the error handler for a communicator
.INDENT 7.0
.TP
.B Return type
Errhandler
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_group()
Access the group associated with a communicator
.INDENT 7.0
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_info()
Return the hints for a communicator
that are currently in use
.INDENT 7.0
.TP
.B Return type
Info
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_name()
Get the print name for this communicator
.INDENT 7.0
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Get_parent()
Return the parent intercommunicator for this process
.INDENT 7.0
.TP
.B Return type
Intercomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_rank()
Return the rank of this process in a communicator
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_size()
Return the number of processes in a communicator
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_topology()
Determine the type of topology (if any)
associated with a communicator
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iallgather(sendbuf, recvbuf)
Nonblocking Gather to All
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecB\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iallgatherv(sendbuf, recvbuf)
Nonblocking Gather to All Vector
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecV\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iallreduce(sendbuf, recvbuf, op=SUM)
Nonblocking Reduce to All
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ialltoall(sendbuf, recvbuf)
Nonblocking All to All Scatter/Gather
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpecB\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecB\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ialltoallv(sendbuf, recvbuf)
Nonblocking All to All Scatter/Gather Vector
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpecV\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecV\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ialltoallw(sendbuf, recvbuf)
Nonblocking Generalized All\-to\-All
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpecW\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecW\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ibarrier()
Nonblocking Barrier
.INDENT 7.0
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ibcast(buf, root=0)
Nonblocking Broadcast
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ibsend(buf, dest, tag=0)
Nonblocking send in buffered mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Idup()
Nonblocking duplicate an existing communicator
.INDENT 7.0
.TP
.B Return type
Tuple[Comm, Request]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Igather(sendbuf, recvbuf, root=0)
Nonblocking Gather
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpecB\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Igatherv(sendbuf, recvbuf, root=0)
Nonblocking Gather Vector
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpecV\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Improbe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Nonblocking test for a matched message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Optional[Message]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iprobe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Nonblocking test for a message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Irecv(buf, source=ANY_SOURCE, tag=ANY_TAG)
Nonblocking receive
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ireduce(sendbuf, recvbuf, op=SUM, root=0)
Nonblocking Reduce to Root
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpec\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ireduce_scatter(sendbuf, recvbuf, recvcounts=None, op=SUM)
Nonblocking Reduce\-Scatter (vector version)
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBrecvcounts\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ireduce_scatter_block(sendbuf, recvbuf, op=SUM)
Nonblocking Reduce\-Scatter Block (regular, non\-vector version)
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpecB\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIBufSpecB\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Irsend(buf, dest, tag=0)
Nonblocking send in ready mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Is_inter()
Test to see if a comm is an intercommunicator
.INDENT 7.0
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Is_intra()
Test to see if a comm is an intracommunicator
.INDENT 7.0
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iscatter(sendbuf, recvbuf, root=0)
Nonblocking Scatter
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpecB\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iscatterv(sendbuf, recvbuf, root=0)
Nonblocking Scatter Vector
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpecV\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Isend(buf, dest, tag=0)
Nonblocking send
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Issend(buf, dest, tag=0)
Nonblocking send in synchronous mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Join(fd)
Create a intercommunicator by joining
two processes connected by a socket
.INDENT 7.0
.TP
.B Parameters
\fBfd\fP (\fI\%int\fP) – 
.TP
.B Return type
Intercomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Mprobe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking test for a matched message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Message
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Probe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking test for a message
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This function blocks until the message arrives.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Literal[True]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Recv(buf, source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking receive
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This function blocks until the message is received
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Recv_init(buf, source=ANY_SOURCE, tag=ANY_TAG)
Create a persistent request for a receive
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Prequest
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Reduce(sendbuf, recvbuf, op=SUM, root=0)
Reduce to Root
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpec\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Reduce_scatter(sendbuf, recvbuf, recvcounts=None, op=SUM)
Reduce\-Scatter (vector version)
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBrecvcounts\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Reduce_scatter_block(sendbuf, recvbuf, op=SUM)
Reduce\-Scatter Block (regular, non\-vector version)
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpecB\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIBufSpecB\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Rsend(buf, dest, tag=0)
Blocking send in ready mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Rsend_init(buf, dest, tag=0)
Persistent request for a send in ready mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Scatter(sendbuf, recvbuf, root=0)
Scatter data from one process
to all other processes in a group
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpecB\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Scatterv(sendbuf, recvbuf, root=0)
Scatter Vector, scatter data from one process to all other
processes in a group providing different amount of data and
displacements at the sending side
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIOptional\fP\fI[\fP\fIBufSpecV\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Send(buf, dest, tag=0)
Blocking send
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This function may block until the message is
received. Whether or not \fI\%Send\fP blocks depends on
several factors and is implementation dependent
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Send_init(buf, dest, tag=0)
Create a persistent request for a standard send
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Prequest
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Sendrecv(sendbuf, dest, sendtag=0, recvbuf=None, source=ANY_SOURCE, recvtag=ANY_TAG, status=None)
Send and receive a message
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This function is guaranteed not to deadlock in
situations where pairs of blocking sends and receives may
deadlock.
.UNINDENT
.UNINDENT
.sp
\fBCAUTION:\fP
.INDENT 7.0
.INDENT 3.5
A common mistake when using this function is to
mismatch the tags with the source and destination ranks,
which can result in deadlock.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBsendtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBrecvtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Sendrecv_replace(buf, dest, sendtag=0, source=ANY_SOURCE, recvtag=ANY_TAG, status=None)
Send and receive a message
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This function is guaranteed not to deadlock in
situations where pairs of blocking sends and receives may
deadlock.
.UNINDENT
.UNINDENT
.sp
\fBCAUTION:\fP
.INDENT 7.0
.INDENT 3.5
A common mistake when using this function is to
mismatch the tags with the source and destination ranks,
which can result in deadlock.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBsendtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBrecvtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_attr(keyval, attrval)
Store attribute value associated with a key
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBkeyval\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBattrval\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_errhandler(errhandler)
Set the error handler for a communicator
.INDENT 7.0
.TP
.B Parameters
\fBerrhandler\fP (\fIErrhandler\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_info(info)
Set new values for the hints
associated with a communicator
.INDENT 7.0
.TP
.B Parameters
\fBinfo\fP (\fIInfo\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_name(name)
Set the print name for this communicator
.INDENT 7.0
.TP
.B Parameters
\fBname\fP (\fI\%str\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Split(color=0, key=0)
Split communicator by color and key
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcolor\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBkey\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Comm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Split_type(split_type, key=0, info=INFO_NULL)
Split communicator by split type
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsplit_type\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBkey\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.UNINDENT
.TP
.B Return type
Comm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ssend(buf, dest, tag=0)
Blocking send in synchronous mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ssend_init(buf, dest, tag=0)
Persistent request for a send in synchronous mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B allgather(sendobj)
Gather to All
.INDENT 7.0
.TP
.B Parameters
\fBsendobj\fP (\fIAny\fP) – 
.TP
.B Return type
List[Any]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B allreduce(sendobj, op=SUM)
Reduce to All
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBop\fP (\fIUnion\fP\fI[\fP\fIOp\fP\fI, \fP\fICallable\fP\fI[\fP\fI[\fP\fIAny\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B alltoall(sendobj)
All to All Scatter/Gather
.INDENT 7.0
.TP
.B Parameters
\fBsendobj\fP (\fISequence\fP\fI[\fP\fIAny\fP\fI]\fP) – 
.TP
.B Return type
List[Any]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B barrier()
Barrier
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B bcast(obj, root=0)
Broadcast
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B bsend(obj, dest, tag=0)
Send in buffered mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
Comm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B gather(sendobj, root=0)
Gather
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Optional[List[Any]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B ibsend(obj, dest, tag=0)
Nonblocking send in buffered mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B improbe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Nonblocking test for a matched message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Optional[Message]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B iprobe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Nonblocking test for a message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B irecv(buf=None, source=ANY_SOURCE, tag=ANY_TAG)
Nonblocking receive
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIOptional\fP\fI[\fP\fIBuffer\fP\fI]\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B isend(obj, dest, tag=0)
Nonblocking send
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B issend(obj, dest, tag=0)
Nonblocking send in synchronous mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B mprobe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking test for a matched message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Message
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B probe(source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking test for a message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Literal[True]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B recv(buf=None, source=ANY_SOURCE, tag=ANY_TAG, status=None)
Receive
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIOptional\fP\fI[\fP\fIBuffer\fP\fI]\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B reduce(sendobj, op=SUM, root=0)
Reduce to Root
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBop\fP (\fIUnion\fP\fI[\fP\fIOp\fP\fI, \fP\fICallable\fP\fI[\fP\fI[\fP\fIAny\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Optional[Any]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B scatter(sendobj, root=0)
Scatter
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendobj\fP (\fISequence\fP\fI[\fP\fIAny\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B send(obj, dest, tag=0)
Send
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B sendrecv(sendobj, dest, sendtag=0, recvbuf=None, source=ANY_SOURCE, recvtag=ANY_TAG, status=None)
Send and Receive
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBsendtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIOptional\fP\fI[\fP\fIBuffer\fP\fI]\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBrecvtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B ssend(obj, dest, tag=0)
Send in synchronous mode
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBdest\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B group
communicator group
.UNINDENT
.INDENT 7.0
.TP
.B info
communicator info
.UNINDENT
.INDENT 7.0
.TP
.B is_inter
is intercommunicator
.UNINDENT
.INDENT 7.0
.TP
.B is_intra
is intracommunicator
.UNINDENT
.INDENT 7.0
.TP
.B is_topo
is a topology communicator
.UNINDENT
.INDENT 7.0
.TP
.B name
communicator name
.UNINDENT
.INDENT 7.0
.TP
.B rank
rank of this process in communicator
.UNINDENT
.INDENT 7.0
.TP
.B size
number of processes in communicator
.UNINDENT
.INDENT 7.0
.TP
.B topology
communicator topology type
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Datatype
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Datatype(datatype=None)
Bases: \fI\%object\fP
.sp
Datatype object
.INDENT 7.0
.TP
.B Parameters
\fBdatatype\fP (\fIOptional\fP\fI[\fP\fIDatatype\fP\fI]\fP) – 
.TP
.B Return type
Datatype
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, datatype=None)
.INDENT 7.0
.TP
.B Parameters
\fBdatatype\fP (\fIOptional\fP\fI[\fP\fIDatatype\fP\fI]\fP) – 
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Commit\fP()
T}	T{
Commit the datatype
T}
_
T{
\fI\%Create_contiguous\fP(count)
T}	T{
Create a contiguous datatype
T}
_
T{
\fI\%Create_darray\fP(size, rank, gsizes, distribs, ...)
T}	T{
Create a datatype representing an HPF\-like distributed array on Cartesian process grids
T}
_
T{
\fI\%Create_f90_complex\fP(p, r)
T}	T{
Return a bounded complex datatype
T}
_
T{
\fI\%Create_f90_integer\fP(r)
T}	T{
Return a bounded integer datatype
T}
_
T{
\fI\%Create_f90_real\fP(p, r)
T}	T{
Return a bounded real datatype
T}
_
T{
\fI\%Create_hindexed\fP(blocklengths, displacements)
T}	T{
Create an indexed datatype with displacements in bytes
T}
_
T{
\fI\%Create_hindexed_block\fP(blocklength, displacements)
T}	T{
Create an indexed datatype with constant\-sized blocks and displacements in bytes
T}
_
T{
\fI\%Create_hvector\fP(count, blocklength, stride)
T}	T{
Create a vector (strided) datatype
T}
_
T{
\fI\%Create_indexed\fP(blocklengths, displacements)
T}	T{
Create an indexed datatype
T}
_
T{
\fI\%Create_indexed_block\fP(blocklength, displacements)
T}	T{
Create an indexed datatype with constant\-sized blocks
T}
_
T{
\fI\%Create_keyval\fP([copy_fn, delete_fn, nopython])
T}	T{
Create a new attribute key for datatypes
T}
_
T{
\fI\%Create_resized\fP(lb, extent)
T}	T{
Create a datatype with a new lower bound and extent
T}
_
T{
\fI\%Create_struct\fP(blocklengths, displacements, ...)
T}	T{
Create an datatype from a general set of block sizes, displacements and datatypes
T}
_
T{
\fI\%Create_subarray\fP(sizes, subsizes, starts[, order])
T}	T{
Create a datatype for a subarray of a regular, multidimensional array
T}
_
T{
\fI\%Create_vector\fP(count, blocklength, stride)
T}	T{
Create a vector (strided) datatype
T}
_
T{
\fI\%Delete_attr\fP(keyval)
T}	T{
Delete attribute value associated with a key
T}
_
T{
\fI\%Dup\fP()
T}	T{
Duplicate a datatype
T}
_
T{
\fI\%Free\fP()
T}	T{
Free the datatype
T}
_
T{
\fI\%Free_keyval\fP(keyval)
T}	T{
Free an attribute key for datatypes
T}
_
T{
\fI\%Get_attr\fP(keyval)
T}	T{
Retrieve attribute value by key
T}
_
T{
\fI\%Get_contents\fP()
T}	T{
Retrieve the actual arguments used in the call that created a datatype
T}
_
T{
\fI\%Get_envelope\fP()
T}	T{
Return information on the number and type of input arguments used in the call that created a datatype
T}
_
T{
\fI\%Get_extent\fP()
T}	T{
Return lower bound and extent of datatype
T}
_
T{
\fI\%Get_name\fP()
T}	T{
Get the print name for this datatype
T}
_
T{
\fI\%Get_size\fP()
T}	T{
Return the number of bytes occupied by entries in the datatype
T}
_
T{
\fI\%Get_true_extent\fP()
T}	T{
Return the true lower bound and extent of a datatype
T}
_
T{
\fI\%Match_size\fP(typeclass, size)
T}	T{
Find a datatype matching a specified size in bytes
T}
_
T{
\fI\%Pack\fP(inbuf, outbuf, position, comm)
T}	T{
Pack into contiguous memory according to datatype.
T}
_
T{
\fI\%Pack_external\fP(datarep, inbuf, outbuf, position)
T}	T{
Pack into contiguous memory according to datatype, using a portable data representation (\fBexternal32\fP).
T}
_
T{
\fI\%Pack_external_size\fP(datarep, count)
T}	T{
Return the upper bound on the amount of space (in bytes) needed to pack a message according to datatype, using a portable data representation (\fBexternal32\fP).
T}
_
T{
\fI\%Pack_size\fP(count, comm)
T}	T{
Return the upper bound on the amount of space (in bytes) needed to pack a message according to datatype.
T}
_
T{
\fI\%Set_attr\fP(keyval, attrval)
T}	T{
Store attribute value associated with a key
T}
_
T{
\fI\%Set_name\fP(name)
T}	T{
Set the print name for this datatype
T}
_
T{
\fI\%Unpack\fP(inbuf, position, outbuf, comm)
T}	T{
Unpack from contiguous memory according to datatype.
T}
_
T{
\fI\%Unpack_external\fP(datarep, inbuf, position, outbuf)
T}	T{
Unpack from contiguous memory according to datatype, using a portable data representation (\fBexternal32\fP).
T}
_
T{
\fI\%decode\fP()
T}	T{
Convenience method for decoding a datatype
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%combiner\fP
T}	T{
datatype combiner
T}
_
T{
\fI\%contents\fP
T}	T{
datatype contents
T}
_
T{
\fI\%envelope\fP
T}	T{
datatype envelope
T}
_
T{
\fI\%extent\fP
T}	T{
T}
_
T{
\fI\%is_named\fP
T}	T{
is a named datatype
T}
_
T{
\fI\%is_predefined\fP
T}	T{
is a predefined datatype
T}
_
T{
\fI\%lb\fP
T}	T{
lower bound
T}
_
T{
\fI\%name\fP
T}	T{
datatype name
T}
_
T{
\fI\%size\fP
T}	T{
T}
_
T{
\fI\%true_extent\fP
T}	T{
true extent
T}
_
T{
\fI\%true_lb\fP
T}	T{
true lower bound
T}
_
T{
\fI\%true_ub\fP
T}	T{
true upper bound
T}
_
T{
\fI\%ub\fP
T}	T{
upper bound
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Commit()
Commit the datatype
.INDENT 7.0
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_contiguous(count)
Create a contiguous datatype
.INDENT 7.0
.TP
.B Parameters
\fBcount\fP (\fI\%int\fP) – 
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_darray(size, rank, gsizes, distribs, dargs, psizes, order=ORDER_C)
Create a datatype representing an HPF\-like
distributed array on Cartesian process grids
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsize\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBrank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBgsizes\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBdistribs\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBdargs\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBpsizes\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBorder\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Create_f90_complex(p, r)
Return a bounded complex datatype
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBp\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBr\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Create_f90_integer(r)
Return a bounded integer datatype
.INDENT 7.0
.TP
.B Parameters
\fBr\fP (\fI\%int\fP) – 
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Create_f90_real(p, r)
Return a bounded real datatype
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBp\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBr\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_hindexed(blocklengths, displacements)
Create an indexed datatype
with displacements in bytes
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBblocklengths\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBdisplacements\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_hindexed_block(blocklength, displacements)
Create an indexed datatype
with constant\-sized blocks
and displacements in bytes
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBblocklength\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBdisplacements\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_hvector(count, blocklength, stride)
Create a vector (strided) datatype
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcount\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBblocklength\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstride\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_indexed(blocklengths, displacements)
Create an indexed datatype
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBblocklengths\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBdisplacements\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_indexed_block(blocklength, displacements)
Create an indexed datatype
with constant\-sized blocks
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBblocklength\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBdisplacements\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Create_keyval(copy_fn=None, delete_fn=None, nopython=False)
Create a new attribute key for datatypes
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcopy_fn\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIDatatype\fP\fI, \fP\fI\%int\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBdelete_fn\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIDatatype\fP\fI, \fP\fI\%int\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fI\%None\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBnopython\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_resized(lb, extent)
Create a datatype with a new lower bound and extent
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBlb\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBextent\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Create_struct(blocklengths, displacements, datatypes)
Create an datatype from a general set of
block sizes, displacements and datatypes
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBblocklengths\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBdisplacements\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBdatatypes\fP (\fISequence\fP\fI[\fP\fIDatatype\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_subarray(sizes, subsizes, starts, order=ORDER_C)
Create a datatype for a subarray of
a regular, multidimensional array
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsizes\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBsubsizes\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBstarts\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBorder\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_vector(count, blocklength, stride)
Create a vector (strided) datatype
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcount\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBblocklength\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstride\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Delete_attr(keyval)
Delete attribute value associated with a key
.INDENT 7.0
.TP
.B Parameters
\fBkeyval\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Dup()
Duplicate a datatype
.INDENT 7.0
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Free()
Free the datatype
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Free_keyval(keyval)
Free an attribute key for datatypes
.INDENT 7.0
.TP
.B Parameters
\fBkeyval\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_attr(keyval)
Retrieve attribute value by key
.INDENT 7.0
.TP
.B Parameters
\fBkeyval\fP (\fI\%int\fP) – 
.TP
.B Return type
Optional[Union[\fI\%int\fP, Any]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_contents()
Retrieve the actual arguments used in the call that created a
datatype
.INDENT 7.0
.TP
.B Return type
Tuple[List[\fI\%int\fP], List[\fI\%int\fP], List[Datatype]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_envelope()
Return information on the number and type of input arguments
used in the call that created a datatype
.INDENT 7.0
.TP
.B Return type
Tuple[\fI\%int\fP, \fI\%int\fP, \fI\%int\fP, \fI\%int\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_extent()
Return lower bound and extent of datatype
.INDENT 7.0
.TP
.B Return type
Tuple[\fI\%int\fP, \fI\%int\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_name()
Get the print name for this datatype
.INDENT 7.0
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_size()
Return the number of bytes occupied
by entries in the datatype
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_true_extent()
Return the true lower bound and extent of a datatype
.INDENT 7.0
.TP
.B Return type
Tuple[\fI\%int\fP, \fI\%int\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Match_size(typeclass, size)
Find a datatype matching a specified size in bytes
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtypeclass\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBsize\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Pack(inbuf, outbuf, position, comm)
Pack into contiguous memory according to datatype.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBinbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBoutbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBposition\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBcomm\fP (\fIComm\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Pack_external(datarep, inbuf, outbuf, position)
Pack into contiguous memory according to datatype,
using a portable data representation (\fBexternal32\fP).
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatarep\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBinbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBoutbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBposition\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Pack_external_size(datarep, count)
Return the upper bound on the amount of space (in bytes)
needed to pack a message according to datatype,
using a portable data representation (\fBexternal32\fP).
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatarep\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBcount\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Pack_size(count, comm)
Return the upper bound on the amount of space (in bytes)
needed to pack a message according to datatype.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcount\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBcomm\fP (\fIComm\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_attr(keyval, attrval)
Store attribute value associated with a key
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBkeyval\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBattrval\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_name(name)
Set the print name for this datatype
.INDENT 7.0
.TP
.B Parameters
\fBname\fP (\fI\%str\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Unpack(inbuf, position, outbuf, comm)
Unpack from contiguous memory according to datatype.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBinbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBposition\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBoutbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBcomm\fP (\fIComm\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Unpack_external(datarep, inbuf, position, outbuf)
Unpack from contiguous memory according to datatype,
using a portable data representation (\fBexternal32\fP).
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatarep\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBinbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBposition\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBoutbuf\fP (\fIBufSpec\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B decode()
Convenience method for decoding a datatype
.INDENT 7.0
.TP
.B Return type
Tuple[Datatype, \fI\%str\fP, Dict[\fI\%str\fP, Any]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
Datatype
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B combiner
datatype combiner
.UNINDENT
.INDENT 7.0
.TP
.B contents
datatype contents
.UNINDENT
.INDENT 7.0
.TP
.B envelope
datatype envelope
.UNINDENT
.INDENT 7.0
.TP
.B extent
.UNINDENT
.INDENT 7.0
.TP
.B is_named
is a named datatype
.UNINDENT
.INDENT 7.0
.TP
.B is_predefined
is a predefined datatype
.UNINDENT
.INDENT 7.0
.TP
.B lb
lower bound
.UNINDENT
.INDENT 7.0
.TP
.B name
datatype name
.UNINDENT
.INDENT 7.0
.TP
.B size
.UNINDENT
.INDENT 7.0
.TP
.B true_extent
true extent
.UNINDENT
.INDENT 7.0
.TP
.B true_lb
true lower bound
.UNINDENT
.INDENT 7.0
.TP
.B true_ub
true upper bound
.UNINDENT
.INDENT 7.0
.TP
.B ub
upper bound
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Distgraphcomm
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Distgraphcomm(comm=None)
Bases: \fBmpi4py.MPI.Topocomm\fP
.sp
Distributed graph topology intracommunicator
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIDistgraphcomm\fP\fI]\fP) – 
.TP
.B Return type
Distgraphcomm
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, comm=None)
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIDistgraphcomm\fP\fI]\fP) – 
.TP
.B Return type
Distgraphcomm
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Get_dist_neighbors\fP()
T}	T{
Return adjacency information for a distributed graph topology
T}
_
T{
\fI\%Get_dist_neighbors_count\fP()
T}	T{
Return adjacency information for a distributed graph topology
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Get_dist_neighbors()
Return adjacency information for a distributed graph topology
.INDENT 7.0
.TP
.B Return type
Tuple[List[\fI\%int\fP], List[\fI\%int\fP], Optional[Tuple[List[\fI\%int\fP], List[\fI\%int\fP]]]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_dist_neighbors_count()
Return adjacency information for a distributed graph topology
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Errhandler
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Errhandler(errhandler=None)
Bases: \fI\%object\fP
.sp
Error handler
.INDENT 7.0
.TP
.B Parameters
\fBerrhandler\fP (\fIOptional\fP\fI[\fP\fIErrhandler\fP\fI]\fP) – 
.TP
.B Return type
Errhandler
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, errhandler=None)
.INDENT 7.0
.TP
.B Parameters
\fBerrhandler\fP (\fIOptional\fP\fI[\fP\fIErrhandler\fP\fI]\fP) – 
.TP
.B Return type
Errhandler
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Free\fP()
T}	T{
Free an error handler
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Free()
Free an error handler
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
Errhandler
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.File
.INDENT 0.0
.TP
.B class  mpi4py.MPI.File(file=None)
Bases: \fI\%object\fP
.sp
File handle
.INDENT 7.0
.TP
.B Parameters
\fBfile\fP (\fIOptional\fP\fI[\fP\fIFile\fP\fI]\fP) – 
.TP
.B Return type
File
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, file=None)
.INDENT 7.0
.TP
.B Parameters
\fBfile\fP (\fIOptional\fP\fI[\fP\fIFile\fP\fI]\fP) – 
.TP
.B Return type
File
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Call_errhandler\fP(errorcode)
T}	T{
Call the error handler installed on a file
T}
_
T{
\fI\%Close\fP()
T}	T{
Close a file
T}
_
T{
\fI\%Delete\fP(filename[, info])
T}	T{
Delete a file
T}
_
T{
\fI\%Get_amode\fP()
T}	T{
Return the file access mode
T}
_
T{
\fI\%Get_atomicity\fP()
T}	T{
Return the atomicity mode
T}
_
T{
\fI\%Get_byte_offset\fP(offset)
T}	T{
Return the absolute byte position in the file corresponding to \(aqoffset\(aq etypes relative to the current view
T}
_
T{
\fI\%Get_errhandler\fP()
T}	T{
Get the error handler for a file
T}
_
T{
\fI\%Get_group\fP()
T}	T{
Return the group of processes that opened the file
T}
_
T{
\fI\%Get_info\fP()
T}	T{
Return the hints for a file that that are currently in use
T}
_
T{
\fI\%Get_position\fP()
T}	T{
Return the current position of the individual file pointer in etype units relative to the current view
T}
_
T{
\fI\%Get_position_shared\fP()
T}	T{
Return the current position of the shared file pointer in etype units relative to the current view
T}
_
T{
\fI\%Get_size\fP()
T}	T{
Return the file size
T}
_
T{
\fI\%Get_type_extent\fP(datatype)
T}	T{
Return the extent of datatype in the file
T}
_
T{
\fI\%Get_view\fP()
T}	T{
Return the file view
T}
_
T{
\fI\%Iread\fP(buf)
T}	T{
Nonblocking read using individual file pointer
T}
_
T{
\fI\%Iread_all\fP(buf)
T}	T{
Nonblocking collective read using individual file pointer
T}
_
T{
\fI\%Iread_at\fP(offset, buf)
T}	T{
Nonblocking read using explicit offset
T}
_
T{
\fI\%Iread_at_all\fP(offset, buf)
T}	T{
Nonblocking collective read using explicit offset
T}
_
T{
\fI\%Iread_shared\fP(buf)
T}	T{
Nonblocking read using shared file pointer
T}
_
T{
\fI\%Iwrite\fP(buf)
T}	T{
Nonblocking write using individual file pointer
T}
_
T{
\fI\%Iwrite_all\fP(buf)
T}	T{
Nonblocking collective write using individual file pointer
T}
_
T{
\fI\%Iwrite_at\fP(offset, buf)
T}	T{
Nonblocking write using explicit offset
T}
_
T{
\fI\%Iwrite_at_all\fP(offset, buf)
T}	T{
Nonblocking collective write using explicit offset
T}
_
T{
\fI\%Iwrite_shared\fP(buf)
T}	T{
Nonblocking write using shared file pointer
T}
_
T{
\fI\%Open\fP(comm, filename[, amode, info])
T}	T{
Open a file
T}
_
T{
\fI\%Preallocate\fP(size)
T}	T{
Preallocate storage space for a file
T}
_
T{
\fI\%Read\fP(buf[, status])
T}	T{
Read using individual file pointer
T}
_
T{
\fI\%Read_all\fP(buf[, status])
T}	T{
Collective read using individual file pointer
T}
_
T{
\fI\%Read_all_begin\fP(buf)
T}	T{
Start a split collective read using individual file pointer
T}
_
T{
\fI\%Read_all_end\fP(buf[, status])
T}	T{
Complete a split collective read using individual file pointer
T}
_
T{
\fI\%Read_at\fP(offset, buf[, status])
T}	T{
Read using explicit offset
T}
_
T{
\fI\%Read_at_all\fP(offset, buf[, status])
T}	T{
Collective read using explicit offset
T}
_
T{
\fI\%Read_at_all_begin\fP(offset, buf)
T}	T{
Start a split collective read using explict offset
T}
_
T{
\fI\%Read_at_all_end\fP(buf[, status])
T}	T{
Complete a split collective read using explict offset
T}
_
T{
\fI\%Read_ordered\fP(buf[, status])
T}	T{
Collective read using shared file pointer
T}
_
T{
\fI\%Read_ordered_begin\fP(buf)
T}	T{
Start a split collective read using shared file pointer
T}
_
T{
\fI\%Read_ordered_end\fP(buf[, status])
T}	T{
Complete a split collective read using shared file pointer
T}
_
T{
\fI\%Read_shared\fP(buf[, status])
T}	T{
Read using shared file pointer
T}
_
T{
\fI\%Seek\fP(offset[, whence])
T}	T{
Update the individual file pointer
T}
_
T{
\fI\%Seek_shared\fP(offset[, whence])
T}	T{
Update the shared file pointer
T}
_
T{
\fI\%Set_atomicity\fP(flag)
T}	T{
Set the atomicity mode
T}
_
T{
\fI\%Set_errhandler\fP(errhandler)
T}	T{
Set the error handler for a file
T}
_
T{
\fI\%Set_info\fP(info)
T}	T{
Set new values for the hints associated with a file
T}
_
T{
\fI\%Set_size\fP(size)
T}	T{
Sets the file size
T}
_
T{
\fI\%Set_view\fP([disp, etype, filetype, datarep, info])
T}	T{
Set the file view
T}
_
T{
\fI\%Sync\fP()
T}	T{
Causes all previous writes to be transferred to the storage device
T}
_
T{
\fI\%Write\fP(buf[, status])
T}	T{
Write using individual file pointer
T}
_
T{
\fI\%Write_all\fP(buf[, status])
T}	T{
Collective write using individual file pointer
T}
_
T{
\fI\%Write_all_begin\fP(buf)
T}	T{
Start a split collective write using individual file pointer
T}
_
T{
\fI\%Write_all_end\fP(buf[, status])
T}	T{
Complete a split collective write using individual file pointer
T}
_
T{
\fI\%Write_at\fP(offset, buf[, status])
T}	T{
Write using explicit offset
T}
_
T{
\fI\%Write_at_all\fP(offset, buf[, status])
T}	T{
Collective write using explicit offset
T}
_
T{
\fI\%Write_at_all_begin\fP(offset, buf)
T}	T{
Start a split collective write using explict offset
T}
_
T{
\fI\%Write_at_all_end\fP(buf[, status])
T}	T{
Complete a split collective write using explict offset
T}
_
T{
\fI\%Write_ordered\fP(buf[, status])
T}	T{
Collective write using shared file pointer
T}
_
T{
\fI\%Write_ordered_begin\fP(buf)
T}	T{
Start a split collective write using shared file pointer
T}
_
T{
\fI\%Write_ordered_end\fP(buf[, status])
T}	T{
Complete a split collective write using shared file pointer
T}
_
T{
\fI\%Write_shared\fP(buf[, status])
T}	T{
Write using shared file pointer
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%amode\fP
T}	T{
file access mode
T}
_
T{
\fI\%atomicity\fP
T}	T{
T}
_
T{
\fI\%group\fP
T}	T{
file group
T}
_
T{
\fI\%info\fP
T}	T{
file info
T}
_
T{
\fI\%size\fP
T}	T{
file size
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Call_errhandler(errorcode)
Call the error handler installed on a file
.INDENT 7.0
.TP
.B Parameters
\fBerrorcode\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Close()
Close a file
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Delete(filename, info=INFO_NULL)
Delete a file
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfilename\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_amode()
Return the file access mode
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_atomicity()
Return the atomicity mode
.INDENT 7.0
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_byte_offset(offset)
Return the absolute byte position in the file corresponding
to ‘offset’ etypes relative to the current view
.INDENT 7.0
.TP
.B Parameters
\fBoffset\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_errhandler()
Get the error handler for a file
.INDENT 7.0
.TP
.B Return type
Errhandler
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_group()
Return the group of processes
that opened the file
.INDENT 7.0
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_info()
Return the hints for a file that
that are currently in use
.INDENT 7.0
.TP
.B Return type
Info
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_position()
Return the current position of the individual file pointer
in etype units relative to the current view
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_position_shared()
Return the current position of the shared file pointer
in etype units relative to the current view
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_size()
Return the file size
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_type_extent(datatype)
Return the extent of datatype in the file
.INDENT 7.0
.TP
.B Parameters
\fBdatatype\fP (\fIDatatype\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_view()
Return the file view
.INDENT 7.0
.TP
.B Return type
Tuple[\fI\%int\fP, Datatype, Datatype, \fI\%str\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iread(buf)
Nonblocking read using individual file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iread_all(buf)
Nonblocking collective read using individual file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iread_at(offset, buf)
Nonblocking read using explicit offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iread_at_all(offset, buf)
Nonblocking collective read using explicit offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iread_shared(buf)
Nonblocking read using shared file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iwrite(buf)
Nonblocking write using individual file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iwrite_all(buf)
Nonblocking collective write using individual file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iwrite_at(offset, buf)
Nonblocking write using explicit offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iwrite_at_all(offset, buf)
Nonblocking collective write using explicit offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iwrite_shared(buf)
Nonblocking write using shared file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Open(comm, filename, amode=MODE_RDONLY, info=INFO_NULL)
Open a file
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcomm\fP (\fIIntracomm\fP) – 
.IP \(bu 2
\fBfilename\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBamode\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.UNINDENT
.TP
.B Return type
File
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Preallocate(size)
Preallocate storage space for a file
.INDENT 7.0
.TP
.B Parameters
\fBsize\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read(buf, status=None)
Read using individual file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_all(buf, status=None)
Collective read using individual file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_all_begin(buf)
Start a split collective read
using individual file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_all_end(buf, status=None)
Complete a split collective read
using individual file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_at(offset, buf, status=None)
Read using explicit offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_at_all(offset, buf, status=None)
Collective read using explicit offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_at_all_begin(offset, buf)
Start a split collective read using explict offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_at_all_end(buf, status=None)
Complete a split collective read using explict offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_ordered(buf, status=None)
Collective read using shared file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_ordered_begin(buf)
Start a split collective read
using shared file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_ordered_end(buf, status=None)
Complete a split collective read
using shared file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Read_shared(buf, status=None)
Read using shared file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Seek(offset, whence=SEEK_SET)
Update the individual file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBwhence\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Seek_shared(offset, whence=SEEK_SET)
Update the shared file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBwhence\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_atomicity(flag)
Set the atomicity mode
.INDENT 7.0
.TP
.B Parameters
\fBflag\fP (\fI\%bool\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_errhandler(errhandler)
Set the error handler for a file
.INDENT 7.0
.TP
.B Parameters
\fBerrhandler\fP (\fIErrhandler\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_info(info)
Set new values for the hints
associated with a file
.INDENT 7.0
.TP
.B Parameters
\fBinfo\fP (\fIInfo\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_size(size)
Sets the file size
.INDENT 7.0
.TP
.B Parameters
\fBsize\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_view(disp=0, etype=BYTE, filetype=None, datarep=\(aqnative\(aq, info=INFO_NULL)
Set the file view
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdisp\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBetype\fP (\fIDatatype\fP) – 
.IP \(bu 2
\fBfiletype\fP (\fIOptional\fP\fI[\fP\fIDatatype\fP\fI]\fP) – 
.IP \(bu 2
\fBdatarep\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Sync()
Causes all previous writes to be
transferred to the storage device
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write(buf, status=None)
Write using individual file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_all(buf, status=None)
Collective write using individual file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_all_begin(buf)
Start a split collective write
using individual file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_all_end(buf, status=None)
Complete a split collective write
using individual file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_at(offset, buf, status=None)
Write using explicit offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_at_all(offset, buf, status=None)
Collective write using explicit offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_at_all_begin(offset, buf)
Start a split collective write using explict offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBoffset\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_at_all_end(buf, status=None)
Complete a split collective write using explict offset
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_ordered(buf, status=None)
Collective write using shared file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_ordered_begin(buf)
Start a split collective write using
shared file pointer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_ordered_end(buf, status=None)
Complete a split collective write
using shared file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Write_shared(buf, status=None)
Write using shared file pointer
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
File
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B amode
file access mode
.UNINDENT
.INDENT 7.0
.TP
.B atomicity
.UNINDENT
.INDENT 7.0
.TP
.B group
file group
.UNINDENT
.INDENT 7.0
.TP
.B info
file info
.UNINDENT
.INDENT 7.0
.TP
.B size
file size
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Graphcomm
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Graphcomm(comm=None)
Bases: \fBmpi4py.MPI.Topocomm\fP
.sp
General graph topology intracommunicator
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIGraphcomm\fP\fI]\fP) – 
.TP
.B Return type
Graphcomm
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, comm=None)
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIGraphcomm\fP\fI]\fP) – 
.TP
.B Return type
Graphcomm
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Get_dims\fP()
T}	T{
Return the number of nodes and edges
T}
_
T{
\fI\%Get_neighbors\fP(rank)
T}	T{
Return list of neighbors of a process
T}
_
T{
\fI\%Get_neighbors_count\fP(rank)
T}	T{
Return number of neighbors of a process
T}
_
T{
\fI\%Get_topo\fP()
T}	T{
Return index and edges
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%dims\fP
T}	T{
number of nodes and edges
T}
_
T{
\fI\%edges\fP
T}	T{
T}
_
T{
\fI\%index\fP
T}	T{
T}
_
T{
\fI\%nedges\fP
T}	T{
number of edges
T}
_
T{
\fI\%neighbors\fP
T}	T{
T}
_
T{
\fI\%nneighbors\fP
T}	T{
number of neighbors
T}
_
T{
\fI\%nnodes\fP
T}	T{
number of nodes
T}
_
T{
\fI\%topo\fP
T}	T{
topology information
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Get_dims()
Return the number of nodes and edges
.INDENT 7.0
.TP
.B Return type
Tuple[\fI\%int\fP, \fI\%int\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_neighbors(rank)
Return list of neighbors of a process
.INDENT 7.0
.TP
.B Parameters
\fBrank\fP (\fI\%int\fP) – 
.TP
.B Return type
List[\fI\%int\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_neighbors_count(rank)
Return number of neighbors of a process
.INDENT 7.0
.TP
.B Parameters
\fBrank\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_topo()
Return index and edges
.INDENT 7.0
.TP
.B Return type
Tuple[List[\fI\%int\fP], List[\fI\%int\fP]]
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B dims
number of nodes and edges
.UNINDENT
.INDENT 7.0
.TP
.B edges
.UNINDENT
.INDENT 7.0
.TP
.B index
.UNINDENT
.INDENT 7.0
.TP
.B nedges
number of edges
.UNINDENT
.INDENT 7.0
.TP
.B neighbors
.UNINDENT
.INDENT 7.0
.TP
.B nneighbors
number of neighbors
.UNINDENT
.INDENT 7.0
.TP
.B nnodes
number of nodes
.UNINDENT
.INDENT 7.0
.TP
.B topo
topology information
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Grequest
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Grequest(request=None)
Bases: \fBmpi4py.MPI.Request\fP
.sp
Generalized request handle
.INDENT 7.0
.TP
.B Parameters
\fBrequest\fP (\fIOptional\fP\fI[\fP\fIGrequest\fP\fI]\fP) – 
.TP
.B Return type
Grequest
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, request=None)
.INDENT 7.0
.TP
.B Parameters
\fBrequest\fP (\fIOptional\fP\fI[\fP\fIGrequest\fP\fI]\fP) – 
.TP
.B Return type
Grequest
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Complete\fP()
T}	T{
Notify that a user\-defined request is complete
T}
_
T{
\fI\%Start\fP(query_fn, free_fn, cancel_fn[, args, ...])
T}	T{
Create and return a user\-defined request
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Complete()
Notify that a user\-defined request is complete
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Start(query_fn, free_fn, cancel_fn, args=None, kargs=None)
Create and return a user\-defined request
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBquery_fn\fP (\fICallable\fP\fI[\fP\fI\&...\fP\fI, \fP\fI\%None\fP\fI]\fP) – 
.IP \(bu 2
\fBfree_fn\fP (\fICallable\fP\fI[\fP\fI\&...\fP\fI, \fP\fI\%None\fP\fI]\fP) – 
.IP \(bu 2
\fBcancel_fn\fP (\fICallable\fP\fI[\fP\fI\&...\fP\fI, \fP\fI\%None\fP\fI]\fP) – 
.IP \(bu 2
\fBargs\fP (\fIOptional\fP\fI[\fP\fITuple\fP\fI[\fP\fIAny\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBkargs\fP (\fIOptional\fP\fI[\fP\fIDict\fP\fI[\fP\fI\%str\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Grequest
.UNINDENT
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Group
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Group(group=None)
Bases: \fI\%object\fP
.sp
Group of processes
.INDENT 7.0
.TP
.B Parameters
\fBgroup\fP (\fIOptional\fP\fI[\fP\fIGroup\fP\fI]\fP) – 
.TP
.B Return type
Group
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, group=None)
.INDENT 7.0
.TP
.B Parameters
\fBgroup\fP (\fIOptional\fP\fI[\fP\fIGroup\fP\fI]\fP) – 
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Compare\fP(group1, group2)
T}	T{
Compare two groups
T}
_
T{
\fI\%Difference\fP(group1, group2)
T}	T{
Produce a group from the difference of two existing groups
T}
_
T{
\fI\%Dup\fP()
T}	T{
Duplicate a group
T}
_
T{
\fI\%Excl\fP(ranks)
T}	T{
Produce a group by reordering an existing group and taking only unlisted members
T}
_
T{
\fI\%Free\fP()
T}	T{
Free a group
T}
_
T{
\fI\%Get_rank\fP()
T}	T{
Return the rank of this process in a group
T}
_
T{
\fI\%Get_size\fP()
T}	T{
Return the size of a group
T}
_
T{
\fI\%Incl\fP(ranks)
T}	T{
Produce a group by reordering an existing group and taking only listed members
T}
_
T{
\fI\%Intersection\fP(group1, group2)
T}	T{
Produce a group as the intersection of two existing groups
T}
_
T{
\fI\%Range_excl\fP(ranks)
T}	T{
Create a new group by excluding ranges of processes from an existing group
T}
_
T{
\fI\%Range_incl\fP(ranks)
T}	T{
Create a new group from ranges of of ranks in an existing group
T}
_
T{
\fI\%Translate_ranks\fP(group1, ranks1[, group2])
T}	T{
Translate the ranks of processes in one group to those in another group
T}
_
T{
\fI\%Union\fP(group1, group2)
T}	T{
Produce a group by combining two existing groups
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%rank\fP
T}	T{
rank of this process in group
T}
_
T{
\fI\%size\fP
T}	T{
number of processes in group
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B classmethod  Compare(group1, group2)
Compare two groups
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgroup1\fP (\fIGroup\fP) – 
.IP \(bu 2
\fBgroup2\fP (\fIGroup\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Difference(group1, group2)
Produce a group from the difference
of two existing groups
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgroup1\fP (\fIGroup\fP) – 
.IP \(bu 2
\fBgroup2\fP (\fIGroup\fP) – 
.UNINDENT
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Dup()
Duplicate a group
.INDENT 7.0
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Excl(ranks)
Produce a group by reordering an existing
group and taking only unlisted members
.INDENT 7.0
.TP
.B Parameters
\fBranks\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Free()
Free a group
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_rank()
Return the rank of this process in a group
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_size()
Return the size of a group
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Incl(ranks)
Produce a group by reordering an existing
group and taking only listed members
.INDENT 7.0
.TP
.B Parameters
\fBranks\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Intersection(group1, group2)
Produce a group as the intersection
of two existing groups
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgroup1\fP (\fIGroup\fP) – 
.IP \(bu 2
\fBgroup2\fP (\fIGroup\fP) – 
.UNINDENT
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Range_excl(ranks)
Create a new group by excluding ranges
of processes from an existing group
.INDENT 7.0
.TP
.B Parameters
\fBranks\fP (\fISequence\fP\fI[\fP\fITuple\fP\fI[\fP\fI\%int\fP\fI, \fP\fI\%int\fP\fI, \fP\fI\%int\fP\fI]\fP\fI]\fP) – 
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Range_incl(ranks)
Create a new group from ranges of
of ranks in an existing group
.INDENT 7.0
.TP
.B Parameters
\fBranks\fP (\fISequence\fP\fI[\fP\fITuple\fP\fI[\fP\fI\%int\fP\fI, \fP\fI\%int\fP\fI, \fP\fI\%int\fP\fI]\fP\fI]\fP) – 
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Translate_ranks(group1, ranks1, group2=None)
Translate the ranks of processes in
one group to those in another group
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgroup1\fP (\fIGroup\fP) – 
.IP \(bu 2
\fBranks1\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBgroup2\fP (\fIOptional\fP\fI[\fP\fIGroup\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
List[\fI\%int\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Union(group1, group2)
Produce a group by combining
two existing groups
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgroup1\fP (\fIGroup\fP) – 
.IP \(bu 2
\fBgroup2\fP (\fIGroup\fP) – 
.UNINDENT
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B rank
rank of this process in group
.UNINDENT
.INDENT 7.0
.TP
.B size
number of processes in group
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Info
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Info(info=None)
Bases: \fI\%object\fP
.sp
Info object
.INDENT 7.0
.TP
.B Parameters
\fBinfo\fP (\fIOptional\fP\fI[\fP\fIInfo\fP\fI]\fP) – 
.TP
.B Return type
Info
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, info=None)
.INDENT 7.0
.TP
.B Parameters
\fBinfo\fP (\fIOptional\fP\fI[\fP\fIInfo\fP\fI]\fP) – 
.TP
.B Return type
Info
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Create\fP()
T}	T{
Create a new, empty info object
T}
_
T{
\fI\%Delete\fP(key)
T}	T{
Remove a (key, value) pair from info
T}
_
T{
\fI\%Dup\fP()
T}	T{
Duplicate an existing info object, creating a new object, with the same (key, value) pairs and the same ordering of keys
T}
_
T{
\fI\%Free\fP()
T}	T{
Free a info object
T}
_
T{
\fI\%Get\fP(key[, maxlen])
T}	T{
Retrieve the value associated with a key
T}
_
T{
\fI\%Get_nkeys\fP()
T}	T{
Return the number of currently defined keys in info
T}
_
T{
\fI\%Get_nthkey\fP(n)
T}	T{
Return the nth defined key in info.
T}
_
T{
\fI\%Set\fP(key, value)
T}	T{
Add the (key, value) pair to info, and overrides the value if a value for the same key was previously set
T}
_
T{
\fI\%clear\fP()
T}	T{
info clear
T}
_
T{
\fI\%copy\fP()
T}	T{
info copy
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%get\fP(key[, default])
T}	T{
info get
T}
_
T{
\fI\%items\fP()
T}	T{
info items
T}
_
T{
\fI\%keys\fP()
T}	T{
info keys
T}
_
T{
\fI\%pop\fP(key, *default)
T}	T{
info pop
T}
_
T{
\fI\%popitem\fP()
T}	T{
info popitem
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
T{
\fI\%update\fP([other])
T}	T{
info update
T}
_
T{
\fI\%values\fP()
T}	T{
info values
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B classmethod  Create()
Create a new, empty info object
.INDENT 7.0
.TP
.B Return type
Info
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Delete(key)
Remove a (key, value) pair from info
.INDENT 7.0
.TP
.B Parameters
\fBkey\fP (\fI\%str\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Dup()
Duplicate an existing info object, creating a new object, with
the same (key, value) pairs and the same ordering of keys
.INDENT 7.0
.TP
.B Return type
Info
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Free()
Free a info object
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get(key, maxlen=\- 1)
Retrieve the value associated with a key
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBkey\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBmaxlen\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Optional[\fI\%str\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_nkeys()
Return the number of currently defined keys in info
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_nthkey(n)
Return the nth defined key in info. Keys are numbered in the
range [0, N) where N is the value returned by
\fI\%Info.Get_nkeys()\fP
.INDENT 7.0
.TP
.B Parameters
\fBn\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set(key, value)
Add the (key, value) pair to info, and overrides the value if
a value for the same key was previously set
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBkey\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBvalue\fP (\fI\%str\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B clear()
info clear
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B copy()
info copy
.INDENT 7.0
.TP
.B Return type
Info
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
Info
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get(key, default=None)
info get
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBkey\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBdefault\fP (\fIOptional\fP\fI[\fP\fI\%str\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Optional[\fI\%str\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B items()
info items
.INDENT 7.0
.TP
.B Return type
List[Tuple[\fI\%str\fP, \fI\%str\fP]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B keys()
info keys
.INDENT 7.0
.TP
.B Return type
List[\fI\%str\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B pop(key, *default)
info pop
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBkey\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBdefault\fP (\fI\%str\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B popitem()
info popitem
.INDENT 7.0
.TP
.B Return type
Tuple[\fI\%str\fP, \fI\%str\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B update(other=(), **kwds)
info update
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBother\fP (\fIUnion\fP\fI[\fP\fIInfo\fP\fI, \fP\fIMapping\fP\fI[\fP\fI\%str\fP\fI, \fP\fI\%str\fP\fI]\fP\fI, \fP\fIIterable\fP\fI[\fP\fITuple\fP\fI[\fP\fI\%str\fP\fI, \fP\fI\%str\fP\fI]\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBkwds\fP (\fI\%str\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B values()
info values
.INDENT 7.0
.TP
.B Return type
List[\fI\%str\fP]
.UNINDENT
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Intercomm
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Intercomm(comm=None)
Bases: \fBmpi4py.MPI.Comm\fP
.sp
Intercommunicator
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIIntercomm\fP\fI]\fP) – 
.TP
.B Return type
Intercomm
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, comm=None)
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIIntercomm\fP\fI]\fP) – 
.TP
.B Return type
Intercomm
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Get_remote_group\fP()
T}	T{
Access the remote group associated with the inter\-communicator
T}
_
T{
\fI\%Get_remote_size\fP()
T}	T{
Intercommunicator remote size
T}
_
T{
\fI\%Merge\fP([high])
T}	T{
Merge intercommunicator
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%remote_group\fP
T}	T{
remote group
T}
_
T{
\fI\%remote_size\fP
T}	T{
number of remote processes
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Get_remote_group()
Access the remote group associated
with the inter\-communicator
.INDENT 7.0
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_remote_size()
Intercommunicator remote size
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Merge(high=False)
Merge intercommunicator
.INDENT 7.0
.TP
.B Parameters
\fBhigh\fP (\fI\%bool\fP) – 
.TP
.B Return type
Intracomm
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B remote_group
remote group
.UNINDENT
.INDENT 7.0
.TP
.B remote_size
number of remote processes
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Intracomm
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Intracomm(comm=None)
Bases: \fBmpi4py.MPI.Comm\fP
.sp
Intracommunicator
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIIntracomm\fP\fI]\fP) – 
.TP
.B Return type
Intracomm
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, comm=None)
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fIIntracomm\fP\fI]\fP) – 
.TP
.B Return type
Intracomm
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Accept\fP(port_name[, info, root])
T}	T{
Accept a request to form a new intercommunicator
T}
_
T{
\fI\%Cart_map\fP(dims[, periods])
T}	T{
Return an optimal placement for the calling process on the physical machine
T}
_
T{
\fI\%Connect\fP(port_name[, info, root])
T}	T{
Make a request to form a new intercommunicator
T}
_
T{
\fI\%Create_cart\fP(dims[, periods, reorder])
T}	T{
Create cartesian communicator
T}
_
T{
\fI\%Create_dist_graph\fP(sources, degrees, destinations)
T}	T{
Create distributed graph communicator
T}
_
T{
\fI\%Create_dist_graph_adjacent\fP(sources, destinations)
T}	T{
Create distributed graph communicator
T}
_
T{
\fI\%Create_graph\fP(index, edges[, reorder])
T}	T{
Create graph communicator
T}
_
T{
\fI\%Create_intercomm\fP(local_leader, peer_comm, ...)
T}	T{
Create intercommunicator
T}
_
T{
\fI\%Exscan\fP(sendbuf, recvbuf[, op])
T}	T{
Exclusive Scan
T}
_
T{
\fI\%Graph_map\fP(index, edges)
T}	T{
Return an optimal placement for the calling process on the physical machine
T}
_
T{
\fI\%Iexscan\fP(sendbuf, recvbuf[, op])
T}	T{
Inclusive Scan
T}
_
T{
\fI\%Iscan\fP(sendbuf, recvbuf[, op])
T}	T{
Inclusive Scan
T}
_
T{
\fI\%Scan\fP(sendbuf, recvbuf[, op])
T}	T{
Inclusive Scan
T}
_
T{
\fI\%Spawn\fP(command[, args, maxprocs, info, root, ...])
T}	T{
Spawn instances of a single MPI application
T}
_
T{
\fI\%Spawn_multiple\fP(command[, args, maxprocs, ...])
T}	T{
Spawn instances of multiple MPI applications
T}
_
T{
\fI\%exscan\fP(sendobj[, op])
T}	T{
Exclusive Scan
T}
_
T{
\fI\%scan\fP(sendobj[, op])
T}	T{
Inclusive Scan
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Accept(port_name, info=INFO_NULL, root=0)
Accept a request to form a new intercommunicator
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBport_name\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Intercomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Cart_map(dims, periods=None)
Return an optimal placement for the
calling process on the physical machine
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdims\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBperiods\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%bool\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Connect(port_name, info=INFO_NULL, root=0)
Make a request to form a new intercommunicator
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBport_name\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Intercomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_cart(dims, periods=None, reorder=False)
Create cartesian communicator
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdims\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBperiods\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%bool\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBreorder\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
Cartcomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_dist_graph(sources, degrees, destinations, weights=None, info=INFO_NULL, reorder=False)
Create distributed graph communicator
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsources\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBdegrees\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBdestinations\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBweights\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.IP \(bu 2
\fBreorder\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
Distgraphcomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_dist_graph_adjacent(sources, destinations, sourceweights=None, destweights=None, info=INFO_NULL, reorder=False)
Create distributed graph communicator
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsources\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBdestinations\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBsourceweights\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBdestweights\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.IP \(bu 2
\fBreorder\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
Distgraphcomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_graph(index, edges, reorder=False)
Create graph communicator
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBindex\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBedges\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBreorder\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
Graphcomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Create_intercomm(local_leader, peer_comm, remote_leader, tag=0)
Create intercommunicator
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBlocal_leader\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBpeer_comm\fP (\fIIntracomm\fP) – 
.IP \(bu 2
\fBremote_leader\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
Intercomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Exscan(sendbuf, recvbuf, op=SUM)
Exclusive Scan
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Graph_map(index, edges)
Return an optimal placement for the
calling process on the physical machine
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBindex\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.IP \(bu 2
\fBedges\fP (\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iexscan(sendbuf, recvbuf, op=SUM)
Inclusive Scan
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Iscan(sendbuf, recvbuf, op=SUM)
Inclusive Scan
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Scan(sendbuf, recvbuf, op=SUM)
Inclusive Scan
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIUnion\fP\fI[\fP\fIBufSpec\fP\fI, \fP\fIInPlace\fP\fI]\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Spawn(command, args=None, maxprocs=1, info=INFO_NULL, root=0, errcodes=None)
Spawn instances of a single MPI application
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcommand\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBargs\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%str\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBmaxprocs\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBerrcodes\fP (\fIOptional\fP\fI[\fP\fI\%list\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Intercomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Spawn_multiple(command, args=None, maxprocs=None, info=INFO_NULL, root=0, errcodes=None)
Spawn instances of multiple MPI applications
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcommand\fP (\fISequence\fP\fI[\fP\fI\%str\fP\fI]\fP) – 
.IP \(bu 2
\fBargs\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%str\fP\fI]\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBmaxprocs\fP (\fIOptional\fP\fI[\fP\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIUnion\fP\fI[\fP\fIInfo\fP\fI, \fP\fISequence\fP\fI[\fP\fIInfo\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBroot\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBerrcodes\fP (\fIOptional\fP\fI[\fP\fI\%list\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Intercomm
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B exscan(sendobj, op=SUM)
Exclusive Scan
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBop\fP (\fIUnion\fP\fI[\fP\fIOp\fP\fI, \fP\fICallable\fP\fI[\fP\fI[\fP\fIAny\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B scan(sendobj, op=SUM)
Inclusive Scan
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBop\fP (\fIUnion\fP\fI[\fP\fIOp\fP\fI, \fP\fICallable\fP\fI[\fP\fI[\fP\fIAny\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Message
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Message(message=None)
Bases: \fI\%object\fP
.sp
Matched message handle
.INDENT 7.0
.TP
.B Parameters
\fBmessage\fP (\fIOptional\fP\fI[\fP\fIMessage\fP\fI]\fP) – 
.TP
.B Return type
Message
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, message=None)
.INDENT 7.0
.TP
.B Parameters
\fBmessage\fP (\fIOptional\fP\fI[\fP\fIMessage\fP\fI]\fP) – 
.TP
.B Return type
Message
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Iprobe\fP(comm[, source, tag, status])
T}	T{
Nonblocking test for a matched message
T}
_
T{
\fI\%Irecv\fP(buf)
T}	T{
Nonblocking receive of matched message
T}
_
T{
\fI\%Probe\fP(comm[, source, tag, status])
T}	T{
Blocking test for a matched message
T}
_
T{
\fI\%Recv\fP(buf[, status])
T}	T{
Blocking receive of matched message
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%iprobe\fP(comm[, source, tag, status])
T}	T{
Nonblocking test for a matched message
T}
_
T{
\fI\%irecv\fP()
T}	T{
Nonblocking receive of matched message
T}
_
T{
\fI\%probe\fP(comm[, source, tag, status])
T}	T{
Blocking test for a matched message
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
T{
\fI\%recv\fP([status])
T}	T{
Blocking receive of matched message
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B classmethod  Iprobe(comm, source=ANY_SOURCE, tag=ANY_TAG, status=None)
Nonblocking test for a matched message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcomm\fP (\fIComm\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Optional[Message]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Irecv(buf)
Nonblocking receive of matched message
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBufSpec\fP) – 
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Probe(comm, source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking test for a matched message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcomm\fP (\fIComm\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Message
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Recv(buf, status=None)
Blocking receive of matched message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
Message
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  iprobe(comm, source=ANY_SOURCE, tag=ANY_TAG, status=None)
Nonblocking test for a matched message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcomm\fP (\fIComm\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Optional[Message]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B irecv()
Nonblocking receive of matched message
.INDENT 7.0
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  probe(comm, source=ANY_SOURCE, tag=ANY_TAG, status=None)
Blocking test for a matched message
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcomm\fP (\fIComm\fP) – 
.IP \(bu 2
\fBsource\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtag\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Message
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B recv(status=None)
Blocking receive of matched message
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Op
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Op(op=None)
Bases: \fI\%object\fP
.sp
Operation object
.INDENT 7.0
.TP
.B Parameters
\fBop\fP (\fIOptional\fP\fI[\fP\fIOp\fP\fI]\fP) – 
.TP
.B Return type
Op
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, op=None)
.INDENT 7.0
.TP
.B Parameters
\fBop\fP (\fIOptional\fP\fI[\fP\fIOp\fP\fI]\fP) – 
.TP
.B Return type
Op
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Create\fP(function[, commute])
T}	T{
Create a user\-defined operation
T}
_
T{
\fI\%Free\fP()
T}	T{
Free the operation
T}
_
T{
\fI\%Is_commutative\fP()
T}	T{
Query reduction operations for their commutativity
T}
_
T{
\fI\%Reduce_local\fP(inbuf, inoutbuf)
T}	T{
Apply a reduction operator to local data
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%is_commutative\fP
T}	T{
is commutative
T}
_
T{
\fI\%is_predefined\fP
T}	T{
is a predefined operation
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B classmethod  Create(function, commute=False)
Create a user\-defined operation
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfunction\fP (\fICallable\fP\fI[\fP\fI[\fP\fIBuffer\fP\fI, \fP\fIBuffer\fP\fI, \fP\fIDatatype\fP\fI]\fP\fI, \fP\fI\%None\fP\fI]\fP) – 
.IP \(bu 2
\fBcommute\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
Op
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Free()
Free the operation
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Is_commutative()
Query reduction operations for their commutativity
.INDENT 7.0
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Reduce_local(inbuf, inoutbuf)
Apply a reduction operator to local data
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBinbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBinoutbuf\fP (\fIBufSpec\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
Op
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B is_commutative
is commutative
.UNINDENT
.INDENT 7.0
.TP
.B is_predefined
is a predefined operation
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Pickle
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Pickle(dumps=None, loads=None, protocol=None)
Bases: \fI\%object\fP
.sp
Pickle/unpickle Python objects
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdumps\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIAny\fP\fI, \fP\fI\%int\fP\fI]\fP\fI, \fP\fI\%bytes\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBloads\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIBuffer\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBprotocol\fP (\fIOptional\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.INDENT 7.0
.TP
.B __init__(dumps=None, loads=None, protocol=None)
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdumps\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIAny\fP\fI, \fP\fI\%int\fP\fI]\fP\fI, \fP\fI\%bytes\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBloads\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIBuffer\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBprotocol\fP (\fIOptional\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%dumps\fP(obj[, buffer_callback])
T}	T{
Serialize object to pickle data stream.
T}
_
T{
\fI\%loads\fP(data[, buffers])
T}	T{
Deserialize object from pickle data stream.
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%PROTOCOL\fP
T}	T{
pickle protocol
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B dumps(obj, buffer_callback=None)
Serialize object to pickle data stream.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIAny\fP) – 
.IP \(bu 2
\fBbuffer_callback\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIBuffer\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%bytes\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B loads(data, buffers=None)
Deserialize object from pickle data stream.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdata\fP (\fIBuffer\fP) – 
.IP \(bu 2
\fBbuffers\fP (\fIOptional\fP\fI[\fP\fIIterable\fP\fI[\fP\fIBuffer\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B PROTOCOL
pickle protocol
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Prequest
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Prequest(request=None)
Bases: \fBmpi4py.MPI.Request\fP
.sp
Persistent request handle
.INDENT 7.0
.TP
.B Parameters
\fBrequest\fP (\fIOptional\fP\fI[\fP\fIPrequest\fP\fI]\fP) – 
.TP
.B Return type
Prequest
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, request=None)
.INDENT 7.0
.TP
.B Parameters
\fBrequest\fP (\fIOptional\fP\fI[\fP\fIPrequest\fP\fI]\fP) – 
.TP
.B Return type
Prequest
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Start\fP()
T}	T{
Initiate a communication with a persistent request
T}
_
T{
\fI\%Startall\fP(requests)
T}	T{
Start a collection of persistent requests
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Start()
Initiate a communication with a persistent request
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Startall(requests)
Start a collection of persistent requests
.INDENT 7.0
.TP
.B Parameters
\fBrequests\fP (\fIList\fP\fI[\fP\fIPrequest\fP\fI]\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Request
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Request(request=None)
Bases: \fI\%object\fP
.sp
Request handle
.INDENT 7.0
.TP
.B Parameters
\fBrequest\fP (\fIOptional\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.TP
.B Return type
Request
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, request=None)
.INDENT 7.0
.TP
.B Parameters
\fBrequest\fP (\fIOptional\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Cancel\fP()
T}	T{
Cancel a communication request
T}
_
T{
\fI\%Free\fP()
T}	T{
Free a communication request
T}
_
T{
\fI\%Get_status\fP([status])
T}	T{
Non\-destructive test for the completion of a request
T}
_
T{
\fI\%Test\fP([status])
T}	T{
Test for the completion of a send or receive
T}
_
T{
\fI\%Testall\fP(requests[, statuses])
T}	T{
Test for completion of all previously initiated requests
T}
_
T{
\fI\%Testany\fP(requests[, status])
T}	T{
Test for completion of any previously initiated request
T}
_
T{
\fI\%Testsome\fP(requests[, statuses])
T}	T{
Test for completion of some previously initiated requests
T}
_
T{
\fI\%Wait\fP([status])
T}	T{
Wait for a send or receive to complete
T}
_
T{
\fI\%Waitall\fP(requests[, statuses])
T}	T{
Wait for all previously initiated requests to complete
T}
_
T{
\fI\%Waitany\fP(requests[, status])
T}	T{
Wait for any previously initiated request to complete
T}
_
T{
\fI\%Waitsome\fP(requests[, statuses])
T}	T{
Wait for some previously initiated requests to complete
T}
_
T{
\fI\%cancel\fP()
T}	T{
Cancel a communication request
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%get_status\fP([status])
T}	T{
Non\-destructive test for the completion of a request
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
T{
\fI\%test\fP([status])
T}	T{
Test for the completion of a send or receive
T}
_
T{
\fI\%testall\fP(requests[, statuses])
T}	T{
Test for completion of all previously initiated requests
T}
_
T{
\fI\%testany\fP(requests[, status])
T}	T{
Test for completion of any previously initiated request
T}
_
T{
\fI\%testsome\fP(requests[, statuses])
T}	T{
Test for completion of some previously initiated requests
T}
_
T{
\fI\%wait\fP([status])
T}	T{
Wait for a send or receive to complete
T}
_
T{
\fI\%waitall\fP(requests[, statuses])
T}	T{
Wait for all previously initiated requests to complete
T}
_
T{
\fI\%waitany\fP(requests[, status])
T}	T{
Wait for any previously initiated request to complete
T}
_
T{
\fI\%waitsome\fP(requests[, statuses])
T}	T{
Wait for some previously initiated requests to complete
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Cancel()
Cancel a communication request
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Free()
Free a communication request
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_status(status=None)
Non\-destructive test for the completion of a request
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Test(status=None)
Test for the completion of a send or receive
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Testall(requests, statuses=None)
Test for completion of all previously initiated requests
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatuses\fP (\fIOptional\fP\fI[\fP\fIList\fP\fI[\fP\fIStatus\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Testany(requests, status=None)
Test for completion of any previously initiated request
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Tuple[\fI\%int\fP, \fI\%bool\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Testsome(requests, statuses=None)
Test for completion of some previously initiated requests
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatuses\fP (\fIOptional\fP\fI[\fP\fIList\fP\fI[\fP\fIStatus\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Optional[List[\fI\%int\fP]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Wait(status=None)
Wait for a send or receive to complete
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
Literal[True]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Waitall(requests, statuses=None)
Wait for all previously initiated requests to complete
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatuses\fP (\fIOptional\fP\fI[\fP\fIList\fP\fI[\fP\fIStatus\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Literal[True]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Waitany(requests, status=None)
Wait for any previously initiated request to complete
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Waitsome(requests, statuses=None)
Wait for some previously initiated requests to complete
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatuses\fP (\fIOptional\fP\fI[\fP\fIList\fP\fI[\fP\fIStatus\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Optional[List[\fI\%int\fP]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B cancel()
Cancel a communication request
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_status(status=None)
Non\-destructive test for the completion of a request
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B test(status=None)
Test for the completion of a send or receive
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
Tuple[\fI\%bool\fP, Optional[Any]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  testall(requests, statuses=None)
Test for completion of all previously initiated requests
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatuses\fP (\fIOptional\fP\fI[\fP\fIList\fP\fI[\fP\fIStatus\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Tuple[\fI\%bool\fP, Optional[List[Any]]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  testany(requests, status=None)
Test for completion of any previously initiated request
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Tuple[\fI\%int\fP, \fI\%bool\fP, Optional[Any]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  testsome(requests, statuses=None)
Test for completion of some previously initiated requests
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatuses\fP (\fIOptional\fP\fI[\fP\fIList\fP\fI[\fP\fIStatus\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Tuple[Optional[List[\fI\%int\fP]], Optional[List[Any]]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B wait(status=None)
Wait for a send or receive to complete
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  waitall(requests, statuses=None)
Wait for all previously initiated requests to complete
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatuses\fP (\fIOptional\fP\fI[\fP\fIList\fP\fI[\fP\fIStatus\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
List[Any]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  waitany(requests, status=None)
Wait for any previously initiated request to complete
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Tuple[\fI\%int\fP, Any]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  waitsome(requests, statuses=None)
Wait for some previously initiated requests to complete
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrequests\fP (\fISequence\fP\fI[\fP\fIRequest\fP\fI]\fP) – 
.IP \(bu 2
\fBstatuses\fP (\fIOptional\fP\fI[\fP\fIList\fP\fI[\fP\fIStatus\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Tuple[Optional[List[\fI\%int\fP]], Optional[List[Any]]]
.UNINDENT
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Status
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Status(status=None)
Bases: \fI\%object\fP
.sp
Status object
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
Status
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, status=None)
.INDENT 7.0
.TP
.B Parameters
\fBstatus\fP (\fIOptional\fP\fI[\fP\fIStatus\fP\fI]\fP) – 
.TP
.B Return type
Status
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Get_count\fP([datatype])
T}	T{
Get the number of \fItop level\fP elements
T}
_
T{
\fI\%Get_elements\fP(datatype)
T}	T{
Get the number of basic elements in a datatype
T}
_
T{
\fI\%Get_error\fP()
T}	T{
Get message error
T}
_
T{
\fI\%Get_source\fP()
T}	T{
Get message source
T}
_
T{
\fI\%Get_tag\fP()
T}	T{
Get message tag
T}
_
T{
\fI\%Is_cancelled\fP()
T}	T{
Test to see if a request was cancelled
T}
_
T{
\fI\%Set_cancelled\fP(flag)
T}	T{
Set the cancelled state associated with a status
T}
_
T{
\fI\%Set_elements\fP(datatype, count)
T}	T{
Set the number of elements in a status
T}
_
T{
\fI\%Set_error\fP(error)
T}	T{
Set message error
T}
_
T{
\fI\%Set_source\fP(source)
T}	T{
Set message source
T}
_
T{
\fI\%Set_tag\fP(tag)
T}	T{
Set message tag
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%cancelled\fP
T}	T{
cancelled state
T}
_
T{
\fI\%count\fP
T}	T{
byte count
T}
_
T{
\fI\%error\fP
T}	T{
T}
_
T{
\fI\%source\fP
T}	T{
T}
_
T{
\fI\%tag\fP
T}	T{
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Get_count(datatype=BYTE)
Get the number of \fItop level\fP elements
.INDENT 7.0
.TP
.B Parameters
\fBdatatype\fP (\fIDatatype\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_elements(datatype)
Get the number of basic elements in a datatype
.INDENT 7.0
.TP
.B Parameters
\fBdatatype\fP (\fIDatatype\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_error()
Get message error
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_source()
Get message source
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_tag()
Get message tag
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Is_cancelled()
Test to see if a request was cancelled
.INDENT 7.0
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_cancelled(flag)
Set the cancelled state associated with a status
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This should be only used when implementing
query callback functions for generalized requests
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
\fBflag\fP (\fI\%bool\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_elements(datatype, count)
Set the number of elements in a status
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
This should be only used when implementing
query callback functions for generalized requests
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatatype\fP (\fIDatatype\fP) – 
.IP \(bu 2
\fBcount\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_error(error)
Set message error
.INDENT 7.0
.TP
.B Parameters
\fBerror\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_source(source)
Set message source
.INDENT 7.0
.TP
.B Parameters
\fBsource\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_tag(tag)
Set message tag
.INDENT 7.0
.TP
.B Parameters
\fBtag\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fIList\fP\fI[\fP\fI\%int\fP\fI]\fP) – 
.TP
.B Return type
Status
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
List[\fI\%int\fP]
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B cancelled
cancelled state
.UNINDENT
.INDENT 7.0
.TP
.B count
byte count
.UNINDENT
.INDENT 7.0
.TP
.B error
.UNINDENT
.INDENT 7.0
.TP
.B source
.UNINDENT
.INDENT 7.0
.TP
.B tag
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Topocomm
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Topocomm(comm=None)
Bases: \fBmpi4py.MPI.Intracomm\fP
.sp
Topology intracommunicator
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fITopocomm\fP\fI]\fP) – 
.TP
.B Return type
Topocomm
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, comm=None)
.INDENT 7.0
.TP
.B Parameters
\fBcomm\fP (\fIOptional\fP\fI[\fP\fITopocomm\fP\fI]\fP) – 
.TP
.B Return type
Topocomm
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Ineighbor_allgather\fP(sendbuf, recvbuf)
T}	T{
Nonblocking Neighbor Gather to All
T}
_
T{
\fI\%Ineighbor_allgatherv\fP(sendbuf, recvbuf)
T}	T{
Nonblocking Neighbor Gather to All Vector
T}
_
T{
\fI\%Ineighbor_alltoall\fP(sendbuf, recvbuf)
T}	T{
Nonblocking Neighbor All\-to\-All
T}
_
T{
\fI\%Ineighbor_alltoallv\fP(sendbuf, recvbuf)
T}	T{
Nonblocking Neighbor All\-to\-All Vector
T}
_
T{
\fI\%Ineighbor_alltoallw\fP(sendbuf, recvbuf)
T}	T{
Nonblocking Neighbor All\-to\-All Generalized
T}
_
T{
\fI\%Neighbor_allgather\fP(sendbuf, recvbuf)
T}	T{
Neighbor Gather to All
T}
_
T{
\fI\%Neighbor_allgatherv\fP(sendbuf, recvbuf)
T}	T{
Neighbor Gather to All Vector
T}
_
T{
\fI\%Neighbor_alltoall\fP(sendbuf, recvbuf)
T}	T{
Neighbor All\-to\-All
T}
_
T{
\fI\%Neighbor_alltoallv\fP(sendbuf, recvbuf)
T}	T{
Neighbor All\-to\-All Vector
T}
_
T{
\fI\%Neighbor_alltoallw\fP(sendbuf, recvbuf)
T}	T{
Neighbor All\-to\-All Generalized
T}
_
T{
\fI\%neighbor_allgather\fP(sendobj)
T}	T{
Neighbor Gather to All
T}
_
T{
\fI\%neighbor_alltoall\fP(sendobj)
T}	T{
Neighbor All to All Scatter/Gather
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%degrees\fP
T}	T{
number of incoming and outgoing neighbors
T}
_
T{
\fI\%indegree\fP
T}	T{
number of incoming neighbors
T}
_
T{
\fI\%inedges\fP
T}	T{
incoming neighbors
T}
_
T{
\fI\%inoutedges\fP
T}	T{
incoming and outgoing neighbors
T}
_
T{
\fI\%outdegree\fP
T}	T{
number of outgoing neighbors
T}
_
T{
\fI\%outedges\fP
T}	T{
outgoing neighbors
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Ineighbor_allgather(sendbuf, recvbuf)
Nonblocking Neighbor Gather to All
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecB\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ineighbor_allgatherv(sendbuf, recvbuf)
Nonblocking Neighbor Gather to All Vector
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecV\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ineighbor_alltoall(sendbuf, recvbuf)
Nonblocking Neighbor All\-to\-All
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpecB\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecB\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ineighbor_alltoallv(sendbuf, recvbuf)
Nonblocking Neighbor All\-to\-All Vector
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpecV\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecV\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Ineighbor_alltoallw(sendbuf, recvbuf)
Nonblocking Neighbor All\-to\-All Generalized
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpecW\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecW\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Neighbor_allgather(sendbuf, recvbuf)
Neighbor Gather to All
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecB\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Neighbor_allgatherv(sendbuf, recvbuf)
Neighbor Gather to All Vector
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecV\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Neighbor_alltoall(sendbuf, recvbuf)
Neighbor All\-to\-All
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpecB\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecB\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Neighbor_alltoallv(sendbuf, recvbuf)
Neighbor All\-to\-All Vector
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpecV\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecV\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Neighbor_alltoallw(sendbuf, recvbuf)
Neighbor All\-to\-All Generalized
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsendbuf\fP (\fIBufSpecW\fP) – 
.IP \(bu 2
\fBrecvbuf\fP (\fIBufSpecW\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B neighbor_allgather(sendobj)
Neighbor Gather to All
.INDENT 7.0
.TP
.B Parameters
\fBsendobj\fP (\fIAny\fP) – 
.TP
.B Return type
List[Any]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B neighbor_alltoall(sendobj)
Neighbor All to All Scatter/Gather
.INDENT 7.0
.TP
.B Parameters
\fBsendobj\fP (\fIList\fP\fI[\fP\fIAny\fP\fI]\fP) – 
.TP
.B Return type
List[Any]
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B degrees
number of incoming and outgoing neighbors
.UNINDENT
.INDENT 7.0
.TP
.B indegree
number of incoming neighbors
.UNINDENT
.INDENT 7.0
.TP
.B inedges
incoming neighbors
.UNINDENT
.INDENT 7.0
.TP
.B inoutedges
incoming and outgoing neighbors
.UNINDENT
.INDENT 7.0
.TP
.B outdegree
number of outgoing neighbors
.UNINDENT
.INDENT 7.0
.TP
.B outedges
outgoing neighbors
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Win
.INDENT 0.0
.TP
.B class  mpi4py.MPI.Win(win=None)
Bases: \fI\%object\fP
.sp
Window handle
.INDENT 7.0
.TP
.B Parameters
\fBwin\fP (\fIOptional\fP\fI[\fP\fIWin\fP\fI]\fP) – 
.TP
.B Return type
Win
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, win=None)
.INDENT 7.0
.TP
.B Parameters
\fBwin\fP (\fIOptional\fP\fI[\fP\fIWin\fP\fI]\fP) – 
.TP
.B Return type
Win
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Accumulate\fP(origin, target_rank[, target, op])
T}	T{
Accumulate data into the target process
T}
_
T{
\fI\%Allocate\fP(size[, disp_unit, info, comm])
T}	T{
Create an window object for one\-sided communication
T}
_
T{
\fI\%Allocate_shared\fP(size[, disp_unit, info, comm])
T}	T{
Create an window object for one\-sided communication
T}
_
T{
\fI\%Attach\fP(memory)
T}	T{
Attach a local memory region
T}
_
T{
\fI\%Call_errhandler\fP(errorcode)
T}	T{
Call the error handler installed on a window
T}
_
T{
\fI\%Compare_and_swap\fP(origin, compare, result, ...)
T}	T{
Perform one\-sided atomic compare\-and\-swap
T}
_
T{
\fI\%Complete\fP()
T}	T{
Completes an RMA operations begun after an \fI\%Win.Start()\fP
T}
_
T{
\fI\%Create\fP(memory[, disp_unit, info, comm])
T}	T{
Create an window object for one\-sided communication
T}
_
T{
\fI\%Create_dynamic\fP([info, comm])
T}	T{
Create an window object for one\-sided communication
T}
_
T{
\fI\%Create_keyval\fP([copy_fn, delete_fn, nopython])
T}	T{
Create a new attribute key for windows
T}
_
T{
\fI\%Delete_attr\fP(keyval)
T}	T{
Delete attribute value associated with a key
T}
_
T{
\fI\%Detach\fP(memory)
T}	T{
Detach a local memory region
T}
_
T{
\fI\%Fence\fP([assertion])
T}	T{
Perform an MPI fence synchronization on a window
T}
_
T{
\fI\%Fetch_and_op\fP(origin, result, target_rank[, ...])
T}	T{
Perform one\-sided read\-modify\-write
T}
_
T{
\fI\%Flush\fP(rank)
T}	T{
Complete all outstanding RMA operations at the given target
T}
_
T{
\fI\%Flush_all\fP()
T}	T{
Complete  all  outstanding RMA operations at all targets
T}
_
T{
\fI\%Flush_local\fP(rank)
T}	T{
Complete locally all outstanding RMA operations at the given target
T}
_
T{
\fI\%Flush_local_all\fP()
T}	T{
Complete locally all outstanding RMA opera\- tions at all targets
T}
_
T{
\fI\%Free\fP()
T}	T{
Free a window
T}
_
T{
\fI\%Free_keyval\fP(keyval)
T}	T{
Free an attribute key for windows
T}
_
T{
\fI\%Get\fP(origin, target_rank[, target])
T}	T{
Get data from a memory window on a remote process.
T}
_
T{
\fI\%Get_accumulate\fP(origin, result, target_rank)
T}	T{
Fetch\-and\-accumulate data into the target process
T}
_
T{
\fI\%Get_attr\fP(keyval)
T}	T{
Retrieve attribute value by key
T}
_
T{
\fI\%Get_errhandler\fP()
T}	T{
Get the error handler for a window
T}
_
T{
\fI\%Get_group\fP()
T}	T{
Return a duplicate of the group of the communicator used to create the window
T}
_
T{
\fI\%Get_info\fP()
T}	T{
Return the hints for a windows that are currently in use
T}
_
T{
\fI\%Get_name\fP()
T}	T{
Get the print name associated with the window
T}
_
T{
\fI\%Lock\fP(rank[, lock_type, assertion])
T}	T{
Begin an RMA access epoch at the target process
T}
_
T{
\fI\%Lock_all\fP([assertion])
T}	T{
Begin an RMA access epoch at all processes
T}
_
T{
\fI\%Post\fP(group[, assertion])
T}	T{
Start an RMA exposure epoch
T}
_
T{
\fI\%Put\fP(origin, target_rank[, target])
T}	T{
Put data into a memory window on a remote process.
T}
_
T{
\fI\%Raccumulate\fP(origin, target_rank[, target, op])
T}	T{
Fetch\-and\-accumulate data into the target process
T}
_
T{
\fI\%Rget\fP(origin, target_rank[, target])
T}	T{
Get data from a memory window on a remote process.
T}
_
T{
\fI\%Rget_accumulate\fP(origin, result, target_rank)
T}	T{
Accumulate data into the target process using remote memory access.
T}
_
T{
\fI\%Rput\fP(origin, target_rank[, target])
T}	T{
Put data into a memory window on a remote process.
T}
_
T{
\fI\%Set_attr\fP(keyval, attrval)
T}	T{
Store attribute value associated with a key
T}
_
T{
\fI\%Set_errhandler\fP(errhandler)
T}	T{
Set the error handler for a window
T}
_
T{
\fI\%Set_info\fP(info)
T}	T{
Set new values for the hints associated with a window
T}
_
T{
\fI\%Set_name\fP(name)
T}	T{
Set the print name associated with the window
T}
_
T{
\fI\%Shared_query\fP(rank)
T}	T{
Query the process\-local address for remote memory segments created with \fI\%Win.Allocate_shared()\fP
T}
_
T{
\fI\%Start\fP(group[, assertion])
T}	T{
Start an RMA access epoch for MPI
T}
_
T{
\fI\%Sync\fP()
T}	T{
Synchronize public and private copies of the given window
T}
_
T{
\fI\%Test\fP()
T}	T{
Test whether an RMA exposure epoch has completed
T}
_
T{
\fI\%Unlock\fP(rank)
T}	T{
Complete an RMA access epoch at the target process
T}
_
T{
\fI\%Unlock_all\fP()
T}	T{
Complete an RMA access epoch at all processes
T}
_
T{
\fI\%Wait\fP()
T}	T{
Complete an RMA exposure epoch begun with \fI\%Win.Post()\fP
T}
_
T{
\fI\%f2py\fP(arg)
T}	T{
T}
_
T{
\fI\%py2f\fP()
T}	T{
T}
_
T{
\fI\%tomemory\fP()
T}	T{
Return window memory buffer
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%attrs\fP
T}	T{
window attributes
T}
_
T{
\fI\%flavor\fP
T}	T{
window create flavor
T}
_
T{
\fI\%group\fP
T}	T{
window group
T}
_
T{
\fI\%info\fP
T}	T{
window info
T}
_
T{
\fI\%model\fP
T}	T{
window memory model
T}
_
T{
\fI\%name\fP
T}	T{
window name
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Accumulate(origin, target_rank, target=None, op=SUM)
Accumulate data into the target process
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget\fP (\fIOptional\fP\fI[\fP\fITargetSpec\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Allocate(size, disp_unit=1, info=INFO_NULL, comm=COMM_SELF)
Create an window object for one\-sided communication
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsize\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBdisp_unit\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.IP \(bu 2
\fBcomm\fP (\fIIntracomm\fP) – 
.UNINDENT
.TP
.B Return type
Win
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Allocate_shared(size, disp_unit=1, info=INFO_NULL, comm=COMM_SELF)
Create an window object for one\-sided communication
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsize\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBdisp_unit\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.IP \(bu 2
\fBcomm\fP (\fIIntracomm\fP) – 
.UNINDENT
.TP
.B Return type
Win
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Attach(memory)
Attach a local memory region
.INDENT 7.0
.TP
.B Parameters
\fBmemory\fP (\fIBuffer\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Call_errhandler(errorcode)
Call the error handler installed on a window
.INDENT 7.0
.TP
.B Parameters
\fBerrorcode\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Compare_and_swap(origin, compare, result, target_rank, target_disp=0)
Perform one\-sided atomic compare\-and\-swap
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBcompare\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBresult\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget_disp\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Complete()
Completes an RMA operations begun after an \fI\%Win.Start()\fP
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Create(memory, disp_unit=1, info=INFO_NULL, comm=COMM_SELF)
Create an window object for one\-sided communication
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmemory\fP (\fIUnion\fP\fI[\fP\fIBuffer\fP\fI, \fP\fIBottom\fP\fI, \fP\fI\%None\fP\fI]\fP) – 
.IP \(bu 2
\fBdisp_unit\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.IP \(bu 2
\fBcomm\fP (\fIIntracomm\fP) – 
.UNINDENT
.TP
.B Return type
Win
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Create_dynamic(info=INFO_NULL, comm=COMM_SELF)
Create an window object for one\-sided communication
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.IP \(bu 2
\fBcomm\fP (\fIIntracomm\fP) – 
.UNINDENT
.TP
.B Return type
Win
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Create_keyval(copy_fn=None, delete_fn=None, nopython=False)
Create a new attribute key for windows
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBcopy_fn\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIWin\fP\fI, \fP\fI\%int\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fIAny\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBdelete_fn\fP (\fIOptional\fP\fI[\fP\fICallable\fP\fI[\fP\fI[\fP\fIWin\fP\fI, \fP\fI\%int\fP\fI, \fP\fIAny\fP\fI]\fP\fI, \fP\fI\%None\fP\fI]\fP\fI]\fP) – 
.IP \(bu 2
\fBnopython\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Delete_attr(keyval)
Delete attribute value associated with a key
.INDENT 7.0
.TP
.B Parameters
\fBkeyval\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Detach(memory)
Detach a local memory region
.INDENT 7.0
.TP
.B Parameters
\fBmemory\fP (\fIBuffer\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Fence(assertion=0)
Perform an MPI fence synchronization on a window
.INDENT 7.0
.TP
.B Parameters
\fBassertion\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Fetch_and_op(origin, result, target_rank, target_disp=0, op=SUM)
Perform one\-sided read\-modify\-write
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBresult\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget_disp\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Flush(rank)
Complete all outstanding RMA operations at the given target
.INDENT 7.0
.TP
.B Parameters
\fBrank\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Flush_all()
Complete  all  outstanding RMA operations at all targets
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Flush_local(rank)
Complete locally all outstanding RMA operations at the given target
.INDENT 7.0
.TP
.B Parameters
\fBrank\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Flush_local_all()
Complete locally all outstanding RMA opera\- tions at all targets
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Free()
Free a window
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  Free_keyval(keyval)
Free an attribute key for windows
.INDENT 7.0
.TP
.B Parameters
\fBkeyval\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get(origin, target_rank, target=None)
Get data from a memory window on a remote process.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget\fP (\fIOptional\fP\fI[\fP\fITargetSpec\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_accumulate(origin, result, target_rank, target=None, op=SUM)
Fetch\-and\-accumulate data into the target process
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBresult\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget\fP (\fIOptional\fP\fI[\fP\fITargetSpec\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_attr(keyval)
Retrieve attribute value by key
.INDENT 7.0
.TP
.B Parameters
\fBkeyval\fP (\fI\%int\fP) – 
.TP
.B Return type
Optional[Union[\fI\%int\fP, Any]]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_errhandler()
Get the error handler for a window
.INDENT 7.0
.TP
.B Return type
Errhandler
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_group()
Return a duplicate of the group of the
communicator used to create the window
.INDENT 7.0
.TP
.B Return type
Group
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_info()
Return the hints for a windows
that are currently in use
.INDENT 7.0
.TP
.B Return type
Info
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_name()
Get the print name associated with the window
.INDENT 7.0
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Lock(rank, lock_type=LOCK_EXCLUSIVE, assertion=0)
Begin an RMA access epoch at the target process
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBrank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBlock_type\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBassertion\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Lock_all(assertion=0)
Begin an RMA access epoch at all processes
.INDENT 7.0
.TP
.B Parameters
\fBassertion\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Post(group, assertion=0)
Start an RMA exposure epoch
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgroup\fP (\fIGroup\fP) – 
.IP \(bu 2
\fBassertion\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Put(origin, target_rank, target=None)
Put data into a memory window on a remote process.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget\fP (\fIOptional\fP\fI[\fP\fITargetSpec\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Raccumulate(origin, target_rank, target=None, op=SUM)
Fetch\-and\-accumulate data into the target process
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget\fP (\fIOptional\fP\fI[\fP\fITargetSpec\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Rget(origin, target_rank, target=None)
Get data from a memory window on a remote process.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget\fP (\fIOptional\fP\fI[\fP\fITargetSpec\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Rget_accumulate(origin, result, target_rank, target=None, op=SUM)
Accumulate data into the target process
using remote memory access.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBresult\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget\fP (\fIOptional\fP\fI[\fP\fITargetSpec\fP\fI]\fP) – 
.IP \(bu 2
\fBop\fP (\fIOp\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Rput(origin, target_rank, target=None)
Put data into a memory window on a remote process.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBorigin\fP (\fIBufSpec\fP) – 
.IP \(bu 2
\fBtarget_rank\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBtarget\fP (\fIOptional\fP\fI[\fP\fITargetSpec\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
Request
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_attr(keyval, attrval)
Store attribute value associated with a key
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBkeyval\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBattrval\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_errhandler(errhandler)
Set the error handler for a window
.INDENT 7.0
.TP
.B Parameters
\fBerrhandler\fP (\fIErrhandler\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_info(info)
Set new values for the hints
associated with a window
.INDENT 7.0
.TP
.B Parameters
\fBinfo\fP (\fIInfo\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Set_name(name)
Set the print name associated with the window
.INDENT 7.0
.TP
.B Parameters
\fBname\fP (\fI\%str\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Shared_query(rank)
Query the process\-local address
for remote memory segments
created with \fI\%Win.Allocate_shared()\fP
.INDENT 7.0
.TP
.B Parameters
\fBrank\fP (\fI\%int\fP) – 
.TP
.B Return type
Tuple[memory, \fI\%int\fP]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Start(group, assertion=0)
Start an RMA access epoch for MPI
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgroup\fP (\fIGroup\fP) – 
.IP \(bu 2
\fBassertion\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Sync()
Synchronize public and private copies of the given window
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Test()
Test whether an RMA exposure epoch has completed
.INDENT 7.0
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Unlock(rank)
Complete an RMA access epoch at the target process
.INDENT 7.0
.TP
.B Parameters
\fBrank\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Unlock_all()
Complete an RMA access epoch at all processes
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Wait()
Complete an RMA exposure epoch begun with \fI\%Win.Post()\fP
.INDENT 7.0
.TP
.B Return type
Literal[True]
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B classmethod  f2py(arg)
.INDENT 7.0
.TP
.B Parameters
\fBarg\fP (\fI\%int\fP) – 
.TP
.B Return type
Win
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B py2f()
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B tomemory()
Return window memory buffer
.INDENT 7.0
.TP
.B Return type
memory
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B attrs
window attributes
.UNINDENT
.INDENT 7.0
.TP
.B flavor
window create flavor
.UNINDENT
.INDENT 7.0
.TP
.B group
window group
.UNINDENT
.INDENT 7.0
.TP
.B info
window info
.UNINDENT
.INDENT 7.0
.TP
.B model
window memory model
.UNINDENT
.INDENT 7.0
.TP
.B name
window name
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.memory
.INDENT 0.0
.TP
.B class  mpi4py.MPI.memory(buf)
Bases: \fI\%object\fP
.sp
Memory buffer
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBuffer\fP) – 
.TP
.B Return type
memory
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, buf)
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBuffer\fP) – 
.TP
.B Return type
memory
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%allocate\fP(nbytes[, clear])
T}	T{
Memory allocation
T}
_
T{
\fI\%fromaddress\fP(address, nbytes[, readonly])
T}	T{
Memory from address and size in bytes
T}
_
T{
\fI\%frombuffer\fP(obj[, readonly])
T}	T{
Memory from buffer\-like object
T}
_
T{
\fI\%release\fP()
T}	T{
Release the underlying buffer exposed by the memory object
T}
_
T{
\fI\%tobytes\fP([order])
T}	T{
Return the data in the buffer as a byte string
T}
_
T{
\fI\%toreadonly\fP()
T}	T{
Return a readonly version of the memory object
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%address\fP
T}	T{
Memory address
T}
_
T{
\fI\%format\fP
T}	T{
A string with the format of each element
T}
_
T{
\fI\%itemsize\fP
T}	T{
The size in bytes of each element
T}
_
T{
\fI\%nbytes\fP
T}	T{
Memory size (in bytes)
T}
_
T{
\fI\%obj\fP
T}	T{
The underlying object of the memory
T}
_
T{
\fI\%readonly\fP
T}	T{
Boolean indicating whether the memory is read\-only
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B static  allocate(nbytes, clear=False)
Memory allocation
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBnbytes\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBclear\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
memory
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  fromaddress(address, nbytes, readonly=False)
Memory from address and size in bytes
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBaddress\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBnbytes\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBreadonly\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
memory
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B static  frombuffer(obj, readonly=False)
Memory from buffer\-like object
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBobj\fP (\fIBuffer\fP) – 
.IP \(bu 2
\fBreadonly\fP (\fI\%bool\fP) – 
.UNINDENT
.TP
.B Return type
memory
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B release()
Release the underlying buffer exposed by the memory object
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B tobytes(order=None)
Return the data in the buffer as a byte string
.INDENT 7.0
.TP
.B Parameters
\fBorder\fP (\fIOptional\fP\fI[\fP\fI\%str\fP\fI]\fP) – 
.TP
.B Return type
\fI\%bytes\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B toreadonly()
Return a readonly version of the memory object
.INDENT 7.0
.TP
.B Return type
memory
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B address
Memory address
.UNINDENT
.INDENT 7.0
.TP
.B format
A string with the format of each element
.UNINDENT
.INDENT 7.0
.TP
.B itemsize
The size in bytes of each element
.UNINDENT
.INDENT 7.0
.TP
.B nbytes
Memory size (in bytes)
.UNINDENT
.INDENT 7.0
.TP
.B obj
The underlying object of the memory
.UNINDENT
.INDENT 7.0
.TP
.B readonly
Boolean indicating whether the memory is read\-only
.UNINDENT
.UNINDENT
.sp
Exceptions
.TS
center;
|l|l|.
_
T{
\fBException\fP([ierr])
T}	T{
Exception class
T}
_
.TE
.SS mpi4py.MPI.Exception
.INDENT 0.0
.TP
.B exception  mpi4py.MPI.Exception(ierr=SUCCESS)
Bases: \fI\%RuntimeError\fP
.sp
Exception class
.INDENT 7.0
.TP
.B Parameters
\fBierr\fP (\fI\%int\fP) – 
.TP
.B Return type
Exception
.UNINDENT
.INDENT 7.0
.TP
.B static  __new__(cls, ierr=SUCCESS)
.INDENT 7.0
.TP
.B Parameters
\fBierr\fP (\fI\%int\fP) – 
.TP
.B Return type
Exception
.UNINDENT
.UNINDENT
.sp
Methods Summary
.TS
center;
|l|l|.
_
T{
\fI\%Get_error_class\fP()
T}	T{
Error class
T}
_
T{
\fI\%Get_error_code\fP()
T}	T{
Error code
T}
_
T{
\fI\%Get_error_string\fP()
T}	T{
Error string
T}
_
.TE
.sp
Attributes Summary
.TS
center;
|l|l|.
_
T{
\fI\%error_class\fP
T}	T{
error class
T}
_
T{
\fI\%error_code\fP
T}	T{
error code
T}
_
T{
\fI\%error_string\fP
T}	T{
error string
T}
_
.TE
.sp
Methods Documentation
.INDENT 7.0
.TP
.B Get_error_class()
Error class
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_error_code()
Error code
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B Get_error_string()
Error string
.INDENT 7.0
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.sp
Attributes Documentation
.INDENT 7.0
.TP
.B error_class
error class
.UNINDENT
.INDENT 7.0
.TP
.B error_code
error code
.UNINDENT
.INDENT 7.0
.TP
.B error_string
error string
.UNINDENT
.UNINDENT
.sp
Functions
.TS
center;
|l|l|.
_
T{
\fBAdd_error_class\fP()
T}	T{
Add an \fIerror class\fP to the known error classes
T}
_
T{
\fBAdd_error_code\fP(errorclass)
T}	T{
Add an \fIerror code\fP to an \fIerror class\fP
T}
_
T{
\fBAdd_error_string\fP(errorcode, string)
T}	T{
Associate an \fIerror string\fP with an \fIerror class\fP or \fIerrorcode\fP
T}
_
T{
\fBAint_add\fP(base, disp)
T}	T{
Return the sum of base address and displacement
T}
_
T{
\fBAint_diff\fP(addr1, addr2)
T}	T{
Return the difference between absolute addresses
T}
_
T{
\fBAlloc_mem\fP(size[, info])
T}	T{
Allocate memory for message passing and RMA
T}
_
T{
\fBAttach_buffer\fP(buf)
T}	T{
Attach a user\-provided buffer for sending in buffered mode
T}
_
T{
\fBClose_port\fP(port_name)
T}	T{
Close a port
T}
_
T{
\fBCompute_dims\fP(nnodes, dims)
T}	T{
Return a balanced distribution of processes per coordinate direction
T}
_
T{
\fBDetach_buffer\fP()
T}	T{
Remove an existing attached buffer
T}
_
T{
\fBFinalize\fP()
T}	T{
Terminate the MPI execution environment
T}
_
T{
\fBFree_mem\fP(mem)
T}	T{
Free memory allocated with \fBAlloc_mem()\fP
T}
_
T{
\fBGet_address\fP(location)
T}	T{
Get the address of a location in memory
T}
_
T{
\fBGet_error_class\fP(errorcode)
T}	T{
Convert an \fIerror code\fP into an \fIerror class\fP
T}
_
T{
\fBGet_error_string\fP(errorcode)
T}	T{
Return the \fIerror string\fP for a given \fIerror class\fP or \fIerror code\fP
T}
_
T{
\fBGet_library_version\fP()
T}	T{
Obtain the version string of the MPI library
T}
_
T{
\fBGet_processor_name\fP()
T}	T{
Obtain the name of the calling processor
T}
_
T{
\fBGet_version\fP()
T}	T{
Obtain the version number of the MPI standard supported by the implementation as a tuple \fB(version, subversion)\fP
T}
_
T{
\fBInit\fP()
T}	T{
Initialize the MPI execution environment
T}
_
T{
\fBInit_thread\fP([required])
T}	T{
Initialize the MPI execution environment
T}
_
T{
\fBIs_finalized\fP()
T}	T{
Indicates whether \fBFinalize\fP has completed
T}
_
T{
\fBIs_initialized\fP()
T}	T{
Indicates whether \fBInit\fP has been called
T}
_
T{
\fBIs_thread_main\fP()
T}	T{
Indicate whether this thread called \fBInit\fP or \fBInit_thread\fP
T}
_
T{
\fBLookup_name\fP(service_name[, info])
T}	T{
Lookup a port name given a service name
T}
_
T{
\fBOpen_port\fP([info])
T}	T{
Return an address that can be used to establish connections between groups of MPI processes
T}
_
T{
\fBPcontrol\fP(level)
T}	T{
Control profiling
T}
_
T{
\fBPublish_name\fP(service_name, port_name[, info])
T}	T{
Publish a service name
T}
_
T{
\fBQuery_thread\fP()
T}	T{
Return the level of thread support provided by the MPI library
T}
_
T{
\fBRegister_datarep\fP(datarep, read_fn, write_fn, ...)
T}	T{
Register user\-defined data representations
T}
_
T{
\fBUnpublish_name\fP(service_name, port_name[, info])
T}	T{
Unpublish a service name
T}
_
T{
\fBWtick\fP()
T}	T{
Return the resolution of \fBWtime\fP
T}
_
T{
\fBWtime\fP()
T}	T{
Return an elapsed time on the calling processor
T}
_
T{
\fBget_vendor\fP()
T}	T{
Infomation about the underlying MPI implementation
T}
_
.TE
.SS mpi4py.MPI.Add_error_class
.INDENT 0.0
.TP
.B mpi4py.MPI.Add_error_class()
Add an \fIerror class\fP to the known error classes
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Add_error_code
.INDENT 0.0
.TP
.B mpi4py.MPI.Add_error_code(errorclass)
Add an \fIerror code\fP to an \fIerror class\fP
.INDENT 7.0
.TP
.B Parameters
\fBerrorclass\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Add_error_string
.INDENT 0.0
.TP
.B mpi4py.MPI.Add_error_string(errorcode, string)
Associate an \fIerror string\fP with an
\fIerror class\fP or \fIerrorcode\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBerrorcode\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBstring\fP (\fI\%str\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Aint_add
.INDENT 0.0
.TP
.B mpi4py.MPI.Aint_add(base, disp)
Return the sum of base address and displacement
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbase\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBdisp\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Aint_diff
.INDENT 0.0
.TP
.B mpi4py.MPI.Aint_diff(addr1, addr2)
Return the difference between absolute addresses
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBaddr1\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBaddr2\fP (\fI\%int\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Alloc_mem
.INDENT 0.0
.TP
.B mpi4py.MPI.Alloc_mem(size, info=INFO_NULL)
Allocate memory for message passing and RMA
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsize\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.UNINDENT
.TP
.B Return type
memory
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Attach_buffer
.INDENT 0.0
.TP
.B mpi4py.MPI.Attach_buffer(buf)
Attach a user\-provided buffer for
sending in buffered mode
.INDENT 7.0
.TP
.B Parameters
\fBbuf\fP (\fIBuffer\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Close_port
.INDENT 0.0
.TP
.B mpi4py.MPI.Close_port(port_name)
Close a port
.INDENT 7.0
.TP
.B Parameters
\fBport_name\fP (\fI\%str\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Compute_dims
.INDENT 0.0
.TP
.B mpi4py.MPI.Compute_dims(nnodes, dims)
Return a balanced distribution of
processes per coordinate direction
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBnnodes\fP (\fI\%int\fP) – 
.IP \(bu 2
\fBdims\fP (\fIUnion\fP\fI[\fP\fI\%int\fP\fI, \fP\fISequence\fP\fI[\fP\fI\%int\fP\fI]\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
List[\fI\%int\fP]
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Detach_buffer
.INDENT 0.0
.TP
.B mpi4py.MPI.Detach_buffer()
Remove an existing attached buffer
.INDENT 7.0
.TP
.B Return type
Buffer
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Finalize
.INDENT 0.0
.TP
.B mpi4py.MPI.Finalize()
Terminate the MPI execution environment
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Free_mem
.INDENT 0.0
.TP
.B mpi4py.MPI.Free_mem(mem)
Free memory allocated with \fBAlloc_mem()\fP
.INDENT 7.0
.TP
.B Parameters
\fBmem\fP (\fImemory\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Get_address
.INDENT 0.0
.TP
.B mpi4py.MPI.Get_address(location)
Get the address of a location in memory
.INDENT 7.0
.TP
.B Parameters
\fBlocation\fP (\fIUnion\fP\fI[\fP\fIBuffer\fP\fI, \fP\fIBottom\fP\fI]\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Get_error_class
.INDENT 0.0
.TP
.B mpi4py.MPI.Get_error_class(errorcode)
Convert an \fIerror code\fP into an \fIerror class\fP
.INDENT 7.0
.TP
.B Parameters
\fBerrorcode\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Get_error_string
.INDENT 0.0
.TP
.B mpi4py.MPI.Get_error_string(errorcode)
Return the \fIerror string\fP for a given
\fIerror class\fP or \fIerror code\fP
.INDENT 7.0
.TP
.B Parameters
\fBerrorcode\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Get_library_version
.INDENT 0.0
.TP
.B mpi4py.MPI.Get_library_version()
Obtain the version string of the MPI library
.INDENT 7.0
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Get_processor_name
.INDENT 0.0
.TP
.B mpi4py.MPI.Get_processor_name()
Obtain the name of the calling processor
.INDENT 7.0
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Get_version
.INDENT 0.0
.TP
.B mpi4py.MPI.Get_version()
Obtain the version number of the MPI standard supported
by the implementation as a tuple \fB(version, subversion)\fP
.INDENT 7.0
.TP
.B Return type
Tuple[\fI\%int\fP, \fI\%int\fP]
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Init
.INDENT 0.0
.TP
.B mpi4py.MPI.Init()
Initialize the MPI execution environment
.INDENT 7.0
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Init_thread
.INDENT 0.0
.TP
.B mpi4py.MPI.Init_thread(required=THREAD_MULTIPLE)
Initialize the MPI execution environment
.INDENT 7.0
.TP
.B Parameters
\fBrequired\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Is_finalized
.INDENT 0.0
.TP
.B mpi4py.MPI.Is_finalized()
Indicates whether \fBFinalize\fP has completed
.INDENT 7.0
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Is_initialized
.INDENT 0.0
.TP
.B mpi4py.MPI.Is_initialized()
Indicates whether \fBInit\fP has been called
.INDENT 7.0
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Is_thread_main
.INDENT 0.0
.TP
.B mpi4py.MPI.Is_thread_main()
Indicate whether this thread called \fBInit\fP or \fBInit_thread\fP
.INDENT 7.0
.TP
.B Return type
\fI\%bool\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Lookup_name
.INDENT 0.0
.TP
.B mpi4py.MPI.Lookup_name(service_name, info=INFO_NULL)
Lookup a port name given a service name
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBservice_name\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Open_port
.INDENT 0.0
.TP
.B mpi4py.MPI.Open_port(info=INFO_NULL)
Return an address that can be used to establish
connections between groups of MPI processes
.INDENT 7.0
.TP
.B Parameters
\fBinfo\fP (\fIInfo\fP) – 
.TP
.B Return type
\fI\%str\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Pcontrol
.INDENT 0.0
.TP
.B mpi4py.MPI.Pcontrol(level)
Control profiling
.INDENT 7.0
.TP
.B Parameters
\fBlevel\fP (\fI\%int\fP) – 
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Publish_name
.INDENT 0.0
.TP
.B mpi4py.MPI.Publish_name(service_name, port_name, info=INFO_NULL)
Publish a service name
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBservice_name\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBport_name\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Query_thread
.INDENT 0.0
.TP
.B mpi4py.MPI.Query_thread()
Return the level of thread support provided by the MPI library
.INDENT 7.0
.TP
.B Return type
\fI\%int\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Register_datarep
.INDENT 0.0
.TP
.B mpi4py.MPI.Register_datarep(datarep, read_fn, write_fn, extent_fn)
Register user\-defined data representations
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdatarep\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBread_fn\fP (\fICallable\fP\fI[\fP\fI[\fP\fIBuffer\fP\fI, \fP\fIDatatype\fP\fI, \fP\fI\%int\fP\fI, \fP\fIBuffer\fP\fI, \fP\fI\%int\fP\fI]\fP\fI, \fP\fI\%None\fP\fI]\fP) – 
.IP \(bu 2
\fBwrite_fn\fP (\fICallable\fP\fI[\fP\fI[\fP\fIBuffer\fP\fI, \fP\fIDatatype\fP\fI, \fP\fI\%int\fP\fI, \fP\fIBuffer\fP\fI, \fP\fI\%int\fP\fI]\fP\fI, \fP\fI\%None\fP\fI]\fP) – 
.IP \(bu 2
\fBextent_fn\fP (\fICallable\fP\fI[\fP\fI[\fP\fIDatatype\fP\fI]\fP\fI, \fP\fI\%int\fP\fI]\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Unpublish_name
.INDENT 0.0
.TP
.B mpi4py.MPI.Unpublish_name(service_name, port_name, info=INFO_NULL)
Unpublish a service name
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBservice_name\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBport_name\fP (\fI\%str\fP) – 
.IP \(bu 2
\fBinfo\fP (\fIInfo\fP) – 
.UNINDENT
.TP
.B Return type
\fI\%None\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Wtick
.INDENT 0.0
.TP
.B mpi4py.MPI.Wtick()
Return the resolution of \fBWtime\fP
.INDENT 7.0
.TP
.B Return type
\fI\%float\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.Wtime
.INDENT 0.0
.TP
.B mpi4py.MPI.Wtime()
Return an elapsed time on the calling processor
.INDENT 7.0
.TP
.B Return type
\fI\%float\fP
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.get_vendor
.INDENT 0.0
.TP
.B mpi4py.MPI.get_vendor()
Infomation about the underlying MPI implementation
.INDENT 7.0
.TP
.B Returns
.INDENT 7.0
.IP \(bu 2
a string with the name of the MPI implementation
.IP \(bu 2
an integer 3\-tuple version \fB(major, minor, micro)\fP
.UNINDENT

.TP
.B Return type
Tuple[\fI\%str\fP, Tuple[\fI\%int\fP, \fI\%int\fP, \fI\%int\fP]]
.UNINDENT
.UNINDENT
.sp
Attributes
.TS
center;
|l|l|.
_
T{
\fBUNDEFINED\fP
T}	T{
\fI\%int\fP \fBUNDEFINED\fP
T}
_
T{
\fBANY_SOURCE\fP
T}	T{
\fI\%int\fP \fBANY_SOURCE\fP
T}
_
T{
\fBANY_TAG\fP
T}	T{
\fI\%int\fP \fBANY_TAG\fP
T}
_
T{
\fBPROC_NULL\fP
T}	T{
\fI\%int\fP \fBPROC_NULL\fP
T}
_
T{
\fBROOT\fP
T}	T{
\fI\%int\fP \fBROOT\fP
T}
_
T{
\fBBOTTOM\fP
T}	T{
\fBBottom\fP \fBBOTTOM\fP
T}
_
T{
\fBIN_PLACE\fP
T}	T{
\fBInPlace\fP \fBIN_PLACE\fP
T}
_
T{
\fBKEYVAL_INVALID\fP
T}	T{
\fI\%int\fP \fBKEYVAL_INVALID\fP
T}
_
T{
\fBTAG_UB\fP
T}	T{
\fI\%int\fP \fBTAG_UB\fP
T}
_
T{
\fBHOST\fP
T}	T{
\fI\%int\fP \fBHOST\fP
T}
_
T{
\fBIO\fP
T}	T{
\fI\%int\fP \fBIO\fP
T}
_
T{
\fBWTIME_IS_GLOBAL\fP
T}	T{
\fI\%int\fP \fBWTIME_IS_GLOBAL\fP
T}
_
T{
\fBUNIVERSE_SIZE\fP
T}	T{
\fI\%int\fP \fBUNIVERSE_SIZE\fP
T}
_
T{
\fBAPPNUM\fP
T}	T{
\fI\%int\fP \fBAPPNUM\fP
T}
_
T{
\fBLASTUSEDCODE\fP
T}	T{
\fI\%int\fP \fBLASTUSEDCODE\fP
T}
_
T{
\fBWIN_BASE\fP
T}	T{
\fI\%int\fP \fBWIN_BASE\fP
T}
_
T{
\fBWIN_SIZE\fP
T}	T{
\fI\%int\fP \fBWIN_SIZE\fP
T}
_
T{
\fBWIN_DISP_UNIT\fP
T}	T{
\fI\%int\fP \fBWIN_DISP_UNIT\fP
T}
_
T{
\fBWIN_CREATE_FLAVOR\fP
T}	T{
\fI\%int\fP \fBWIN_CREATE_FLAVOR\fP
T}
_
T{
\fBWIN_FLAVOR\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR\fP
T}
_
T{
\fBWIN_MODEL\fP
T}	T{
\fI\%int\fP \fBWIN_MODEL\fP
T}
_
T{
\fBSUCCESS\fP
T}	T{
\fI\%int\fP \fBSUCCESS\fP
T}
_
T{
\fBERR_LASTCODE\fP
T}	T{
\fI\%int\fP \fBERR_LASTCODE\fP
T}
_
T{
\fBERR_COMM\fP
T}	T{
\fI\%int\fP \fBERR_COMM\fP
T}
_
T{
\fBERR_GROUP\fP
T}	T{
\fI\%int\fP \fBERR_GROUP\fP
T}
_
T{
\fBERR_TYPE\fP
T}	T{
\fI\%int\fP \fBERR_TYPE\fP
T}
_
T{
\fBERR_REQUEST\fP
T}	T{
\fI\%int\fP \fBERR_REQUEST\fP
T}
_
T{
\fBERR_OP\fP
T}	T{
\fI\%int\fP \fBERR_OP\fP
T}
_
T{
\fBERR_BUFFER\fP
T}	T{
\fI\%int\fP \fBERR_BUFFER\fP
T}
_
T{
\fBERR_COUNT\fP
T}	T{
\fI\%int\fP \fBERR_COUNT\fP
T}
_
T{
\fBERR_TAG\fP
T}	T{
\fI\%int\fP \fBERR_TAG\fP
T}
_
T{
\fBERR_RANK\fP
T}	T{
\fI\%int\fP \fBERR_RANK\fP
T}
_
T{
\fBERR_ROOT\fP
T}	T{
\fI\%int\fP \fBERR_ROOT\fP
T}
_
T{
\fBERR_TRUNCATE\fP
T}	T{
\fI\%int\fP \fBERR_TRUNCATE\fP
T}
_
T{
\fBERR_IN_STATUS\fP
T}	T{
\fI\%int\fP \fBERR_IN_STATUS\fP
T}
_
T{
\fBERR_PENDING\fP
T}	T{
\fI\%int\fP \fBERR_PENDING\fP
T}
_
T{
\fBERR_TOPOLOGY\fP
T}	T{
\fI\%int\fP \fBERR_TOPOLOGY\fP
T}
_
T{
\fBERR_DIMS\fP
T}	T{
\fI\%int\fP \fBERR_DIMS\fP
T}
_
T{
\fBERR_ARG\fP
T}	T{
\fI\%int\fP \fBERR_ARG\fP
T}
_
T{
\fBERR_OTHER\fP
T}	T{
\fI\%int\fP \fBERR_OTHER\fP
T}
_
T{
\fBERR_UNKNOWN\fP
T}	T{
\fI\%int\fP \fBERR_UNKNOWN\fP
T}
_
T{
\fBERR_INTERN\fP
T}	T{
\fI\%int\fP \fBERR_INTERN\fP
T}
_
T{
\fBERR_INFO\fP
T}	T{
\fI\%int\fP \fBERR_INFO\fP
T}
_
T{
\fBERR_FILE\fP
T}	T{
\fI\%int\fP \fBERR_FILE\fP
T}
_
T{
\fBERR_WIN\fP
T}	T{
\fI\%int\fP \fBERR_WIN\fP
T}
_
T{
\fBERR_KEYVAL\fP
T}	T{
\fI\%int\fP \fBERR_KEYVAL\fP
T}
_
T{
\fBERR_INFO_KEY\fP
T}	T{
\fI\%int\fP \fBERR_INFO_KEY\fP
T}
_
T{
\fBERR_INFO_VALUE\fP
T}	T{
\fI\%int\fP \fBERR_INFO_VALUE\fP
T}
_
T{
\fBERR_INFO_NOKEY\fP
T}	T{
\fI\%int\fP \fBERR_INFO_NOKEY\fP
T}
_
T{
\fBERR_ACCESS\fP
T}	T{
\fI\%int\fP \fBERR_ACCESS\fP
T}
_
T{
\fBERR_AMODE\fP
T}	T{
\fI\%int\fP \fBERR_AMODE\fP
T}
_
T{
\fBERR_BAD_FILE\fP
T}	T{
\fI\%int\fP \fBERR_BAD_FILE\fP
T}
_
T{
\fBERR_FILE_EXISTS\fP
T}	T{
\fI\%int\fP \fBERR_FILE_EXISTS\fP
T}
_
T{
\fBERR_FILE_IN_USE\fP
T}	T{
\fI\%int\fP \fBERR_FILE_IN_USE\fP
T}
_
T{
\fBERR_NO_SPACE\fP
T}	T{
\fI\%int\fP \fBERR_NO_SPACE\fP
T}
_
T{
\fBERR_NO_SUCH_FILE\fP
T}	T{
\fI\%int\fP \fBERR_NO_SUCH_FILE\fP
T}
_
T{
\fBERR_IO\fP
T}	T{
\fI\%int\fP \fBERR_IO\fP
T}
_
T{
\fBERR_READ_ONLY\fP
T}	T{
\fI\%int\fP \fBERR_READ_ONLY\fP
T}
_
T{
\fBERR_CONVERSION\fP
T}	T{
\fI\%int\fP \fBERR_CONVERSION\fP
T}
_
T{
\fBERR_DUP_DATAREP\fP
T}	T{
\fI\%int\fP \fBERR_DUP_DATAREP\fP
T}
_
T{
\fBERR_UNSUPPORTED_DATAREP\fP
T}	T{
\fI\%int\fP \fBERR_UNSUPPORTED_DATAREP\fP
T}
_
T{
\fBERR_UNSUPPORTED_OPERATION\fP
T}	T{
\fI\%int\fP \fBERR_UNSUPPORTED_OPERATION\fP
T}
_
T{
\fBERR_NAME\fP
T}	T{
\fI\%int\fP \fBERR_NAME\fP
T}
_
T{
\fBERR_NO_MEM\fP
T}	T{
\fI\%int\fP \fBERR_NO_MEM\fP
T}
_
T{
\fBERR_NOT_SAME\fP
T}	T{
\fI\%int\fP \fBERR_NOT_SAME\fP
T}
_
T{
\fBERR_PORT\fP
T}	T{
\fI\%int\fP \fBERR_PORT\fP
T}
_
T{
\fBERR_QUOTA\fP
T}	T{
\fI\%int\fP \fBERR_QUOTA\fP
T}
_
T{
\fBERR_SERVICE\fP
T}	T{
\fI\%int\fP \fBERR_SERVICE\fP
T}
_
T{
\fBERR_SPAWN\fP
T}	T{
\fI\%int\fP \fBERR_SPAWN\fP
T}
_
T{
\fBERR_BASE\fP
T}	T{
\fI\%int\fP \fBERR_BASE\fP
T}
_
T{
\fBERR_SIZE\fP
T}	T{
\fI\%int\fP \fBERR_SIZE\fP
T}
_
T{
\fBERR_DISP\fP
T}	T{
\fI\%int\fP \fBERR_DISP\fP
T}
_
T{
\fBERR_ASSERT\fP
T}	T{
\fI\%int\fP \fBERR_ASSERT\fP
T}
_
T{
\fBERR_LOCKTYPE\fP
T}	T{
\fI\%int\fP \fBERR_LOCKTYPE\fP
T}
_
T{
\fBERR_RMA_CONFLICT\fP
T}	T{
\fI\%int\fP \fBERR_RMA_CONFLICT\fP
T}
_
T{
\fBERR_RMA_SYNC\fP
T}	T{
\fI\%int\fP \fBERR_RMA_SYNC\fP
T}
_
T{
\fBERR_RMA_RANGE\fP
T}	T{
\fI\%int\fP \fBERR_RMA_RANGE\fP
T}
_
T{
\fBERR_RMA_ATTACH\fP
T}	T{
\fI\%int\fP \fBERR_RMA_ATTACH\fP
T}
_
T{
\fBERR_RMA_SHARED\fP
T}	T{
\fI\%int\fP \fBERR_RMA_SHARED\fP
T}
_
T{
\fBERR_RMA_FLAVOR\fP
T}	T{
\fI\%int\fP \fBERR_RMA_FLAVOR\fP
T}
_
T{
\fBORDER_C\fP
T}	T{
\fI\%int\fP \fBORDER_C\fP
T}
_
T{
\fBORDER_FORTRAN\fP
T}	T{
\fI\%int\fP \fBORDER_FORTRAN\fP
T}
_
T{
\fBORDER_F\fP
T}	T{
\fI\%int\fP \fBORDER_F\fP
T}
_
T{
\fBTYPECLASS_INTEGER\fP
T}	T{
\fI\%int\fP \fBTYPECLASS_INTEGER\fP
T}
_
T{
\fBTYPECLASS_REAL\fP
T}	T{
\fI\%int\fP \fBTYPECLASS_REAL\fP
T}
_
T{
\fBTYPECLASS_COMPLEX\fP
T}	T{
\fI\%int\fP \fBTYPECLASS_COMPLEX\fP
T}
_
T{
\fBDISTRIBUTE_NONE\fP
T}	T{
\fI\%int\fP \fBDISTRIBUTE_NONE\fP
T}
_
T{
\fBDISTRIBUTE_BLOCK\fP
T}	T{
\fI\%int\fP \fBDISTRIBUTE_BLOCK\fP
T}
_
T{
\fBDISTRIBUTE_CYCLIC\fP
T}	T{
\fI\%int\fP \fBDISTRIBUTE_CYCLIC\fP
T}
_
T{
\fBDISTRIBUTE_DFLT_DARG\fP
T}	T{
\fI\%int\fP \fBDISTRIBUTE_DFLT_DARG\fP
T}
_
T{
\fBCOMBINER_NAMED\fP
T}	T{
\fI\%int\fP \fBCOMBINER_NAMED\fP
T}
_
T{
\fBCOMBINER_DUP\fP
T}	T{
\fI\%int\fP \fBCOMBINER_DUP\fP
T}
_
T{
\fBCOMBINER_CONTIGUOUS\fP
T}	T{
\fI\%int\fP \fBCOMBINER_CONTIGUOUS\fP
T}
_
T{
\fBCOMBINER_VECTOR\fP
T}	T{
\fI\%int\fP \fBCOMBINER_VECTOR\fP
T}
_
T{
\fBCOMBINER_HVECTOR\fP
T}	T{
\fI\%int\fP \fBCOMBINER_HVECTOR\fP
T}
_
T{
\fBCOMBINER_INDEXED\fP
T}	T{
\fI\%int\fP \fBCOMBINER_INDEXED\fP
T}
_
T{
\fBCOMBINER_HINDEXED\fP
T}	T{
\fI\%int\fP \fBCOMBINER_HINDEXED\fP
T}
_
T{
\fBCOMBINER_INDEXED_BLOCK\fP
T}	T{
\fI\%int\fP \fBCOMBINER_INDEXED_BLOCK\fP
T}
_
T{
\fBCOMBINER_HINDEXED_BLOCK\fP
T}	T{
\fI\%int\fP \fBCOMBINER_HINDEXED_BLOCK\fP
T}
_
T{
\fBCOMBINER_STRUCT\fP
T}	T{
\fI\%int\fP \fBCOMBINER_STRUCT\fP
T}
_
T{
\fBCOMBINER_SUBARRAY\fP
T}	T{
\fI\%int\fP \fBCOMBINER_SUBARRAY\fP
T}
_
T{
\fBCOMBINER_DARRAY\fP
T}	T{
\fI\%int\fP \fBCOMBINER_DARRAY\fP
T}
_
T{
\fBCOMBINER_RESIZED\fP
T}	T{
\fI\%int\fP \fBCOMBINER_RESIZED\fP
T}
_
T{
\fBCOMBINER_F90_REAL\fP
T}	T{
\fI\%int\fP \fBCOMBINER_F90_REAL\fP
T}
_
T{
\fBCOMBINER_F90_COMPLEX\fP
T}	T{
\fI\%int\fP \fBCOMBINER_F90_COMPLEX\fP
T}
_
T{
\fBCOMBINER_F90_INTEGER\fP
T}	T{
\fI\%int\fP \fBCOMBINER_F90_INTEGER\fP
T}
_
T{
\fBIDENT\fP
T}	T{
\fI\%int\fP \fBIDENT\fP
T}
_
T{
\fBCONGRUENT\fP
T}	T{
\fI\%int\fP \fBCONGRUENT\fP
T}
_
T{
\fBSIMILAR\fP
T}	T{
\fI\%int\fP \fBSIMILAR\fP
T}
_
T{
\fBUNEQUAL\fP
T}	T{
\fI\%int\fP \fBUNEQUAL\fP
T}
_
T{
\fBCART\fP
T}	T{
\fI\%int\fP \fBCART\fP
T}
_
T{
\fBGRAPH\fP
T}	T{
\fI\%int\fP \fBGRAPH\fP
T}
_
T{
\fBDIST_GRAPH\fP
T}	T{
\fI\%int\fP \fBDIST_GRAPH\fP
T}
_
T{
\fBUNWEIGHTED\fP
T}	T{
\fI\%int\fP \fBUNWEIGHTED\fP
T}
_
T{
\fBWEIGHTS_EMPTY\fP
T}	T{
\fI\%int\fP \fBWEIGHTS_EMPTY\fP
T}
_
T{
\fBCOMM_TYPE_SHARED\fP
T}	T{
\fI\%int\fP \fBCOMM_TYPE_SHARED\fP
T}
_
T{
\fBBSEND_OVERHEAD\fP
T}	T{
\fI\%int\fP \fBBSEND_OVERHEAD\fP
T}
_
T{
\fBWIN_FLAVOR_CREATE\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR_CREATE\fP
T}
_
T{
\fBWIN_FLAVOR_ALLOCATE\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR_ALLOCATE\fP
T}
_
T{
\fBWIN_FLAVOR_DYNAMIC\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR_DYNAMIC\fP
T}
_
T{
\fBWIN_FLAVOR_SHARED\fP
T}	T{
\fI\%int\fP \fBWIN_FLAVOR_SHARED\fP
T}
_
T{
\fBWIN_SEPARATE\fP
T}	T{
\fI\%int\fP \fBWIN_SEPARATE\fP
T}
_
T{
\fBWIN_UNIFIED\fP
T}	T{
\fI\%int\fP \fBWIN_UNIFIED\fP
T}
_
T{
\fBMODE_NOCHECK\fP
T}	T{
\fI\%int\fP \fBMODE_NOCHECK\fP
T}
_
T{
\fBMODE_NOSTORE\fP
T}	T{
\fI\%int\fP \fBMODE_NOSTORE\fP
T}
_
T{
\fBMODE_NOPUT\fP
T}	T{
\fI\%int\fP \fBMODE_NOPUT\fP
T}
_
T{
\fBMODE_NOPRECEDE\fP
T}	T{
\fI\%int\fP \fBMODE_NOPRECEDE\fP
T}
_
T{
\fBMODE_NOSUCCEED\fP
T}	T{
\fI\%int\fP \fBMODE_NOSUCCEED\fP
T}
_
T{
\fBLOCK_EXCLUSIVE\fP
T}	T{
\fI\%int\fP \fBLOCK_EXCLUSIVE\fP
T}
_
T{
\fBLOCK_SHARED\fP
T}	T{
\fI\%int\fP \fBLOCK_SHARED\fP
T}
_
T{
\fBMODE_RDONLY\fP
T}	T{
\fI\%int\fP \fBMODE_RDONLY\fP
T}
_
T{
\fBMODE_WRONLY\fP
T}	T{
\fI\%int\fP \fBMODE_WRONLY\fP
T}
_
T{
\fBMODE_RDWR\fP
T}	T{
\fI\%int\fP \fBMODE_RDWR\fP
T}
_
T{
\fBMODE_CREATE\fP
T}	T{
\fI\%int\fP \fBMODE_CREATE\fP
T}
_
T{
\fBMODE_EXCL\fP
T}	T{
\fI\%int\fP \fBMODE_EXCL\fP
T}
_
T{
\fBMODE_DELETE_ON_CLOSE\fP
T}	T{
\fI\%int\fP \fBMODE_DELETE_ON_CLOSE\fP
T}
_
T{
\fBMODE_UNIQUE_OPEN\fP
T}	T{
\fI\%int\fP \fBMODE_UNIQUE_OPEN\fP
T}
_
T{
\fBMODE_SEQUENTIAL\fP
T}	T{
\fI\%int\fP \fBMODE_SEQUENTIAL\fP
T}
_
T{
\fBMODE_APPEND\fP
T}	T{
\fI\%int\fP \fBMODE_APPEND\fP
T}
_
T{
\fBSEEK_SET\fP
T}	T{
\fI\%int\fP \fBSEEK_SET\fP
T}
_
T{
\fBSEEK_CUR\fP
T}	T{
\fI\%int\fP \fBSEEK_CUR\fP
T}
_
T{
\fBSEEK_END\fP
T}	T{
\fI\%int\fP \fBSEEK_END\fP
T}
_
T{
\fBDISPLACEMENT_CURRENT\fP
T}	T{
\fI\%int\fP \fBDISPLACEMENT_CURRENT\fP
T}
_
T{
\fBDISP_CUR\fP
T}	T{
\fI\%int\fP \fBDISP_CUR\fP
T}
_
T{
\fBTHREAD_SINGLE\fP
T}	T{
\fI\%int\fP \fBTHREAD_SINGLE\fP
T}
_
T{
\fBTHREAD_FUNNELED\fP
T}	T{
\fI\%int\fP \fBTHREAD_FUNNELED\fP
T}
_
T{
\fBTHREAD_SERIALIZED\fP
T}	T{
\fI\%int\fP \fBTHREAD_SERIALIZED\fP
T}
_
T{
\fBTHREAD_MULTIPLE\fP
T}	T{
\fI\%int\fP \fBTHREAD_MULTIPLE\fP
T}
_
T{
\fBVERSION\fP
T}	T{
\fI\%int\fP \fBVERSION\fP
T}
_
T{
\fBSUBVERSION\fP
T}	T{
\fI\%int\fP \fBSUBVERSION\fP
T}
_
T{
\fBMAX_PROCESSOR_NAME\fP
T}	T{
\fI\%int\fP \fBMAX_PROCESSOR_NAME\fP
T}
_
T{
\fBMAX_ERROR_STRING\fP
T}	T{
\fI\%int\fP \fBMAX_ERROR_STRING\fP
T}
_
T{
\fBMAX_PORT_NAME\fP
T}	T{
\fI\%int\fP \fBMAX_PORT_NAME\fP
T}
_
T{
\fBMAX_INFO_KEY\fP
T}	T{
\fI\%int\fP \fBMAX_INFO_KEY\fP
T}
_
T{
\fBMAX_INFO_VAL\fP
T}	T{
\fI\%int\fP \fBMAX_INFO_VAL\fP
T}
_
T{
\fBMAX_OBJECT_NAME\fP
T}	T{
\fI\%int\fP \fBMAX_OBJECT_NAME\fP
T}
_
T{
\fBMAX_DATAREP_STRING\fP
T}	T{
\fI\%int\fP \fBMAX_DATAREP_STRING\fP
T}
_
T{
\fBMAX_LIBRARY_VERSION_STRING\fP
T}	T{
\fI\%int\fP \fBMAX_LIBRARY_VERSION_STRING\fP
T}
_
T{
\fBDATATYPE_NULL\fP
T}	T{
\fBDatatype\fP \fBDATATYPE_NULL\fP
T}
_
T{
\fBUB\fP
T}	T{
\fBDatatype\fP \fBUB\fP
T}
_
T{
\fBLB\fP
T}	T{
\fBDatatype\fP \fBLB\fP
T}
_
T{
\fBPACKED\fP
T}	T{
\fBDatatype\fP \fBPACKED\fP
T}
_
T{
\fBBYTE\fP
T}	T{
\fBDatatype\fP \fBBYTE\fP
T}
_
T{
\fBAINT\fP
T}	T{
\fBDatatype\fP \fBAINT\fP
T}
_
T{
\fBOFFSET\fP
T}	T{
\fBDatatype\fP \fBOFFSET\fP
T}
_
T{
\fBCOUNT\fP
T}	T{
\fBDatatype\fP \fBCOUNT\fP
T}
_
T{
\fBCHAR\fP
T}	T{
\fBDatatype\fP \fBCHAR\fP
T}
_
T{
\fBWCHAR\fP
T}	T{
\fBDatatype\fP \fBWCHAR\fP
T}
_
T{
\fBSIGNED_CHAR\fP
T}	T{
\fBDatatype\fP \fBSIGNED_CHAR\fP
T}
_
T{
\fBSHORT\fP
T}	T{
\fBDatatype\fP \fBSHORT\fP
T}
_
T{
\fBINT\fP
T}	T{
\fBDatatype\fP \fBINT\fP
T}
_
T{
\fBLONG\fP
T}	T{
\fBDatatype\fP \fBLONG\fP
T}
_
T{
\fBLONG_LONG\fP
T}	T{
\fBDatatype\fP \fBLONG_LONG\fP
T}
_
T{
\fBUNSIGNED_CHAR\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_CHAR\fP
T}
_
T{
\fBUNSIGNED_SHORT\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_SHORT\fP
T}
_
T{
\fBUNSIGNED\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED\fP
T}
_
T{
\fBUNSIGNED_LONG\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_LONG\fP
T}
_
T{
\fBUNSIGNED_LONG_LONG\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_LONG_LONG\fP
T}
_
T{
\fBFLOAT\fP
T}	T{
\fBDatatype\fP \fBFLOAT\fP
T}
_
T{
\fBDOUBLE\fP
T}	T{
\fBDatatype\fP \fBDOUBLE\fP
T}
_
T{
\fBLONG_DOUBLE\fP
T}	T{
\fBDatatype\fP \fBLONG_DOUBLE\fP
T}
_
T{
\fBC_BOOL\fP
T}	T{
\fBDatatype\fP \fBC_BOOL\fP
T}
_
T{
\fBINT8_T\fP
T}	T{
\fBDatatype\fP \fBINT8_T\fP
T}
_
T{
\fBINT16_T\fP
T}	T{
\fBDatatype\fP \fBINT16_T\fP
T}
_
T{
\fBINT32_T\fP
T}	T{
\fBDatatype\fP \fBINT32_T\fP
T}
_
T{
\fBINT64_T\fP
T}	T{
\fBDatatype\fP \fBINT64_T\fP
T}
_
T{
\fBUINT8_T\fP
T}	T{
\fBDatatype\fP \fBUINT8_T\fP
T}
_
T{
\fBUINT16_T\fP
T}	T{
\fBDatatype\fP \fBUINT16_T\fP
T}
_
T{
\fBUINT32_T\fP
T}	T{
\fBDatatype\fP \fBUINT32_T\fP
T}
_
T{
\fBUINT64_T\fP
T}	T{
\fBDatatype\fP \fBUINT64_T\fP
T}
_
T{
\fBC_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBC_COMPLEX\fP
T}
_
T{
\fBC_FLOAT_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBC_FLOAT_COMPLEX\fP
T}
_
T{
\fBC_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBC_DOUBLE_COMPLEX\fP
T}
_
T{
\fBC_LONG_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBC_LONG_DOUBLE_COMPLEX\fP
T}
_
T{
\fBCXX_BOOL\fP
T}	T{
\fBDatatype\fP \fBCXX_BOOL\fP
T}
_
T{
\fBCXX_FLOAT_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBCXX_FLOAT_COMPLEX\fP
T}
_
T{
\fBCXX_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBCXX_DOUBLE_COMPLEX\fP
T}
_
T{
\fBCXX_LONG_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBCXX_LONG_DOUBLE_COMPLEX\fP
T}
_
T{
\fBSHORT_INT\fP
T}	T{
\fBDatatype\fP \fBSHORT_INT\fP
T}
_
T{
\fBINT_INT\fP
T}	T{
\fBDatatype\fP \fBINT_INT\fP
T}
_
T{
\fBTWOINT\fP
T}	T{
\fBDatatype\fP \fBTWOINT\fP
T}
_
T{
\fBLONG_INT\fP
T}	T{
\fBDatatype\fP \fBLONG_INT\fP
T}
_
T{
\fBFLOAT_INT\fP
T}	T{
\fBDatatype\fP \fBFLOAT_INT\fP
T}
_
T{
\fBDOUBLE_INT\fP
T}	T{
\fBDatatype\fP \fBDOUBLE_INT\fP
T}
_
T{
\fBLONG_DOUBLE_INT\fP
T}	T{
\fBDatatype\fP \fBLONG_DOUBLE_INT\fP
T}
_
T{
\fBCHARACTER\fP
T}	T{
\fBDatatype\fP \fBCHARACTER\fP
T}
_
T{
\fBLOGICAL\fP
T}	T{
\fBDatatype\fP \fBLOGICAL\fP
T}
_
T{
\fBINTEGER\fP
T}	T{
\fBDatatype\fP \fBINTEGER\fP
T}
_
T{
\fBREAL\fP
T}	T{
\fBDatatype\fP \fBREAL\fP
T}
_
T{
\fBDOUBLE_PRECISION\fP
T}	T{
\fBDatatype\fP \fBDOUBLE_PRECISION\fP
T}
_
T{
\fBCOMPLEX\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX\fP
T}
_
T{
\fBDOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBDOUBLE_COMPLEX\fP
T}
_
T{
\fBLOGICAL1\fP
T}	T{
\fBDatatype\fP \fBLOGICAL1\fP
T}
_
T{
\fBLOGICAL2\fP
T}	T{
\fBDatatype\fP \fBLOGICAL2\fP
T}
_
T{
\fBLOGICAL4\fP
T}	T{
\fBDatatype\fP \fBLOGICAL4\fP
T}
_
T{
\fBLOGICAL8\fP
T}	T{
\fBDatatype\fP \fBLOGICAL8\fP
T}
_
T{
\fBINTEGER1\fP
T}	T{
\fBDatatype\fP \fBINTEGER1\fP
T}
_
T{
\fBINTEGER2\fP
T}	T{
\fBDatatype\fP \fBINTEGER2\fP
T}
_
T{
\fBINTEGER4\fP
T}	T{
\fBDatatype\fP \fBINTEGER4\fP
T}
_
T{
\fBINTEGER8\fP
T}	T{
\fBDatatype\fP \fBINTEGER8\fP
T}
_
T{
\fBINTEGER16\fP
T}	T{
\fBDatatype\fP \fBINTEGER16\fP
T}
_
T{
\fBREAL2\fP
T}	T{
\fBDatatype\fP \fBREAL2\fP
T}
_
T{
\fBREAL4\fP
T}	T{
\fBDatatype\fP \fBREAL4\fP
T}
_
T{
\fBREAL8\fP
T}	T{
\fBDatatype\fP \fBREAL8\fP
T}
_
T{
\fBREAL16\fP
T}	T{
\fBDatatype\fP \fBREAL16\fP
T}
_
T{
\fBCOMPLEX4\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX4\fP
T}
_
T{
\fBCOMPLEX8\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX8\fP
T}
_
T{
\fBCOMPLEX16\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX16\fP
T}
_
T{
\fBCOMPLEX32\fP
T}	T{
\fBDatatype\fP \fBCOMPLEX32\fP
T}
_
T{
\fBUNSIGNED_INT\fP
T}	T{
\fBDatatype\fP \fBUNSIGNED_INT\fP
T}
_
T{
\fBSIGNED_SHORT\fP
T}	T{
\fBDatatype\fP \fBSIGNED_SHORT\fP
T}
_
T{
\fBSIGNED_INT\fP
T}	T{
\fBDatatype\fP \fBSIGNED_INT\fP
T}
_
T{
\fBSIGNED_LONG\fP
T}	T{
\fBDatatype\fP \fBSIGNED_LONG\fP
T}
_
T{
\fBSIGNED_LONG_LONG\fP
T}	T{
\fBDatatype\fP \fBSIGNED_LONG_LONG\fP
T}
_
T{
\fBBOOL\fP
T}	T{
\fBDatatype\fP \fBBOOL\fP
T}
_
T{
\fBSINT8_T\fP
T}	T{
\fBDatatype\fP \fBSINT8_T\fP
T}
_
T{
\fBSINT16_T\fP
T}	T{
\fBDatatype\fP \fBSINT16_T\fP
T}
_
T{
\fBSINT32_T\fP
T}	T{
\fBDatatype\fP \fBSINT32_T\fP
T}
_
T{
\fBSINT64_T\fP
T}	T{
\fBDatatype\fP \fBSINT64_T\fP
T}
_
T{
\fBF_BOOL\fP
T}	T{
\fBDatatype\fP \fBF_BOOL\fP
T}
_
T{
\fBF_INT\fP
T}	T{
\fBDatatype\fP \fBF_INT\fP
T}
_
T{
\fBF_FLOAT\fP
T}	T{
\fBDatatype\fP \fBF_FLOAT\fP
T}
_
T{
\fBF_DOUBLE\fP
T}	T{
\fBDatatype\fP \fBF_DOUBLE\fP
T}
_
T{
\fBF_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBF_COMPLEX\fP
T}
_
T{
\fBF_FLOAT_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBF_FLOAT_COMPLEX\fP
T}
_
T{
\fBF_DOUBLE_COMPLEX\fP
T}	T{
\fBDatatype\fP \fBF_DOUBLE_COMPLEX\fP
T}
_
T{
\fBREQUEST_NULL\fP
T}	T{
\fBRequest\fP \fBREQUEST_NULL\fP
T}
_
T{
\fBMESSAGE_NULL\fP
T}	T{
\fBMessage\fP \fBMESSAGE_NULL\fP
T}
_
T{
\fBMESSAGE_NO_PROC\fP
T}	T{
\fBMessage\fP \fBMESSAGE_NO_PROC\fP
T}
_
T{
\fBOP_NULL\fP
T}	T{
\fBOp\fP \fBOP_NULL\fP
T}
_
T{
\fBMAX\fP
T}	T{
\fBOp\fP \fBMAX\fP
T}
_
T{
\fBMIN\fP
T}	T{
\fBOp\fP \fBMIN\fP
T}
_
T{
\fBSUM\fP
T}	T{
\fBOp\fP \fBSUM\fP
T}
_
T{
\fBPROD\fP
T}	T{
\fBOp\fP \fBPROD\fP
T}
_
T{
\fBLAND\fP
T}	T{
\fBOp\fP \fBLAND\fP
T}
_
T{
\fBBAND\fP
T}	T{
\fBOp\fP \fBBAND\fP
T}
_
T{
\fBLOR\fP
T}	T{
\fBOp\fP \fBLOR\fP
T}
_
T{
\fBBOR\fP
T}	T{
\fBOp\fP \fBBOR\fP
T}
_
T{
\fBLXOR\fP
T}	T{
\fBOp\fP \fBLXOR\fP
T}
_
T{
\fBBXOR\fP
T}	T{
\fBOp\fP \fBBXOR\fP
T}
_
T{
\fBMAXLOC\fP
T}	T{
\fBOp\fP \fBMAXLOC\fP
T}
_
T{
\fBMINLOC\fP
T}	T{
\fBOp\fP \fBMINLOC\fP
T}
_
T{
\fBREPLACE\fP
T}	T{
\fBOp\fP \fBREPLACE\fP
T}
_
T{
\fBNO_OP\fP
T}	T{
\fBOp\fP \fBNO_OP\fP
T}
_
T{
\fBGROUP_NULL\fP
T}	T{
\fBGroup\fP \fBGROUP_NULL\fP
T}
_
T{
\fBGROUP_EMPTY\fP
T}	T{
\fBGroup\fP \fBGROUP_EMPTY\fP
T}
_
T{
\fBINFO_NULL\fP
T}	T{
\fBInfo\fP \fBINFO_NULL\fP
T}
_
T{
\fBINFO_ENV\fP
T}	T{
\fBInfo\fP \fBINFO_ENV\fP
T}
_
T{
\fBERRHANDLER_NULL\fP
T}	T{
\fBErrhandler\fP \fBERRHANDLER_NULL\fP
T}
_
T{
\fBERRORS_RETURN\fP
T}	T{
\fBErrhandler\fP \fBERRORS_RETURN\fP
T}
_
T{
\fBERRORS_ARE_FATAL\fP
T}	T{
\fBErrhandler\fP \fBERRORS_ARE_FATAL\fP
T}
_
T{
\fBCOMM_NULL\fP
T}	T{
\fBComm\fP \fBCOMM_NULL\fP
T}
_
T{
\fBCOMM_SELF\fP
T}	T{
\fBIntracomm\fP \fBCOMM_SELF\fP
T}
_
T{
\fBCOMM_WORLD\fP
T}	T{
\fBIntracomm\fP \fBCOMM_WORLD\fP
T}
_
T{
\fBWIN_NULL\fP
T}	T{
\fBWin\fP \fBWIN_NULL\fP
T}
_
T{
\fBFILE_NULL\fP
T}	T{
\fBFile\fP \fBFILE_NULL\fP
T}
_
T{
\fBpickle\fP
T}	T{
\fBPickle\fP \fBpickle\fP
T}
_
.TE
.SS mpi4py.MPI.UNDEFINED
.INDENT 0.0
.TP
.B mpi4py.MPI.UNDEFINED:  \fI\%int\fP  =  UNDEFINED
\fI\%int\fP \fBUNDEFINED\fP
.UNINDENT
.SS mpi4py.MPI.ANY_SOURCE
.INDENT 0.0
.TP
.B mpi4py.MPI.ANY_SOURCE:  \fI\%int\fP  =  ANY_SOURCE
\fI\%int\fP \fBANY_SOURCE\fP
.UNINDENT
.SS mpi4py.MPI.ANY_TAG
.INDENT 0.0
.TP
.B mpi4py.MPI.ANY_TAG:  \fI\%int\fP  =  ANY_TAG
\fI\%int\fP \fBANY_TAG\fP
.UNINDENT
.SS mpi4py.MPI.PROC_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.PROC_NULL:  \fI\%int\fP  =  PROC_NULL
\fI\%int\fP \fBPROC_NULL\fP
.UNINDENT
.SS mpi4py.MPI.ROOT
.INDENT 0.0
.TP
.B mpi4py.MPI.ROOT:  \fI\%int\fP  =  ROOT
\fI\%int\fP \fBROOT\fP
.UNINDENT
.SS mpi4py.MPI.BOTTOM
.INDENT 0.0
.TP
.B mpi4py.MPI.BOTTOM:  Bottom  =  BOTTOM
\fBBottom\fP \fBBOTTOM\fP
.UNINDENT
.SS mpi4py.MPI.IN_PLACE
.INDENT 0.0
.TP
.B mpi4py.MPI.IN_PLACE:  InPlace  =  IN_PLACE
\fBInPlace\fP \fBIN_PLACE\fP
.UNINDENT
.SS mpi4py.MPI.KEYVAL_INVALID
.INDENT 0.0
.TP
.B mpi4py.MPI.KEYVAL_INVALID:  \fI\%int\fP  =  KEYVAL_INVALID
\fI\%int\fP \fBKEYVAL_INVALID\fP
.UNINDENT
.SS mpi4py.MPI.TAG_UB
.INDENT 0.0
.TP
.B mpi4py.MPI.TAG_UB:  \fI\%int\fP  =  TAG_UB
\fI\%int\fP \fBTAG_UB\fP
.UNINDENT
.SS mpi4py.MPI.HOST
.INDENT 0.0
.TP
.B mpi4py.MPI.HOST:  \fI\%int\fP  =  HOST
\fI\%int\fP \fBHOST\fP
.UNINDENT
.SS mpi4py.MPI.IO
.INDENT 0.0
.TP
.B mpi4py.MPI.IO:  \fI\%int\fP  =  IO
\fI\%int\fP \fBIO\fP
.UNINDENT
.SS mpi4py.MPI.WTIME_IS_GLOBAL
.INDENT 0.0
.TP
.B mpi4py.MPI.WTIME_IS_GLOBAL:  \fI\%int\fP  =  WTIME_IS_GLOBAL
\fI\%int\fP \fBWTIME_IS_GLOBAL\fP
.UNINDENT
.SS mpi4py.MPI.UNIVERSE_SIZE
.INDENT 0.0
.TP
.B mpi4py.MPI.UNIVERSE_SIZE:  \fI\%int\fP  =  UNIVERSE_SIZE
\fI\%int\fP \fBUNIVERSE_SIZE\fP
.UNINDENT
.SS mpi4py.MPI.APPNUM
.INDENT 0.0
.TP
.B mpi4py.MPI.APPNUM:  \fI\%int\fP  =  APPNUM
\fI\%int\fP \fBAPPNUM\fP
.UNINDENT
.SS mpi4py.MPI.LASTUSEDCODE
.INDENT 0.0
.TP
.B mpi4py.MPI.LASTUSEDCODE:  \fI\%int\fP  =  LASTUSEDCODE
\fI\%int\fP \fBLASTUSEDCODE\fP
.UNINDENT
.SS mpi4py.MPI.WIN_BASE
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_BASE:  \fI\%int\fP  =  WIN_BASE
\fI\%int\fP \fBWIN_BASE\fP
.UNINDENT
.SS mpi4py.MPI.WIN_SIZE
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_SIZE:  \fI\%int\fP  =  WIN_SIZE
\fI\%int\fP \fBWIN_SIZE\fP
.UNINDENT
.SS mpi4py.MPI.WIN_DISP_UNIT
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_DISP_UNIT:  \fI\%int\fP  =  WIN_DISP_UNIT
\fI\%int\fP \fBWIN_DISP_UNIT\fP
.UNINDENT
.SS mpi4py.MPI.WIN_CREATE_FLAVOR
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_CREATE_FLAVOR:  \fI\%int\fP  =  WIN_CREATE_FLAVOR
\fI\%int\fP \fBWIN_CREATE_FLAVOR\fP
.UNINDENT
.SS mpi4py.MPI.WIN_FLAVOR
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_FLAVOR:  \fI\%int\fP  =  WIN_FLAVOR
\fI\%int\fP \fBWIN_FLAVOR\fP
.UNINDENT
.SS mpi4py.MPI.WIN_MODEL
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_MODEL:  \fI\%int\fP  =  WIN_MODEL
\fI\%int\fP \fBWIN_MODEL\fP
.UNINDENT
.SS mpi4py.MPI.SUCCESS
.INDENT 0.0
.TP
.B mpi4py.MPI.SUCCESS:  \fI\%int\fP  =  SUCCESS
\fI\%int\fP \fBSUCCESS\fP
.UNINDENT
.SS mpi4py.MPI.ERR_LASTCODE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_LASTCODE:  \fI\%int\fP  =  ERR_LASTCODE
\fI\%int\fP \fBERR_LASTCODE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_COMM
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_COMM:  \fI\%int\fP  =  ERR_COMM
\fI\%int\fP \fBERR_COMM\fP
.UNINDENT
.SS mpi4py.MPI.ERR_GROUP
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_GROUP:  \fI\%int\fP  =  ERR_GROUP
\fI\%int\fP \fBERR_GROUP\fP
.UNINDENT
.SS mpi4py.MPI.ERR_TYPE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_TYPE:  \fI\%int\fP  =  ERR_TYPE
\fI\%int\fP \fBERR_TYPE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_REQUEST
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_REQUEST:  \fI\%int\fP  =  ERR_REQUEST
\fI\%int\fP \fBERR_REQUEST\fP
.UNINDENT
.SS mpi4py.MPI.ERR_OP
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_OP:  \fI\%int\fP  =  ERR_OP
\fI\%int\fP \fBERR_OP\fP
.UNINDENT
.SS mpi4py.MPI.ERR_BUFFER
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_BUFFER:  \fI\%int\fP  =  ERR_BUFFER
\fI\%int\fP \fBERR_BUFFER\fP
.UNINDENT
.SS mpi4py.MPI.ERR_COUNT
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_COUNT:  \fI\%int\fP  =  ERR_COUNT
\fI\%int\fP \fBERR_COUNT\fP
.UNINDENT
.SS mpi4py.MPI.ERR_TAG
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_TAG:  \fI\%int\fP  =  ERR_TAG
\fI\%int\fP \fBERR_TAG\fP
.UNINDENT
.SS mpi4py.MPI.ERR_RANK
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_RANK:  \fI\%int\fP  =  ERR_RANK
\fI\%int\fP \fBERR_RANK\fP
.UNINDENT
.SS mpi4py.MPI.ERR_ROOT
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_ROOT:  \fI\%int\fP  =  ERR_ROOT
\fI\%int\fP \fBERR_ROOT\fP
.UNINDENT
.SS mpi4py.MPI.ERR_TRUNCATE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_TRUNCATE:  \fI\%int\fP  =  ERR_TRUNCATE
\fI\%int\fP \fBERR_TRUNCATE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_IN_STATUS
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_IN_STATUS:  \fI\%int\fP  =  ERR_IN_STATUS
\fI\%int\fP \fBERR_IN_STATUS\fP
.UNINDENT
.SS mpi4py.MPI.ERR_PENDING
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_PENDING:  \fI\%int\fP  =  ERR_PENDING
\fI\%int\fP \fBERR_PENDING\fP
.UNINDENT
.SS mpi4py.MPI.ERR_TOPOLOGY
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_TOPOLOGY:  \fI\%int\fP  =  ERR_TOPOLOGY
\fI\%int\fP \fBERR_TOPOLOGY\fP
.UNINDENT
.SS mpi4py.MPI.ERR_DIMS
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_DIMS:  \fI\%int\fP  =  ERR_DIMS
\fI\%int\fP \fBERR_DIMS\fP
.UNINDENT
.SS mpi4py.MPI.ERR_ARG
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_ARG:  \fI\%int\fP  =  ERR_ARG
\fI\%int\fP \fBERR_ARG\fP
.UNINDENT
.SS mpi4py.MPI.ERR_OTHER
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_OTHER:  \fI\%int\fP  =  ERR_OTHER
\fI\%int\fP \fBERR_OTHER\fP
.UNINDENT
.SS mpi4py.MPI.ERR_UNKNOWN
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_UNKNOWN:  \fI\%int\fP  =  ERR_UNKNOWN
\fI\%int\fP \fBERR_UNKNOWN\fP
.UNINDENT
.SS mpi4py.MPI.ERR_INTERN
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_INTERN:  \fI\%int\fP  =  ERR_INTERN
\fI\%int\fP \fBERR_INTERN\fP
.UNINDENT
.SS mpi4py.MPI.ERR_INFO
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_INFO:  \fI\%int\fP  =  ERR_INFO
\fI\%int\fP \fBERR_INFO\fP
.UNINDENT
.SS mpi4py.MPI.ERR_FILE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_FILE:  \fI\%int\fP  =  ERR_FILE
\fI\%int\fP \fBERR_FILE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_WIN
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_WIN:  \fI\%int\fP  =  ERR_WIN
\fI\%int\fP \fBERR_WIN\fP
.UNINDENT
.SS mpi4py.MPI.ERR_KEYVAL
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_KEYVAL:  \fI\%int\fP  =  ERR_KEYVAL
\fI\%int\fP \fBERR_KEYVAL\fP
.UNINDENT
.SS mpi4py.MPI.ERR_INFO_KEY
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_INFO_KEY:  \fI\%int\fP  =  ERR_INFO_KEY
\fI\%int\fP \fBERR_INFO_KEY\fP
.UNINDENT
.SS mpi4py.MPI.ERR_INFO_VALUE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_INFO_VALUE:  \fI\%int\fP  =  ERR_INFO_VALUE
\fI\%int\fP \fBERR_INFO_VALUE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_INFO_NOKEY
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_INFO_NOKEY:  \fI\%int\fP  =  ERR_INFO_NOKEY
\fI\%int\fP \fBERR_INFO_NOKEY\fP
.UNINDENT
.SS mpi4py.MPI.ERR_ACCESS
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_ACCESS:  \fI\%int\fP  =  ERR_ACCESS
\fI\%int\fP \fBERR_ACCESS\fP
.UNINDENT
.SS mpi4py.MPI.ERR_AMODE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_AMODE:  \fI\%int\fP  =  ERR_AMODE
\fI\%int\fP \fBERR_AMODE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_BAD_FILE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_BAD_FILE:  \fI\%int\fP  =  ERR_BAD_FILE
\fI\%int\fP \fBERR_BAD_FILE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_FILE_EXISTS
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_FILE_EXISTS:  \fI\%int\fP  =  ERR_FILE_EXISTS
\fI\%int\fP \fBERR_FILE_EXISTS\fP
.UNINDENT
.SS mpi4py.MPI.ERR_FILE_IN_USE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_FILE_IN_USE:  \fI\%int\fP  =  ERR_FILE_IN_USE
\fI\%int\fP \fBERR_FILE_IN_USE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_NO_SPACE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_NO_SPACE:  \fI\%int\fP  =  ERR_NO_SPACE
\fI\%int\fP \fBERR_NO_SPACE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_NO_SUCH_FILE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_NO_SUCH_FILE:  \fI\%int\fP  =  ERR_NO_SUCH_FILE
\fI\%int\fP \fBERR_NO_SUCH_FILE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_IO
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_IO:  \fI\%int\fP  =  ERR_IO
\fI\%int\fP \fBERR_IO\fP
.UNINDENT
.SS mpi4py.MPI.ERR_READ_ONLY
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_READ_ONLY:  \fI\%int\fP  =  ERR_READ_ONLY
\fI\%int\fP \fBERR_READ_ONLY\fP
.UNINDENT
.SS mpi4py.MPI.ERR_CONVERSION
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_CONVERSION:  \fI\%int\fP  =  ERR_CONVERSION
\fI\%int\fP \fBERR_CONVERSION\fP
.UNINDENT
.SS mpi4py.MPI.ERR_DUP_DATAREP
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_DUP_DATAREP:  \fI\%int\fP  =  ERR_DUP_DATAREP
\fI\%int\fP \fBERR_DUP_DATAREP\fP
.UNINDENT
.SS mpi4py.MPI.ERR_UNSUPPORTED_DATAREP
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_UNSUPPORTED_DATAREP:  \fI\%int\fP  =  ERR_UNSUPPORTED_DATAREP
\fI\%int\fP \fBERR_UNSUPPORTED_DATAREP\fP
.UNINDENT
.SS mpi4py.MPI.ERR_UNSUPPORTED_OPERATION
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_UNSUPPORTED_OPERATION:  \fI\%int\fP  =  ERR_UNSUPPORTED_OPERATION
\fI\%int\fP \fBERR_UNSUPPORTED_OPERATION\fP
.UNINDENT
.SS mpi4py.MPI.ERR_NAME
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_NAME:  \fI\%int\fP  =  ERR_NAME
\fI\%int\fP \fBERR_NAME\fP
.UNINDENT
.SS mpi4py.MPI.ERR_NO_MEM
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_NO_MEM:  \fI\%int\fP  =  ERR_NO_MEM
\fI\%int\fP \fBERR_NO_MEM\fP
.UNINDENT
.SS mpi4py.MPI.ERR_NOT_SAME
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_NOT_SAME:  \fI\%int\fP  =  ERR_NOT_SAME
\fI\%int\fP \fBERR_NOT_SAME\fP
.UNINDENT
.SS mpi4py.MPI.ERR_PORT
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_PORT:  \fI\%int\fP  =  ERR_PORT
\fI\%int\fP \fBERR_PORT\fP
.UNINDENT
.SS mpi4py.MPI.ERR_QUOTA
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_QUOTA:  \fI\%int\fP  =  ERR_QUOTA
\fI\%int\fP \fBERR_QUOTA\fP
.UNINDENT
.SS mpi4py.MPI.ERR_SERVICE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_SERVICE:  \fI\%int\fP  =  ERR_SERVICE
\fI\%int\fP \fBERR_SERVICE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_SPAWN
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_SPAWN:  \fI\%int\fP  =  ERR_SPAWN
\fI\%int\fP \fBERR_SPAWN\fP
.UNINDENT
.SS mpi4py.MPI.ERR_BASE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_BASE:  \fI\%int\fP  =  ERR_BASE
\fI\%int\fP \fBERR_BASE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_SIZE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_SIZE:  \fI\%int\fP  =  ERR_SIZE
\fI\%int\fP \fBERR_SIZE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_DISP
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_DISP:  \fI\%int\fP  =  ERR_DISP
\fI\%int\fP \fBERR_DISP\fP
.UNINDENT
.SS mpi4py.MPI.ERR_ASSERT
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_ASSERT:  \fI\%int\fP  =  ERR_ASSERT
\fI\%int\fP \fBERR_ASSERT\fP
.UNINDENT
.SS mpi4py.MPI.ERR_LOCKTYPE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_LOCKTYPE:  \fI\%int\fP  =  ERR_LOCKTYPE
\fI\%int\fP \fBERR_LOCKTYPE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_RMA_CONFLICT
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_RMA_CONFLICT:  \fI\%int\fP  =  ERR_RMA_CONFLICT
\fI\%int\fP \fBERR_RMA_CONFLICT\fP
.UNINDENT
.SS mpi4py.MPI.ERR_RMA_SYNC
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_RMA_SYNC:  \fI\%int\fP  =  ERR_RMA_SYNC
\fI\%int\fP \fBERR_RMA_SYNC\fP
.UNINDENT
.SS mpi4py.MPI.ERR_RMA_RANGE
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_RMA_RANGE:  \fI\%int\fP  =  ERR_RMA_RANGE
\fI\%int\fP \fBERR_RMA_RANGE\fP
.UNINDENT
.SS mpi4py.MPI.ERR_RMA_ATTACH
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_RMA_ATTACH:  \fI\%int\fP  =  ERR_RMA_ATTACH
\fI\%int\fP \fBERR_RMA_ATTACH\fP
.UNINDENT
.SS mpi4py.MPI.ERR_RMA_SHARED
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_RMA_SHARED:  \fI\%int\fP  =  ERR_RMA_SHARED
\fI\%int\fP \fBERR_RMA_SHARED\fP
.UNINDENT
.SS mpi4py.MPI.ERR_RMA_FLAVOR
.INDENT 0.0
.TP
.B mpi4py.MPI.ERR_RMA_FLAVOR:  \fI\%int\fP  =  ERR_RMA_FLAVOR
\fI\%int\fP \fBERR_RMA_FLAVOR\fP
.UNINDENT
.SS mpi4py.MPI.ORDER_C
.INDENT 0.0
.TP
.B mpi4py.MPI.ORDER_C:  \fI\%int\fP  =  ORDER_C
\fI\%int\fP \fBORDER_C\fP
.UNINDENT
.SS mpi4py.MPI.ORDER_FORTRAN
.INDENT 0.0
.TP
.B mpi4py.MPI.ORDER_FORTRAN:  \fI\%int\fP  =  ORDER_FORTRAN
\fI\%int\fP \fBORDER_FORTRAN\fP
.UNINDENT
.SS mpi4py.MPI.ORDER_F
.INDENT 0.0
.TP
.B mpi4py.MPI.ORDER_F:  \fI\%int\fP  =  ORDER_F
\fI\%int\fP \fBORDER_F\fP
.UNINDENT
.SS mpi4py.MPI.TYPECLASS_INTEGER
.INDENT 0.0
.TP
.B mpi4py.MPI.TYPECLASS_INTEGER:  \fI\%int\fP  =  TYPECLASS_INTEGER
\fI\%int\fP \fBTYPECLASS_INTEGER\fP
.UNINDENT
.SS mpi4py.MPI.TYPECLASS_REAL
.INDENT 0.0
.TP
.B mpi4py.MPI.TYPECLASS_REAL:  \fI\%int\fP  =  TYPECLASS_REAL
\fI\%int\fP \fBTYPECLASS_REAL\fP
.UNINDENT
.SS mpi4py.MPI.TYPECLASS_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.TYPECLASS_COMPLEX:  \fI\%int\fP  =  TYPECLASS_COMPLEX
\fI\%int\fP \fBTYPECLASS_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.DISTRIBUTE_NONE
.INDENT 0.0
.TP
.B mpi4py.MPI.DISTRIBUTE_NONE:  \fI\%int\fP  =  DISTRIBUTE_NONE
\fI\%int\fP \fBDISTRIBUTE_NONE\fP
.UNINDENT
.SS mpi4py.MPI.DISTRIBUTE_BLOCK
.INDENT 0.0
.TP
.B mpi4py.MPI.DISTRIBUTE_BLOCK:  \fI\%int\fP  =  DISTRIBUTE_BLOCK
\fI\%int\fP \fBDISTRIBUTE_BLOCK\fP
.UNINDENT
.SS mpi4py.MPI.DISTRIBUTE_CYCLIC
.INDENT 0.0
.TP
.B mpi4py.MPI.DISTRIBUTE_CYCLIC:  \fI\%int\fP  =  DISTRIBUTE_CYCLIC
\fI\%int\fP \fBDISTRIBUTE_CYCLIC\fP
.UNINDENT
.SS mpi4py.MPI.DISTRIBUTE_DFLT_DARG
.INDENT 0.0
.TP
.B mpi4py.MPI.DISTRIBUTE_DFLT_DARG:  \fI\%int\fP  =  DISTRIBUTE_DFLT_DARG
\fI\%int\fP \fBDISTRIBUTE_DFLT_DARG\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_NAMED
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_NAMED:  \fI\%int\fP  =  COMBINER_NAMED
\fI\%int\fP \fBCOMBINER_NAMED\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_DUP
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_DUP:  \fI\%int\fP  =  COMBINER_DUP
\fI\%int\fP \fBCOMBINER_DUP\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_CONTIGUOUS
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_CONTIGUOUS:  \fI\%int\fP  =  COMBINER_CONTIGUOUS
\fI\%int\fP \fBCOMBINER_CONTIGUOUS\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_VECTOR
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_VECTOR:  \fI\%int\fP  =  COMBINER_VECTOR
\fI\%int\fP \fBCOMBINER_VECTOR\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_HVECTOR
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_HVECTOR:  \fI\%int\fP  =  COMBINER_HVECTOR
\fI\%int\fP \fBCOMBINER_HVECTOR\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_INDEXED
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_INDEXED:  \fI\%int\fP  =  COMBINER_INDEXED
\fI\%int\fP \fBCOMBINER_INDEXED\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_HINDEXED
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_HINDEXED:  \fI\%int\fP  =  COMBINER_HINDEXED
\fI\%int\fP \fBCOMBINER_HINDEXED\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_INDEXED_BLOCK
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_INDEXED_BLOCK:  \fI\%int\fP  =  COMBINER_INDEXED_BLOCK
\fI\%int\fP \fBCOMBINER_INDEXED_BLOCK\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_HINDEXED_BLOCK
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_HINDEXED_BLOCK:  \fI\%int\fP  =  COMBINER_HINDEXED_BLOCK
\fI\%int\fP \fBCOMBINER_HINDEXED_BLOCK\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_STRUCT
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_STRUCT:  \fI\%int\fP  =  COMBINER_STRUCT
\fI\%int\fP \fBCOMBINER_STRUCT\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_SUBARRAY
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_SUBARRAY:  \fI\%int\fP  =  COMBINER_SUBARRAY
\fI\%int\fP \fBCOMBINER_SUBARRAY\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_DARRAY
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_DARRAY:  \fI\%int\fP  =  COMBINER_DARRAY
\fI\%int\fP \fBCOMBINER_DARRAY\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_RESIZED
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_RESIZED:  \fI\%int\fP  =  COMBINER_RESIZED
\fI\%int\fP \fBCOMBINER_RESIZED\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_F90_REAL
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_F90_REAL:  \fI\%int\fP  =  COMBINER_F90_REAL
\fI\%int\fP \fBCOMBINER_F90_REAL\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_F90_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_F90_COMPLEX:  \fI\%int\fP  =  COMBINER_F90_COMPLEX
\fI\%int\fP \fBCOMBINER_F90_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.COMBINER_F90_INTEGER
.INDENT 0.0
.TP
.B mpi4py.MPI.COMBINER_F90_INTEGER:  \fI\%int\fP  =  COMBINER_F90_INTEGER
\fI\%int\fP \fBCOMBINER_F90_INTEGER\fP
.UNINDENT
.SS mpi4py.MPI.IDENT
.INDENT 0.0
.TP
.B mpi4py.MPI.IDENT:  \fI\%int\fP  =  IDENT
\fI\%int\fP \fBIDENT\fP
.UNINDENT
.SS mpi4py.MPI.CONGRUENT
.INDENT 0.0
.TP
.B mpi4py.MPI.CONGRUENT:  \fI\%int\fP  =  CONGRUENT
\fI\%int\fP \fBCONGRUENT\fP
.UNINDENT
.SS mpi4py.MPI.SIMILAR
.INDENT 0.0
.TP
.B mpi4py.MPI.SIMILAR:  \fI\%int\fP  =  SIMILAR
\fI\%int\fP \fBSIMILAR\fP
.UNINDENT
.SS mpi4py.MPI.UNEQUAL
.INDENT 0.0
.TP
.B mpi4py.MPI.UNEQUAL:  \fI\%int\fP  =  UNEQUAL
\fI\%int\fP \fBUNEQUAL\fP
.UNINDENT
.SS mpi4py.MPI.CART
.INDENT 0.0
.TP
.B mpi4py.MPI.CART:  \fI\%int\fP  =  CART
\fI\%int\fP \fBCART\fP
.UNINDENT
.SS mpi4py.MPI.GRAPH
.INDENT 0.0
.TP
.B mpi4py.MPI.GRAPH:  \fI\%int\fP  =  GRAPH
\fI\%int\fP \fBGRAPH\fP
.UNINDENT
.SS mpi4py.MPI.DIST_GRAPH
.INDENT 0.0
.TP
.B mpi4py.MPI.DIST_GRAPH:  \fI\%int\fP  =  DIST_GRAPH
\fI\%int\fP \fBDIST_GRAPH\fP
.UNINDENT
.SS mpi4py.MPI.UNWEIGHTED
.INDENT 0.0
.TP
.B mpi4py.MPI.UNWEIGHTED:  \fI\%int\fP  =  UNWEIGHTED
\fI\%int\fP \fBUNWEIGHTED\fP
.UNINDENT
.SS mpi4py.MPI.WEIGHTS_EMPTY
.INDENT 0.0
.TP
.B mpi4py.MPI.WEIGHTS_EMPTY:  \fI\%int\fP  =  WEIGHTS_EMPTY
\fI\%int\fP \fBWEIGHTS_EMPTY\fP
.UNINDENT
.SS mpi4py.MPI.COMM_TYPE_SHARED
.INDENT 0.0
.TP
.B mpi4py.MPI.COMM_TYPE_SHARED:  \fI\%int\fP  =  COMM_TYPE_SHARED
\fI\%int\fP \fBCOMM_TYPE_SHARED\fP
.UNINDENT
.SS mpi4py.MPI.BSEND_OVERHEAD
.INDENT 0.0
.TP
.B mpi4py.MPI.BSEND_OVERHEAD:  \fI\%int\fP  =  BSEND_OVERHEAD
\fI\%int\fP \fBBSEND_OVERHEAD\fP
.UNINDENT
.SS mpi4py.MPI.WIN_FLAVOR_CREATE
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_FLAVOR_CREATE:  \fI\%int\fP  =  WIN_FLAVOR_CREATE
\fI\%int\fP \fBWIN_FLAVOR_CREATE\fP
.UNINDENT
.SS mpi4py.MPI.WIN_FLAVOR_ALLOCATE
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_FLAVOR_ALLOCATE:  \fI\%int\fP  =  WIN_FLAVOR_ALLOCATE
\fI\%int\fP \fBWIN_FLAVOR_ALLOCATE\fP
.UNINDENT
.SS mpi4py.MPI.WIN_FLAVOR_DYNAMIC
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_FLAVOR_DYNAMIC:  \fI\%int\fP  =  WIN_FLAVOR_DYNAMIC
\fI\%int\fP \fBWIN_FLAVOR_DYNAMIC\fP
.UNINDENT
.SS mpi4py.MPI.WIN_FLAVOR_SHARED
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_FLAVOR_SHARED:  \fI\%int\fP  =  WIN_FLAVOR_SHARED
\fI\%int\fP \fBWIN_FLAVOR_SHARED\fP
.UNINDENT
.SS mpi4py.MPI.WIN_SEPARATE
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_SEPARATE:  \fI\%int\fP  =  WIN_SEPARATE
\fI\%int\fP \fBWIN_SEPARATE\fP
.UNINDENT
.SS mpi4py.MPI.WIN_UNIFIED
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_UNIFIED:  \fI\%int\fP  =  WIN_UNIFIED
\fI\%int\fP \fBWIN_UNIFIED\fP
.UNINDENT
.SS mpi4py.MPI.MODE_NOCHECK
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_NOCHECK:  \fI\%int\fP  =  MODE_NOCHECK
\fI\%int\fP \fBMODE_NOCHECK\fP
.UNINDENT
.SS mpi4py.MPI.MODE_NOSTORE
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_NOSTORE:  \fI\%int\fP  =  MODE_NOSTORE
\fI\%int\fP \fBMODE_NOSTORE\fP
.UNINDENT
.SS mpi4py.MPI.MODE_NOPUT
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_NOPUT:  \fI\%int\fP  =  MODE_NOPUT
\fI\%int\fP \fBMODE_NOPUT\fP
.UNINDENT
.SS mpi4py.MPI.MODE_NOPRECEDE
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_NOPRECEDE:  \fI\%int\fP  =  MODE_NOPRECEDE
\fI\%int\fP \fBMODE_NOPRECEDE\fP
.UNINDENT
.SS mpi4py.MPI.MODE_NOSUCCEED
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_NOSUCCEED:  \fI\%int\fP  =  MODE_NOSUCCEED
\fI\%int\fP \fBMODE_NOSUCCEED\fP
.UNINDENT
.SS mpi4py.MPI.LOCK_EXCLUSIVE
.INDENT 0.0
.TP
.B mpi4py.MPI.LOCK_EXCLUSIVE:  \fI\%int\fP  =  LOCK_EXCLUSIVE
\fI\%int\fP \fBLOCK_EXCLUSIVE\fP
.UNINDENT
.SS mpi4py.MPI.LOCK_SHARED
.INDENT 0.0
.TP
.B mpi4py.MPI.LOCK_SHARED:  \fI\%int\fP  =  LOCK_SHARED
\fI\%int\fP \fBLOCK_SHARED\fP
.UNINDENT
.SS mpi4py.MPI.MODE_RDONLY
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_RDONLY:  \fI\%int\fP  =  MODE_RDONLY
\fI\%int\fP \fBMODE_RDONLY\fP
.UNINDENT
.SS mpi4py.MPI.MODE_WRONLY
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_WRONLY:  \fI\%int\fP  =  MODE_WRONLY
\fI\%int\fP \fBMODE_WRONLY\fP
.UNINDENT
.SS mpi4py.MPI.MODE_RDWR
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_RDWR:  \fI\%int\fP  =  MODE_RDWR
\fI\%int\fP \fBMODE_RDWR\fP
.UNINDENT
.SS mpi4py.MPI.MODE_CREATE
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_CREATE:  \fI\%int\fP  =  MODE_CREATE
\fI\%int\fP \fBMODE_CREATE\fP
.UNINDENT
.SS mpi4py.MPI.MODE_EXCL
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_EXCL:  \fI\%int\fP  =  MODE_EXCL
\fI\%int\fP \fBMODE_EXCL\fP
.UNINDENT
.SS mpi4py.MPI.MODE_DELETE_ON_CLOSE
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_DELETE_ON_CLOSE:  \fI\%int\fP  =  MODE_DELETE_ON_CLOSE
\fI\%int\fP \fBMODE_DELETE_ON_CLOSE\fP
.UNINDENT
.SS mpi4py.MPI.MODE_UNIQUE_OPEN
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_UNIQUE_OPEN:  \fI\%int\fP  =  MODE_UNIQUE_OPEN
\fI\%int\fP \fBMODE_UNIQUE_OPEN\fP
.UNINDENT
.SS mpi4py.MPI.MODE_SEQUENTIAL
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_SEQUENTIAL:  \fI\%int\fP  =  MODE_SEQUENTIAL
\fI\%int\fP \fBMODE_SEQUENTIAL\fP
.UNINDENT
.SS mpi4py.MPI.MODE_APPEND
.INDENT 0.0
.TP
.B mpi4py.MPI.MODE_APPEND:  \fI\%int\fP  =  MODE_APPEND
\fI\%int\fP \fBMODE_APPEND\fP
.UNINDENT
.SS mpi4py.MPI.SEEK_SET
.INDENT 0.0
.TP
.B mpi4py.MPI.SEEK_SET:  \fI\%int\fP  =  SEEK_SET
\fI\%int\fP \fBSEEK_SET\fP
.UNINDENT
.SS mpi4py.MPI.SEEK_CUR
.INDENT 0.0
.TP
.B mpi4py.MPI.SEEK_CUR:  \fI\%int\fP  =  SEEK_CUR
\fI\%int\fP \fBSEEK_CUR\fP
.UNINDENT
.SS mpi4py.MPI.SEEK_END
.INDENT 0.0
.TP
.B mpi4py.MPI.SEEK_END:  \fI\%int\fP  =  SEEK_END
\fI\%int\fP \fBSEEK_END\fP
.UNINDENT
.SS mpi4py.MPI.DISPLACEMENT_CURRENT
.INDENT 0.0
.TP
.B mpi4py.MPI.DISPLACEMENT_CURRENT:  \fI\%int\fP  =  DISPLACEMENT_CURRENT
\fI\%int\fP \fBDISPLACEMENT_CURRENT\fP
.UNINDENT
.SS mpi4py.MPI.DISP_CUR
.INDENT 0.0
.TP
.B mpi4py.MPI.DISP_CUR:  \fI\%int\fP  =  DISP_CUR
\fI\%int\fP \fBDISP_CUR\fP
.UNINDENT
.SS mpi4py.MPI.THREAD_SINGLE
.INDENT 0.0
.TP
.B mpi4py.MPI.THREAD_SINGLE:  \fI\%int\fP  =  THREAD_SINGLE
\fI\%int\fP \fBTHREAD_SINGLE\fP
.UNINDENT
.SS mpi4py.MPI.THREAD_FUNNELED
.INDENT 0.0
.TP
.B mpi4py.MPI.THREAD_FUNNELED:  \fI\%int\fP  =  THREAD_FUNNELED
\fI\%int\fP \fBTHREAD_FUNNELED\fP
.UNINDENT
.SS mpi4py.MPI.THREAD_SERIALIZED
.INDENT 0.0
.TP
.B mpi4py.MPI.THREAD_SERIALIZED:  \fI\%int\fP  =  THREAD_SERIALIZED
\fI\%int\fP \fBTHREAD_SERIALIZED\fP
.UNINDENT
.SS mpi4py.MPI.THREAD_MULTIPLE
.INDENT 0.0
.TP
.B mpi4py.MPI.THREAD_MULTIPLE:  \fI\%int\fP  =  THREAD_MULTIPLE
\fI\%int\fP \fBTHREAD_MULTIPLE\fP
.UNINDENT
.SS mpi4py.MPI.VERSION
.INDENT 0.0
.TP
.B mpi4py.MPI.VERSION:  \fI\%int\fP  =  VERSION
\fI\%int\fP \fBVERSION\fP
.UNINDENT
.SS mpi4py.MPI.SUBVERSION
.INDENT 0.0
.TP
.B mpi4py.MPI.SUBVERSION:  \fI\%int\fP  =  SUBVERSION
\fI\%int\fP \fBSUBVERSION\fP
.UNINDENT
.SS mpi4py.MPI.MAX_PROCESSOR_NAME
.INDENT 0.0
.TP
.B mpi4py.MPI.MAX_PROCESSOR_NAME:  \fI\%int\fP  =  MAX_PROCESSOR_NAME
\fI\%int\fP \fBMAX_PROCESSOR_NAME\fP
.UNINDENT
.SS mpi4py.MPI.MAX_ERROR_STRING
.INDENT 0.0
.TP
.B mpi4py.MPI.MAX_ERROR_STRING:  \fI\%int\fP  =  MAX_ERROR_STRING
\fI\%int\fP \fBMAX_ERROR_STRING\fP
.UNINDENT
.SS mpi4py.MPI.MAX_PORT_NAME
.INDENT 0.0
.TP
.B mpi4py.MPI.MAX_PORT_NAME:  \fI\%int\fP  =  MAX_PORT_NAME
\fI\%int\fP \fBMAX_PORT_NAME\fP
.UNINDENT
.SS mpi4py.MPI.MAX_INFO_KEY
.INDENT 0.0
.TP
.B mpi4py.MPI.MAX_INFO_KEY:  \fI\%int\fP  =  MAX_INFO_KEY
\fI\%int\fP \fBMAX_INFO_KEY\fP
.UNINDENT
.SS mpi4py.MPI.MAX_INFO_VAL
.INDENT 0.0
.TP
.B mpi4py.MPI.MAX_INFO_VAL:  \fI\%int\fP  =  MAX_INFO_VAL
\fI\%int\fP \fBMAX_INFO_VAL\fP
.UNINDENT
.SS mpi4py.MPI.MAX_OBJECT_NAME
.INDENT 0.0
.TP
.B mpi4py.MPI.MAX_OBJECT_NAME:  \fI\%int\fP  =  MAX_OBJECT_NAME
\fI\%int\fP \fBMAX_OBJECT_NAME\fP
.UNINDENT
.SS mpi4py.MPI.MAX_DATAREP_STRING
.INDENT 0.0
.TP
.B mpi4py.MPI.MAX_DATAREP_STRING:  \fI\%int\fP  =  MAX_DATAREP_STRING
\fI\%int\fP \fBMAX_DATAREP_STRING\fP
.UNINDENT
.SS mpi4py.MPI.MAX_LIBRARY_VERSION_STRING
.INDENT 0.0
.TP
.B mpi4py.MPI.MAX_LIBRARY_VERSION_STRING:  \fI\%int\fP  =  MAX_LIBRARY_VERSION_STRING
\fI\%int\fP \fBMAX_LIBRARY_VERSION_STRING\fP
.UNINDENT
.SS mpi4py.MPI.DATATYPE_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.DATATYPE_NULL:  Datatype  =  DATATYPE_NULL
\fBDatatype\fP \fBDATATYPE_NULL\fP
.UNINDENT
.SS mpi4py.MPI.UB
.INDENT 0.0
.TP
.B mpi4py.MPI.UB:  Datatype  =  UB
\fBDatatype\fP \fBUB\fP
.UNINDENT
.SS mpi4py.MPI.LB
.INDENT 0.0
.TP
.B mpi4py.MPI.LB:  Datatype  =  LB
\fBDatatype\fP \fBLB\fP
.UNINDENT
.SS mpi4py.MPI.PACKED
.INDENT 0.0
.TP
.B mpi4py.MPI.PACKED:  Datatype  =  PACKED
\fBDatatype\fP \fBPACKED\fP
.UNINDENT
.SS mpi4py.MPI.BYTE
.INDENT 0.0
.TP
.B mpi4py.MPI.BYTE:  Datatype  =  BYTE
\fBDatatype\fP \fBBYTE\fP
.UNINDENT
.SS mpi4py.MPI.AINT
.INDENT 0.0
.TP
.B mpi4py.MPI.AINT:  Datatype  =  AINT
\fBDatatype\fP \fBAINT\fP
.UNINDENT
.SS mpi4py.MPI.OFFSET
.INDENT 0.0
.TP
.B mpi4py.MPI.OFFSET:  Datatype  =  OFFSET
\fBDatatype\fP \fBOFFSET\fP
.UNINDENT
.SS mpi4py.MPI.COUNT
.INDENT 0.0
.TP
.B mpi4py.MPI.COUNT:  Datatype  =  COUNT
\fBDatatype\fP \fBCOUNT\fP
.UNINDENT
.SS mpi4py.MPI.CHAR
.INDENT 0.0
.TP
.B mpi4py.MPI.CHAR:  Datatype  =  CHAR
\fBDatatype\fP \fBCHAR\fP
.UNINDENT
.SS mpi4py.MPI.WCHAR
.INDENT 0.0
.TP
.B mpi4py.MPI.WCHAR:  Datatype  =  WCHAR
\fBDatatype\fP \fBWCHAR\fP
.UNINDENT
.SS mpi4py.MPI.SIGNED_CHAR
.INDENT 0.0
.TP
.B mpi4py.MPI.SIGNED_CHAR:  Datatype  =  SIGNED_CHAR
\fBDatatype\fP \fBSIGNED_CHAR\fP
.UNINDENT
.SS mpi4py.MPI.SHORT
.INDENT 0.0
.TP
.B mpi4py.MPI.SHORT:  Datatype  =  SHORT
\fBDatatype\fP \fBSHORT\fP
.UNINDENT
.SS mpi4py.MPI.INT
.INDENT 0.0
.TP
.B mpi4py.MPI.INT:  Datatype  =  INT
\fBDatatype\fP \fBINT\fP
.UNINDENT
.SS mpi4py.MPI.LONG
.INDENT 0.0
.TP
.B mpi4py.MPI.LONG:  Datatype  =  LONG
\fBDatatype\fP \fBLONG\fP
.UNINDENT
.SS mpi4py.MPI.LONG_LONG
.INDENT 0.0
.TP
.B mpi4py.MPI.LONG_LONG:  Datatype  =  LONG_LONG
\fBDatatype\fP \fBLONG_LONG\fP
.UNINDENT
.SS mpi4py.MPI.UNSIGNED_CHAR
.INDENT 0.0
.TP
.B mpi4py.MPI.UNSIGNED_CHAR:  Datatype  =  UNSIGNED_CHAR
\fBDatatype\fP \fBUNSIGNED_CHAR\fP
.UNINDENT
.SS mpi4py.MPI.UNSIGNED_SHORT
.INDENT 0.0
.TP
.B mpi4py.MPI.UNSIGNED_SHORT:  Datatype  =  UNSIGNED_SHORT
\fBDatatype\fP \fBUNSIGNED_SHORT\fP
.UNINDENT
.SS mpi4py.MPI.UNSIGNED
.INDENT 0.0
.TP
.B mpi4py.MPI.UNSIGNED:  Datatype  =  UNSIGNED
\fBDatatype\fP \fBUNSIGNED\fP
.UNINDENT
.SS mpi4py.MPI.UNSIGNED_LONG
.INDENT 0.0
.TP
.B mpi4py.MPI.UNSIGNED_LONG:  Datatype  =  UNSIGNED_LONG
\fBDatatype\fP \fBUNSIGNED_LONG\fP
.UNINDENT
.SS mpi4py.MPI.UNSIGNED_LONG_LONG
.INDENT 0.0
.TP
.B mpi4py.MPI.UNSIGNED_LONG_LONG:  Datatype  =  UNSIGNED_LONG_LONG
\fBDatatype\fP \fBUNSIGNED_LONG_LONG\fP
.UNINDENT
.SS mpi4py.MPI.FLOAT
.INDENT 0.0
.TP
.B mpi4py.MPI.FLOAT:  Datatype  =  FLOAT
\fBDatatype\fP \fBFLOAT\fP
.UNINDENT
.SS mpi4py.MPI.DOUBLE
.INDENT 0.0
.TP
.B mpi4py.MPI.DOUBLE:  Datatype  =  DOUBLE
\fBDatatype\fP \fBDOUBLE\fP
.UNINDENT
.SS mpi4py.MPI.LONG_DOUBLE
.INDENT 0.0
.TP
.B mpi4py.MPI.LONG_DOUBLE:  Datatype  =  LONG_DOUBLE
\fBDatatype\fP \fBLONG_DOUBLE\fP
.UNINDENT
.SS mpi4py.MPI.C_BOOL
.INDENT 0.0
.TP
.B mpi4py.MPI.C_BOOL:  Datatype  =  C_BOOL
\fBDatatype\fP \fBC_BOOL\fP
.UNINDENT
.SS mpi4py.MPI.INT8_T
.INDENT 0.0
.TP
.B mpi4py.MPI.INT8_T:  Datatype  =  INT8_T
\fBDatatype\fP \fBINT8_T\fP
.UNINDENT
.SS mpi4py.MPI.INT16_T
.INDENT 0.0
.TP
.B mpi4py.MPI.INT16_T:  Datatype  =  INT16_T
\fBDatatype\fP \fBINT16_T\fP
.UNINDENT
.SS mpi4py.MPI.INT32_T
.INDENT 0.0
.TP
.B mpi4py.MPI.INT32_T:  Datatype  =  INT32_T
\fBDatatype\fP \fBINT32_T\fP
.UNINDENT
.SS mpi4py.MPI.INT64_T
.INDENT 0.0
.TP
.B mpi4py.MPI.INT64_T:  Datatype  =  INT64_T
\fBDatatype\fP \fBINT64_T\fP
.UNINDENT
.SS mpi4py.MPI.UINT8_T
.INDENT 0.0
.TP
.B mpi4py.MPI.UINT8_T:  Datatype  =  UINT8_T
\fBDatatype\fP \fBUINT8_T\fP
.UNINDENT
.SS mpi4py.MPI.UINT16_T
.INDENT 0.0
.TP
.B mpi4py.MPI.UINT16_T:  Datatype  =  UINT16_T
\fBDatatype\fP \fBUINT16_T\fP
.UNINDENT
.SS mpi4py.MPI.UINT32_T
.INDENT 0.0
.TP
.B mpi4py.MPI.UINT32_T:  Datatype  =  UINT32_T
\fBDatatype\fP \fBUINT32_T\fP
.UNINDENT
.SS mpi4py.MPI.UINT64_T
.INDENT 0.0
.TP
.B mpi4py.MPI.UINT64_T:  Datatype  =  UINT64_T
\fBDatatype\fP \fBUINT64_T\fP
.UNINDENT
.SS mpi4py.MPI.C_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.C_COMPLEX:  Datatype  =  C_COMPLEX
\fBDatatype\fP \fBC_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.C_FLOAT_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.C_FLOAT_COMPLEX:  Datatype  =  C_FLOAT_COMPLEX
\fBDatatype\fP \fBC_FLOAT_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.C_DOUBLE_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.C_DOUBLE_COMPLEX:  Datatype  =  C_DOUBLE_COMPLEX
\fBDatatype\fP \fBC_DOUBLE_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.C_LONG_DOUBLE_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.C_LONG_DOUBLE_COMPLEX:  Datatype  =  C_LONG_DOUBLE_COMPLEX
\fBDatatype\fP \fBC_LONG_DOUBLE_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.CXX_BOOL
.INDENT 0.0
.TP
.B mpi4py.MPI.CXX_BOOL:  Datatype  =  CXX_BOOL
\fBDatatype\fP \fBCXX_BOOL\fP
.UNINDENT
.SS mpi4py.MPI.CXX_FLOAT_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.CXX_FLOAT_COMPLEX:  Datatype  =  CXX_FLOAT_COMPLEX
\fBDatatype\fP \fBCXX_FLOAT_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.CXX_DOUBLE_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.CXX_DOUBLE_COMPLEX:  Datatype  =  CXX_DOUBLE_COMPLEX
\fBDatatype\fP \fBCXX_DOUBLE_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.CXX_LONG_DOUBLE_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.CXX_LONG_DOUBLE_COMPLEX:  Datatype  =  CXX_LONG_DOUBLE_COMPLEX
\fBDatatype\fP \fBCXX_LONG_DOUBLE_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.SHORT_INT
.INDENT 0.0
.TP
.B mpi4py.MPI.SHORT_INT:  Datatype  =  SHORT_INT
\fBDatatype\fP \fBSHORT_INT\fP
.UNINDENT
.SS mpi4py.MPI.INT_INT
.INDENT 0.0
.TP
.B mpi4py.MPI.INT_INT:  Datatype  =  INT_INT
\fBDatatype\fP \fBINT_INT\fP
.UNINDENT
.SS mpi4py.MPI.TWOINT
.INDENT 0.0
.TP
.B mpi4py.MPI.TWOINT:  Datatype  =  TWOINT
\fBDatatype\fP \fBTWOINT\fP
.UNINDENT
.SS mpi4py.MPI.LONG_INT
.INDENT 0.0
.TP
.B mpi4py.MPI.LONG_INT:  Datatype  =  LONG_INT
\fBDatatype\fP \fBLONG_INT\fP
.UNINDENT
.SS mpi4py.MPI.FLOAT_INT
.INDENT 0.0
.TP
.B mpi4py.MPI.FLOAT_INT:  Datatype  =  FLOAT_INT
\fBDatatype\fP \fBFLOAT_INT\fP
.UNINDENT
.SS mpi4py.MPI.DOUBLE_INT
.INDENT 0.0
.TP
.B mpi4py.MPI.DOUBLE_INT:  Datatype  =  DOUBLE_INT
\fBDatatype\fP \fBDOUBLE_INT\fP
.UNINDENT
.SS mpi4py.MPI.LONG_DOUBLE_INT
.INDENT 0.0
.TP
.B mpi4py.MPI.LONG_DOUBLE_INT:  Datatype  =  LONG_DOUBLE_INT
\fBDatatype\fP \fBLONG_DOUBLE_INT\fP
.UNINDENT
.SS mpi4py.MPI.CHARACTER
.INDENT 0.0
.TP
.B mpi4py.MPI.CHARACTER:  Datatype  =  CHARACTER
\fBDatatype\fP \fBCHARACTER\fP
.UNINDENT
.SS mpi4py.MPI.LOGICAL
.INDENT 0.0
.TP
.B mpi4py.MPI.LOGICAL:  Datatype  =  LOGICAL
\fBDatatype\fP \fBLOGICAL\fP
.UNINDENT
.SS mpi4py.MPI.INTEGER
.INDENT 0.0
.TP
.B mpi4py.MPI.INTEGER:  Datatype  =  INTEGER
\fBDatatype\fP \fBINTEGER\fP
.UNINDENT
.SS mpi4py.MPI.REAL
.INDENT 0.0
.TP
.B mpi4py.MPI.REAL:  Datatype  =  REAL
\fBDatatype\fP \fBREAL\fP
.UNINDENT
.SS mpi4py.MPI.DOUBLE_PRECISION
.INDENT 0.0
.TP
.B mpi4py.MPI.DOUBLE_PRECISION:  Datatype  =  DOUBLE_PRECISION
\fBDatatype\fP \fBDOUBLE_PRECISION\fP
.UNINDENT
.SS mpi4py.MPI.COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.COMPLEX:  Datatype  =  COMPLEX
\fBDatatype\fP \fBCOMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.DOUBLE_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.DOUBLE_COMPLEX:  Datatype  =  DOUBLE_COMPLEX
\fBDatatype\fP \fBDOUBLE_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.LOGICAL1
.INDENT 0.0
.TP
.B mpi4py.MPI.LOGICAL1:  Datatype  =  LOGICAL1
\fBDatatype\fP \fBLOGICAL1\fP
.UNINDENT
.SS mpi4py.MPI.LOGICAL2
.INDENT 0.0
.TP
.B mpi4py.MPI.LOGICAL2:  Datatype  =  LOGICAL2
\fBDatatype\fP \fBLOGICAL2\fP
.UNINDENT
.SS mpi4py.MPI.LOGICAL4
.INDENT 0.0
.TP
.B mpi4py.MPI.LOGICAL4:  Datatype  =  LOGICAL4
\fBDatatype\fP \fBLOGICAL4\fP
.UNINDENT
.SS mpi4py.MPI.LOGICAL8
.INDENT 0.0
.TP
.B mpi4py.MPI.LOGICAL8:  Datatype  =  LOGICAL8
\fBDatatype\fP \fBLOGICAL8\fP
.UNINDENT
.SS mpi4py.MPI.INTEGER1
.INDENT 0.0
.TP
.B mpi4py.MPI.INTEGER1:  Datatype  =  INTEGER1
\fBDatatype\fP \fBINTEGER1\fP
.UNINDENT
.SS mpi4py.MPI.INTEGER2
.INDENT 0.0
.TP
.B mpi4py.MPI.INTEGER2:  Datatype  =  INTEGER2
\fBDatatype\fP \fBINTEGER2\fP
.UNINDENT
.SS mpi4py.MPI.INTEGER4
.INDENT 0.0
.TP
.B mpi4py.MPI.INTEGER4:  Datatype  =  INTEGER4
\fBDatatype\fP \fBINTEGER4\fP
.UNINDENT
.SS mpi4py.MPI.INTEGER8
.INDENT 0.0
.TP
.B mpi4py.MPI.INTEGER8:  Datatype  =  INTEGER8
\fBDatatype\fP \fBINTEGER8\fP
.UNINDENT
.SS mpi4py.MPI.INTEGER16
.INDENT 0.0
.TP
.B mpi4py.MPI.INTEGER16:  Datatype  =  INTEGER16
\fBDatatype\fP \fBINTEGER16\fP
.UNINDENT
.SS mpi4py.MPI.REAL2
.INDENT 0.0
.TP
.B mpi4py.MPI.REAL2:  Datatype  =  REAL2
\fBDatatype\fP \fBREAL2\fP
.UNINDENT
.SS mpi4py.MPI.REAL4
.INDENT 0.0
.TP
.B mpi4py.MPI.REAL4:  Datatype  =  REAL4
\fBDatatype\fP \fBREAL4\fP
.UNINDENT
.SS mpi4py.MPI.REAL8
.INDENT 0.0
.TP
.B mpi4py.MPI.REAL8:  Datatype  =  REAL8
\fBDatatype\fP \fBREAL8\fP
.UNINDENT
.SS mpi4py.MPI.REAL16
.INDENT 0.0
.TP
.B mpi4py.MPI.REAL16:  Datatype  =  REAL16
\fBDatatype\fP \fBREAL16\fP
.UNINDENT
.SS mpi4py.MPI.COMPLEX4
.INDENT 0.0
.TP
.B mpi4py.MPI.COMPLEX4:  Datatype  =  COMPLEX4
\fBDatatype\fP \fBCOMPLEX4\fP
.UNINDENT
.SS mpi4py.MPI.COMPLEX8
.INDENT 0.0
.TP
.B mpi4py.MPI.COMPLEX8:  Datatype  =  COMPLEX8
\fBDatatype\fP \fBCOMPLEX8\fP
.UNINDENT
.SS mpi4py.MPI.COMPLEX16
.INDENT 0.0
.TP
.B mpi4py.MPI.COMPLEX16:  Datatype  =  COMPLEX16
\fBDatatype\fP \fBCOMPLEX16\fP
.UNINDENT
.SS mpi4py.MPI.COMPLEX32
.INDENT 0.0
.TP
.B mpi4py.MPI.COMPLEX32:  Datatype  =  COMPLEX32
\fBDatatype\fP \fBCOMPLEX32\fP
.UNINDENT
.SS mpi4py.MPI.UNSIGNED_INT
.INDENT 0.0
.TP
.B mpi4py.MPI.UNSIGNED_INT:  Datatype  =  UNSIGNED_INT
\fBDatatype\fP \fBUNSIGNED_INT\fP
.UNINDENT
.SS mpi4py.MPI.SIGNED_SHORT
.INDENT 0.0
.TP
.B mpi4py.MPI.SIGNED_SHORT:  Datatype  =  SIGNED_SHORT
\fBDatatype\fP \fBSIGNED_SHORT\fP
.UNINDENT
.SS mpi4py.MPI.SIGNED_INT
.INDENT 0.0
.TP
.B mpi4py.MPI.SIGNED_INT:  Datatype  =  SIGNED_INT
\fBDatatype\fP \fBSIGNED_INT\fP
.UNINDENT
.SS mpi4py.MPI.SIGNED_LONG
.INDENT 0.0
.TP
.B mpi4py.MPI.SIGNED_LONG:  Datatype  =  SIGNED_LONG
\fBDatatype\fP \fBSIGNED_LONG\fP
.UNINDENT
.SS mpi4py.MPI.SIGNED_LONG_LONG
.INDENT 0.0
.TP
.B mpi4py.MPI.SIGNED_LONG_LONG:  Datatype  =  SIGNED_LONG_LONG
\fBDatatype\fP \fBSIGNED_LONG_LONG\fP
.UNINDENT
.SS mpi4py.MPI.BOOL
.INDENT 0.0
.TP
.B mpi4py.MPI.BOOL:  Datatype  =  BOOL
\fBDatatype\fP \fBBOOL\fP
.UNINDENT
.SS mpi4py.MPI.SINT8_T
.INDENT 0.0
.TP
.B mpi4py.MPI.SINT8_T:  Datatype  =  SINT8_T
\fBDatatype\fP \fBSINT8_T\fP
.UNINDENT
.SS mpi4py.MPI.SINT16_T
.INDENT 0.0
.TP
.B mpi4py.MPI.SINT16_T:  Datatype  =  SINT16_T
\fBDatatype\fP \fBSINT16_T\fP
.UNINDENT
.SS mpi4py.MPI.SINT32_T
.INDENT 0.0
.TP
.B mpi4py.MPI.SINT32_T:  Datatype  =  SINT32_T
\fBDatatype\fP \fBSINT32_T\fP
.UNINDENT
.SS mpi4py.MPI.SINT64_T
.INDENT 0.0
.TP
.B mpi4py.MPI.SINT64_T:  Datatype  =  SINT64_T
\fBDatatype\fP \fBSINT64_T\fP
.UNINDENT
.SS mpi4py.MPI.F_BOOL
.INDENT 0.0
.TP
.B mpi4py.MPI.F_BOOL:  Datatype  =  F_BOOL
\fBDatatype\fP \fBF_BOOL\fP
.UNINDENT
.SS mpi4py.MPI.F_INT
.INDENT 0.0
.TP
.B mpi4py.MPI.F_INT:  Datatype  =  F_INT
\fBDatatype\fP \fBF_INT\fP
.UNINDENT
.SS mpi4py.MPI.F_FLOAT
.INDENT 0.0
.TP
.B mpi4py.MPI.F_FLOAT:  Datatype  =  F_FLOAT
\fBDatatype\fP \fBF_FLOAT\fP
.UNINDENT
.SS mpi4py.MPI.F_DOUBLE
.INDENT 0.0
.TP
.B mpi4py.MPI.F_DOUBLE:  Datatype  =  F_DOUBLE
\fBDatatype\fP \fBF_DOUBLE\fP
.UNINDENT
.SS mpi4py.MPI.F_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.F_COMPLEX:  Datatype  =  F_COMPLEX
\fBDatatype\fP \fBF_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.F_FLOAT_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.F_FLOAT_COMPLEX:  Datatype  =  F_FLOAT_COMPLEX
\fBDatatype\fP \fBF_FLOAT_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.F_DOUBLE_COMPLEX
.INDENT 0.0
.TP
.B mpi4py.MPI.F_DOUBLE_COMPLEX:  Datatype  =  F_DOUBLE_COMPLEX
\fBDatatype\fP \fBF_DOUBLE_COMPLEX\fP
.UNINDENT
.SS mpi4py.MPI.REQUEST_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.REQUEST_NULL:  Request  =  REQUEST_NULL
\fBRequest\fP \fBREQUEST_NULL\fP
.UNINDENT
.SS mpi4py.MPI.MESSAGE_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.MESSAGE_NULL:  Message  =  MESSAGE_NULL
\fBMessage\fP \fBMESSAGE_NULL\fP
.UNINDENT
.SS mpi4py.MPI.MESSAGE_NO_PROC
.INDENT 0.0
.TP
.B mpi4py.MPI.MESSAGE_NO_PROC:  Message  =  MESSAGE_NO_PROC
\fBMessage\fP \fBMESSAGE_NO_PROC\fP
.UNINDENT
.SS mpi4py.MPI.OP_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.OP_NULL:  Op  =  OP_NULL
\fBOp\fP \fBOP_NULL\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.MAX
.INDENT 0.0
.TP
.B mpi4py.MPI.MAX:  Op  =  MAX
\fBOp\fP \fBMAX\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.MIN
.INDENT 0.0
.TP
.B mpi4py.MPI.MIN:  Op  =  MIN
\fBOp\fP \fBMIN\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.SUM
.INDENT 0.0
.TP
.B mpi4py.MPI.SUM:  Op  =  SUM
\fBOp\fP \fBSUM\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.PROD
.INDENT 0.0
.TP
.B mpi4py.MPI.PROD:  Op  =  PROD
\fBOp\fP \fBPROD\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.LAND
.INDENT 0.0
.TP
.B mpi4py.MPI.LAND:  Op  =  LAND
\fBOp\fP \fBLAND\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.BAND
.INDENT 0.0
.TP
.B mpi4py.MPI.BAND:  Op  =  BAND
\fBOp\fP \fBBAND\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.LOR
.INDENT 0.0
.TP
.B mpi4py.MPI.LOR:  Op  =  LOR
\fBOp\fP \fBLOR\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.BOR
.INDENT 0.0
.TP
.B mpi4py.MPI.BOR:  Op  =  BOR
\fBOp\fP \fBBOR\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.LXOR
.INDENT 0.0
.TP
.B mpi4py.MPI.LXOR:  Op  =  LXOR
\fBOp\fP \fBLXOR\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.BXOR
.INDENT 0.0
.TP
.B mpi4py.MPI.BXOR:  Op  =  BXOR
\fBOp\fP \fBBXOR\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.MAXLOC
.INDENT 0.0
.TP
.B mpi4py.MPI.MAXLOC:  Op  =  MAXLOC
\fBOp\fP \fBMAXLOC\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.MINLOC
.INDENT 0.0
.TP
.B mpi4py.MPI.MINLOC:  Op  =  MINLOC
\fBOp\fP \fBMINLOC\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.REPLACE
.INDENT 0.0
.TP
.B mpi4py.MPI.REPLACE:  Op  =  REPLACE
\fBOp\fP \fBREPLACE\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.NO_OP
.INDENT 0.0
.TP
.B mpi4py.MPI.NO_OP:  Op  =  NO_OP
\fBOp\fP \fBNO_OP\fP
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP (\fIAny\fP) – 
.IP \(bu 2
\fBy\fP (\fIAny\fP) – 
.UNINDENT
.TP
.B Return type
Any
.UNINDENT
.UNINDENT
.SS mpi4py.MPI.GROUP_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.GROUP_NULL:  Group  =  GROUP_NULL
\fBGroup\fP \fBGROUP_NULL\fP
.UNINDENT
.SS mpi4py.MPI.GROUP_EMPTY
.INDENT 0.0
.TP
.B mpi4py.MPI.GROUP_EMPTY:  Group  =  GROUP_EMPTY
\fBGroup\fP \fBGROUP_EMPTY\fP
.UNINDENT
.SS mpi4py.MPI.INFO_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.INFO_NULL:  Info  =  INFO_NULL
\fBInfo\fP \fBINFO_NULL\fP
.UNINDENT
.SS mpi4py.MPI.INFO_ENV
.INDENT 0.0
.TP
.B mpi4py.MPI.INFO_ENV:  Info  =  INFO_ENV
\fBInfo\fP \fBINFO_ENV\fP
.UNINDENT
.SS mpi4py.MPI.ERRHANDLER_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.ERRHANDLER_NULL:  Errhandler  =  ERRHANDLER_NULL
\fBErrhandler\fP \fBERRHANDLER_NULL\fP
.UNINDENT
.SS mpi4py.MPI.ERRORS_RETURN
.INDENT 0.0
.TP
.B mpi4py.MPI.ERRORS_RETURN:  Errhandler  =  ERRORS_RETURN
\fBErrhandler\fP \fBERRORS_RETURN\fP
.UNINDENT
.SS mpi4py.MPI.ERRORS_ARE_FATAL
.INDENT 0.0
.TP
.B mpi4py.MPI.ERRORS_ARE_FATAL:  Errhandler  =  ERRORS_ARE_FATAL
\fBErrhandler\fP \fBERRORS_ARE_FATAL\fP
.UNINDENT
.SS mpi4py.MPI.COMM_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.COMM_NULL:  Comm  =  COMM_NULL
\fBComm\fP \fBCOMM_NULL\fP
.UNINDENT
.SS mpi4py.MPI.COMM_SELF
.INDENT 0.0
.TP
.B mpi4py.MPI.COMM_SELF:  Intracomm  =  COMM_SELF
\fBIntracomm\fP \fBCOMM_SELF\fP
.UNINDENT
.SS mpi4py.MPI.COMM_WORLD
.INDENT 0.0
.TP
.B mpi4py.MPI.COMM_WORLD:  Intracomm  =  COMM_WORLD
\fBIntracomm\fP \fBCOMM_WORLD\fP
.UNINDENT
.SS mpi4py.MPI.WIN_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.WIN_NULL:  Win  =  WIN_NULL
\fBWin\fP \fBWIN_NULL\fP
.UNINDENT
.SS mpi4py.MPI.FILE_NULL
.INDENT 0.0
.TP
.B mpi4py.MPI.FILE_NULL:  File  =  FILE_NULL
\fBFile\fP \fBFILE_NULL\fP
.UNINDENT
.SS mpi4py.MPI.pickle
.INDENT 0.0
.TP
.B mpi4py.MPI.pickle:  Pickle  =  <mpi4py.MPI.Pickle object>
\fBPickle\fP \fBpickle\fP
.UNINDENT
.SH CITATION
.sp
If MPI for Python been significant to a project that leads to an
academic publication, please acknowledge that fact by citing the
project.
.INDENT 0.0
.IP \(bu 2
L. Dalcin and Y.\-L. L. Fang,
\fImpi4py: Status Update After 12 Years of Development\fP,
Computing in Science & Engineering, 23(4):47\-54, 2021.
\fI\%https://doi.org/10.1109/MCSE.2021.3083216\fP
.IP \(bu 2
L. Dalcin, P. Kler, R. Paz, and A. Cosimo,
\fIParallel Distributed Computing using Python\fP,
Advances in Water Resources, 34(9):1124\-1139, 2011.
\fI\%https://doi.org/10.1016/j.advwatres.2011.04.013\fP
.IP \(bu 2
L. Dalcin, R. Paz, M. Storti, and J. D’Elia,
\fIMPI for Python: performance improvements and MPI\-2 extensions\fP,
Journal of Parallel and Distributed Computing, 68(5):655\-662, 2008.
\fI\%https://doi.org/10.1016/j.jpdc.2007.09.005\fP
.IP \(bu 2
L. Dalcin, R. Paz, and M. Storti,
\fIMPI for Python\fP,
Journal of Parallel and Distributed Computing, 65(9):1108\-1115, 2005.
\fI\%https://doi.org/10.1016/j.jpdc.2005.03.010\fP
.UNINDENT
.SH INSTALLATION
.SS Requirements
.sp
You need to have the following software properly installed in order to
build \fIMPI for Python\fP:
.INDENT 0.0
.IP \(bu 2
A working MPI implementation, preferably supporting MPI\-3 and built
with shared/dynamic libraries.
.sp
\fBNOTE:\fP
.INDENT 2.0
.INDENT 3.5
If you want to build some MPI implementation from sources,
check the instructions at building\-mpi in the appendix.
.UNINDENT
.UNINDENT
.IP \(bu 2
Python 2.7, 3.5 or above.
.sp
\fBNOTE:\fP
.INDENT 2.0
.INDENT 3.5
Some MPI\-1 implementations \fBdo require\fP the actual
command line arguments to be passed in \fBMPI_Init()\fP\&. In
this case, you will need to use a rebuilt, MPI\-enabled, Python
interpreter executable. \fIMPI for Python\fP has some support for
alleviating you from this task. Check the instructions at
python\-mpi in the appendix.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Using \fBpip\fP
.sp
If you already have a working MPI (either if you installed it from
sources or by using a pre\-built package from your favourite GNU/Linux
distribution) and the \fBmpicc\fP compiler wrapper is on your
search path, you can use \fBpip\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python \-m pip install mpi4py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
If the \fBmpicc\fP compiler wrapper is not on your
search path (or if it has a different name) you can use
\fBenv\fP to pass the environment variable \fBMPICC\fP
providing the full path to the MPI compiler wrapper executable:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ env MPICC=/path/to/mpicc python \-m pip install mpi4py
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
\fBpip\fP keeps previouly built wheel files on its cache for
future reuse. If you want to reinstall the \fBmpi4py\fP package
using a different or updated MPI implementation, you have to either
first remove the cached wheel file with:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python \-m pip cache remove mpi4py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
or ask \fBpip\fP to disable the cache:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python \-m pip install \-\-no\-cache\-dir mpi4py
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Using \fBdistutils\fP
.sp
The \fIMPI for Python\fP package is available for download at the project
website generously hosted by GitHub. You can use \fBcurl\fP
or \fBwget\fP to get a release tarball.
.INDENT 0.0
.IP \(bu 2
Using \fBcurl\fP:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
$ curl \-O https://github.com/mpi4py/mpi4py/releases/download/X.Y.Z/mpi4py\-X.Y.Z.tar.gz
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
Using \fBwget\fP:
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
$ wget https://github.com/mpi4py/mpi4py/releases/download/X.Y.Z/mpi4py\-X.Y.Z.tar.gz
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
After unpacking the release tarball:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ tar \-zxf mpi4py\-X.Y.Z.tar.gz
$ cd mpi4py\-X.Y.Z
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
the package is ready for building.
.sp
\fIMPI for Python\fP uses a standard distutils\-based build system. However,
some distutils commands (like \fIbuild\fP) have additional options:
.INDENT 0.0
.TP
.B \-\-mpicc=
Lets you specify a special location or name for the
\fBmpicc\fP compiler wrapper.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-mpi=
Lets you pass a section with MPI configuration within a special
configuration file.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-configure
Runs exhaustive tests for checking about missing MPI types,
constants, and functions. This option should be passed in order to
build \fIMPI for Python\fP against old MPI\-1 or MPI\-2 implementations,
possibly providing a subset of MPI\-3.
.UNINDENT
.sp
If you use a MPI implementation providing a \fBmpicc\fP compiler
wrapper (e.g., MPICH, Open MPI), it will be used for compilation and
linking. This is the preferred and easiest way of building \fIMPI for
Python\fP\&.
.sp
If \fBmpicc\fP is located somewhere in your search path, simply
run the \fIbuild\fP command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python setup.py build
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If \fBmpicc\fP is not in your search path or the compiler wrapper
has a different name, you can run the \fIbuild\fP command specifying its
location:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python setup.py build \-\-mpicc=/where/you/have/mpicc
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Alternatively, you can provide all the relevant information about your
MPI implementation by editing the file called \fBmpi.cfg\fP\&. You can
use the default section \fB[mpi]\fP or add a new, custom section, for
example \fB[other_mpi]\fP (see the examples provided in the
\fBmpi.cfg\fP file as a starting point to write your own section):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[mpi]

include_dirs         = /usr/local/mpi/include
libraries            = mpi
library_dirs         = /usr/local/mpi/lib
runtime_library_dirs = /usr/local/mpi/lib

[other_mpi]

include_dirs         = /opt/mpi/include ...
libraries            = mpi ...
library_dirs         = /opt/mpi/lib ...
runtime_library_dirs = /op/mpi/lib ...

\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
and then run the \fIbuild\fP command, perhaps specifying you custom
configuration section:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python setup.py build \-\-mpi=other_mpi
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After building, the package is ready for install.
.sp
If you have root privileges (either by log\-in as the root user of by
using \fBsudo\fP) and you want to install \fIMPI for Python\fP in
your system for all users, just do:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python setup.py install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The previous steps will install the \fBmpi4py\fP package at standard
location \fIprefix\fP\fB/lib/python\fP\fIX\fP\fB\&.\fP\fIX\fP\fB/site\-packages\fP\&.
.sp
If you do not have root privileges or you want to install \fIMPI for
Python\fP for your private use, just do:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python setup.py install \-\-user
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Testing
.sp
To quickly test the installation:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpiexec \-n 5 python \-m mpi4py.bench helloworld
Hello, World! I am process 0 of 5 on localhost.
Hello, World! I am process 1 of 5 on localhost.
Hello, World! I am process 2 of 5 on localhost.
Hello, World! I am process 3 of 5 on localhost.
Hello, World! I am process 4 of 5 on localhost.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you installed from source, issuing at the command line:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpiexec \-n 5 python demo/helloworld.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
or (in the case of ancient MPI\-1 implementations):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpirun \-np 5 python \(gapwd\(ga/demo/helloworld.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will launch a five\-process run of the Python interpreter and run the
test script \fBdemo/helloworld.py\fP from the source distribution.
.sp
You can also run all the \fIunittest\fP scripts:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpiexec \-n 5 python test/runtests.py
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
or, if you have \fI\%nose\fP unit testing framework installed:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpiexec \-n 5 nosetests \-w test
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
or, if you have \fI\%py.test\fP unit testing framework installed:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ mpiexec \-n 5 py.test test/
.ft P
.fi
.UNINDENT
.UNINDENT
.SH APPENDIX
.SS MPI\-enabled Python interpreter
.INDENT 0.0
.INDENT 3.5
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
These days it is no longer required to use the MPI\-enabled Python
interpreter in most cases, and, therefore, it is not built by
default anymore because it is too difficult to reliably build a
Python interpreter across different distributions.  If you know
that you still \fBreally\fP need it, see below on how to use the
\fBbuild_exe\fP and \fBinstall_exe\fP commands.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Some MPI\-1 implementations (notably, MPICH 1) \fBdo require\fP the
actual command line arguments to be passed at the time
\fBMPI_Init()\fP is called. In this case, you will need to use a
re\-built, MPI\-enabled, Python interpreter binary executable. A basic
implementation (targeting Python 2.X) of what is required is shown
below:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <Python.h>
#include <mpi.h>

int main(int argc, char *argv[])
{
   int status, flag;
   MPI_Init(&argc, &argv);
   status = Py_Main(argc, argv);
   MPI_Finalized(&flag);
   if (!flag) MPI_Finalize();
   return status;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The source code above is straightforward; compiling it should also
be. However, the linking step is more tricky: special flags have to be
passed to the linker depending on your platform. In order to alleviate
you for such low\-level details, \fIMPI for Python\fP provides some
pure\-distutils based support to build and install an MPI\-enabled
Python interpreter executable:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cd mpi4py\-X.X.X
$ python setup.py build_exe [\-\-mpi=<name>|\-\-mpicc=/path/to/mpicc]
$ [sudo] python setup.py install_exe [\-\-install\-dir=$HOME/bin]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the above steps you should have the MPI\-enabled interpreter
installed as \fIprefix\fP\fB/bin/python\fP\fIX\fP\fB\&.\fP\fIX\fP\fB\-mpi\fP (or
\fB$HOME/bin/python\fP\fIX\fP\fB\&.\fP\fIX\fP\fB\-mpi\fP). Assuming that
\fIprefix\fP\fB/bin\fP (or \fB$HOME/bin\fP) is listed on your
\fBPATH\fP, you should be able to enter your MPI\-enabled Python
interactively, for example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ python2.7\-mpi
Python 2.7.8 (default, Nov 10 2014, 08:19:18)
[GCC 4.9.2 20141101 (Red Hat 4.9.2\-1)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> sys.executable
\(aq/usr/bin/python2.7\-mpi\(aq
>>>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Building MPI from sources
.sp
In the list below you have some executive instructions for building
some of the open\-source MPI implementations out there with support for
shared/dynamic libraries on POSIX environments.
.INDENT 0.0
.IP \(bu 2
\fIMPICH\fP
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
$ tar \-zxf mpich\-X.X.X.tar.gz
$ cd mpich\-X.X.X
$ ./configure \-\-enable\-shared \-\-prefix=/usr/local/mpich
$ make
$ make install
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
\fIOpen MPI\fP
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
$ tar \-zxf openmpi\-X.X.X tar.gz
$ cd openmpi\-X.X.X
$ ./configure \-\-prefix=/usr/local/openmpi
$ make all
$ make install
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
\fIMPICH 1\fP
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
$ tar \-zxf mpich\-X.X.X.tar.gz
$ cd mpich\-X.X.X
$ ./configure \-\-enable\-sharedlib \-\-prefix=/usr/local/mpich1
$ make
$ make install
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Perhaps you will need to set the \fBLD_LIBRARY_PATH\fP
environment variable (using \fBexport\fP, \fBsetenv\fP or
what applies to your system) pointing to the directory containing the
MPI libraries . In case of getting runtime linking errors when running
MPI programs, the following lines can be added to the user login shell
script (\fB\&.profile\fP, \fB\&.bashrc\fP, etc.).
.INDENT 0.0
.IP \(bu 2
\fIMPICH\fP
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
MPI_DIR=/usr/local/mpich
export LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
\fIOpen MPI\fP
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
MPI_DIR=/usr/local/openmpi
export LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH
.ft P
.fi
.UNINDENT
.UNINDENT
.IP \(bu 2
\fIMPICH 1\fP
.INDENT 2.0
.INDENT 3.5
.sp
.nf
.ft C
MPI_DIR=/usr/local/mpich1
export LD_LIBRARY_PATH=$MPI_DIR/lib/shared:$LD_LIBRARY_PATH:
export MPICH_USE_SHLIB=yes
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 2.0
.INDENT 3.5
MPICH 1 support for dynamic libraries is not completely
transparent. Users should set the environment variable
\fBMPICH_USE_SHLIB\fP to \fByes\fP in order to avoid link
problems when using the \fBmpicc\fP compiler wrapper.
.UNINDENT
.UNINDENT
.UNINDENT
.SH AUTHOR
Lisandro Dalcin
.SH COPYRIGHT
2021, Lisandro Dalcin
.\" Generated by docutils manpage writer.
.
